(function () { const x = document.createElement("link").relList; if (x && x.supports && x.supports("modulepreload")) return; for (const F of document.querySelectorAll('link[rel="modulepreload"]')) z(F); new MutationObserver(F => { for (const Z of F) if (Z.type === "childList") for (const P of Z.addedNodes) P.tagName === "LINK" && P.rel === "modulepreload" && z(P) }).observe(document, { childList: !0, subtree: !0 }); function S(F) { const Z = {}; return F.integrity && (Z.integrity = F.integrity), F.referrerPolicy && (Z.referrerPolicy = F.referrerPolicy), F.crossOrigin === "use-credentials" ? Z.credentials = "include" : F.crossOrigin === "anonymous" ? Z.credentials = "omit" : Z.credentials = "same-origin", Z } function z(F) { if (F.ep) return; F.ep = !0; const Z = S(F); fetch(F.href, Z) } })();/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Vd(m) { const x = Object.create(null); for (const S of m.split(",")) x[S] = 1; return S => S in x } const ci = {}, La = [], jn = () => { }, ty = () => !1, Ju = m => m.charCodeAt(0) === 111 && m.charCodeAt(1) === 110 && (m.charCodeAt(2) > 122 || m.charCodeAt(2) < 97), Nd = m => m.startsWith("onUpdate:"), yr = Object.assign, Zd = (m, x) => { const S = m.indexOf(x); S > -1 && m.splice(S, 1) }, iy = Object.prototype.hasOwnProperty, Kt = (m, x) => iy.call(m, x), It = Array.isArray, uc = m => Yu(m) === "[object Map]", ry = m => Yu(m) === "[object Set]", Mt = m => typeof m == "function", ir = m => typeof m == "string", Va = m => typeof m == "symbol", Ni = m => m !== null && typeof m == "object", _m = m => (Ni(m) || Mt(m)) && Mt(m.then) && Mt(m.catch), ny = Object.prototype.toString, Yu = m => ny.call(m), sy = m => Yu(m).slice(8, -1), oy = m => Yu(m) === "[object Object]", Ud = m => ir(m) && m !== "NaN" && m[0] !== "-" && "" + parseInt(m, 10) === m, hc = Vd(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Qu = m => { const x = Object.create(null); return S => x[S] || (x[S] = m(S)) }, ay = /-(\w)/g, Us = Qu(m => m.replace(ay, (x, S) => S ? S.toUpperCase() : "")), ly = /\B([A-Z])/g, So = Qu(m => m.replace(ly, "-$1").toLowerCase()), gm = Qu(m => m.charAt(0).toUpperCase() + m.slice(1)), yd = Qu(m => m ? `on${gm(m)}` : ""), To = (m, x) => !Object.is(m, x), xd = (m, ...x) => { for (let S = 0; S < m.length; S++)m[S](...x) }, ym = (m, x, S, z = !1) => { Object.defineProperty(m, x, { configurable: !0, enumerable: !1, writable: z, value: S }) }, cy = m => { const x = parseFloat(m); return isNaN(x) ? m : x }; let Nf; const eh = () => Nf || (Nf = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function $d(m) { if (It(m)) { const x = {}; for (let S = 0; S < m.length; S++) { const z = m[S], F = ir(z) ? py(z) : $d(z); if (F) for (const Z in F) x[Z] = F[Z] } return x } else if (ir(m) || Ni(m)) return m } const uy = /;(?![^(]*\))/g, hy = /:([^]+)/, dy = /\/\*[^]*?\*\//g; function py(m) { const x = {}; return m.replace(dy, "").split(uy).forEach(S => { if (S) { const z = S.split(hy); z.length > 1 && (x[z[0].trim()] = z[1].trim()) } }), x } function Gd(m) { let x = ""; if (ir(m)) x = m; else if (It(m)) for (let S = 0; S < m.length; S++) { const z = Gd(m[S]); z && (x += z + " ") } else if (Ni(m)) for (const S in m) m[S] && (x += S + " "); return x.trim() } const fy = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", my = Vd(fy); function xm(m) { return !!m || m === "" }/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let sn; class _y { constructor(x = !1) { this.detached = x, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = sn, !x && sn && (this.index = (sn.scopes || (sn.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let x, S; if (this.scopes) for (x = 0, S = this.scopes.length; x < S; x++)this.scopes[x].pause(); for (x = 0, S = this.effects.length; x < S; x++)this.effects[x].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let x, S; if (this.scopes) for (x = 0, S = this.scopes.length; x < S; x++)this.scopes[x].resume(); for (x = 0, S = this.effects.length; x < S; x++)this.effects[x].resume() } } run(x) { if (this._active) { const S = sn; try { return sn = this, x() } finally { sn = S } } } on() { sn = this } off() { sn = this.parent } stop(x) { if (this._active) { this._active = !1; let S, z; for (S = 0, z = this.effects.length; S < z; S++)this.effects[S].stop(); for (this.effects.length = 0, S = 0, z = this.cleanups.length; S < z; S++)this.cleanups[S](); if (this.cleanups.length = 0, this.scopes) { for (S = 0, z = this.scopes.length; S < z; S++)this.scopes[S].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !x) { const F = this.parent.scopes.pop(); F && F !== this && (this.parent.scopes[this.index] = F, F.index = this.index) } this.parent = void 0 } } } function gy() { return sn } let li; const vd = new WeakSet; class vm { constructor(x) { this.fn = x, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, sn && sn.active && sn.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, vd.has(this) && (vd.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || wm(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, Zf(this), Tm(this); const x = li, S = Tn; li = this, Tn = !0; try { return this.fn() } finally { Pm(this), li = x, Tn = S, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let x = this.deps; x; x = x.nextDep)Wd(x); this.deps = this.depsTail = void 0, Zf(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? vd.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { Ed(this) && this.run() } get dirty() { return Ed(this) } } let bm = 0, dc, pc; function wm(m, x = !1) { if (m.flags |= 8, x) { m.next = pc, pc = m; return } m.next = dc, dc = m } function qd() { bm++ } function Hd() { if (--bm > 0) return; if (pc) { let x = pc; for (pc = void 0; x;) { const S = x.next; x.next = void 0, x.flags &= -9, x = S } } let m; for (; dc;) { let x = dc; for (dc = void 0; x;) { const S = x.next; if (x.next = void 0, x.flags &= -9, x.flags & 1) try { x.trigger() } catch (z) { m || (m = z) } x = S } } if (m) throw m } function Tm(m) { for (let x = m.deps; x; x = x.nextDep)x.version = -1, x.prevActiveLink = x.dep.activeLink, x.dep.activeLink = x } function Pm(m) { let x, S = m.depsTail, z = S; for (; z;) { const F = z.prevDep; z.version === -1 ? (z === S && (S = F), Wd(z), yy(z)) : x = z, z.dep.activeLink = z.prevActiveLink, z.prevActiveLink = void 0, z = F } m.deps = x, m.depsTail = S } function Ed(m) { for (let x = m.deps; x; x = x.nextDep)if (x.dep.version !== x.version || x.dep.computed && (Sm(x.dep.computed) || x.dep.version !== x.version)) return !0; return !!m._dirty } function Sm(m) { if (m.flags & 4 && !(m.flags & 16) || (m.flags &= -17, m.globalVersion === yc)) return; m.globalVersion = yc; const x = m.dep; if (m.flags |= 2, x.version > 0 && !m.isSSR && m.deps && !Ed(m)) { m.flags &= -3; return } const S = li, z = Tn; li = m, Tn = !0; try { Tm(m); const F = m.fn(m._value); (x.version === 0 || To(F, m._value)) && (m._value = F, x.version++) } catch (F) { throw x.version++, F } finally { li = S, Tn = z, Pm(m), m.flags &= -3 } } function Wd(m, x = !1) { const { dep: S, prevSub: z, nextSub: F } = m; if (z && (z.nextSub = F, m.prevSub = void 0), F && (F.prevSub = z, m.nextSub = void 0), S.subs === m && (S.subs = z, !z && S.computed)) { S.computed.flags &= -5; for (let Z = S.computed.deps; Z; Z = Z.nextDep)Wd(Z, !0) } !x && !--S.sc && S.map && S.map.delete(S.key) } function yy(m) { const { prevDep: x, nextDep: S } = m; x && (x.nextDep = S, m.prevDep = void 0), S && (S.prevDep = x, m.nextDep = void 0) } let Tn = !0; const Mm = []; function $s() { Mm.push(Tn), Tn = !1 } function Gs() { const m = Mm.pop(); Tn = m === void 0 ? !0 : m } function Zf(m) { const { cleanup: x } = m; if (m.cleanup = void 0, x) { const S = li; li = void 0; try { x() } finally { li = S } } } let yc = 0; class xy { constructor(x, S) { this.sub = x, this.dep = S, this.version = S.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class Im { constructor(x) { this.computed = x, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0 } track(x) { if (!li || !Tn || li === this.computed) return; let S = this.activeLink; if (S === void 0 || S.sub !== li) S = this.activeLink = new xy(li, this), li.deps ? (S.prevDep = li.depsTail, li.depsTail.nextDep = S, li.depsTail = S) : li.deps = li.depsTail = S, Cm(S); else if (S.version === -1 && (S.version = this.version, S.nextDep)) { const z = S.nextDep; z.prevDep = S.prevDep, S.prevDep && (S.prevDep.nextDep = z), S.prevDep = li.depsTail, S.nextDep = void 0, li.depsTail.nextDep = S, li.depsTail = S, li.deps === S && (li.deps = z) } return S } trigger(x) { this.version++, yc++, this.notify(x) } notify(x) { qd(); try { for (let S = this.subs; S; S = S.prevSub)S.sub.notify() && S.sub.dep.notify() } finally { Hd() } } } function Cm(m) { if (m.dep.sc++, m.sub.flags & 4) { const x = m.dep.computed; if (x && !m.dep.subs) { x.flags |= 20; for (let z = x.deps; z; z = z.nextDep)Cm(z) } const S = m.dep.subs; S !== m && (m.prevSub = S, S && (S.nextSub = m)), m.dep.subs = m } } const Ad = new WeakMap, Po = Symbol(""), zd = Symbol(""), xc = Symbol(""); function gr(m, x, S) { if (Tn && li) { let z = Ad.get(m); z || Ad.set(m, z = new Map); let F = z.get(S); F || (z.set(S, F = new Im), F.map = z, F.key = S), F.track() } } function ds(m, x, S, z, F, Z) { const P = Ad.get(m); if (!P) { yc++; return } const c = de => { de && de.trigger() }; if (qd(), x === "clear") P.forEach(c); else { const de = It(m), ze = de && Ud(S); if (de && S === "length") { const xe = Number(z); P.forEach((Fe, Le) => { (Le === "length" || Le === xc || !Va(Le) && Le >= xe) && c(Fe) }) } else switch ((S !== void 0 || P.has(void 0)) && c(P.get(S)), ze && c(P.get(xc)), x) { case "add": de ? ze && c(P.get("length")) : (c(P.get(Po)), uc(m) && c(P.get(zd))); break; case "delete": de || (c(P.get(Po)), uc(m) && c(P.get(zd))); break; case "set": uc(m) && c(P.get(Po)); break } } Hd() } function ka(m) { const x = ii(m); return x === m ? x : (gr(x, "iterate", xc), Vn(m) ? x : x.map(on)) } function Xd(m) { return gr(m = ii(m), "iterate", xc), m } const vy = { __proto__: null, [Symbol.iterator]() { return bd(this, Symbol.iterator, on) }, concat(...m) { return ka(this).concat(...m.map(x => It(x) ? ka(x) : x)) }, entries() { return bd(this, "entries", m => (m[1] = on(m[1]), m)) }, every(m, x) { return cs(this, "every", m, x, void 0, arguments) }, filter(m, x) { return cs(this, "filter", m, x, S => S.map(on), arguments) }, find(m, x) { return cs(this, "find", m, x, on, arguments) }, findIndex(m, x) { return cs(this, "findIndex", m, x, void 0, arguments) }, findLast(m, x) { return cs(this, "findLast", m, x, on, arguments) }, findLastIndex(m, x) { return cs(this, "findLastIndex", m, x, void 0, arguments) }, forEach(m, x) { return cs(this, "forEach", m, x, void 0, arguments) }, includes(...m) { return wd(this, "includes", m) }, indexOf(...m) { return wd(this, "indexOf", m) }, join(m) { return ka(this).join(m) }, lastIndexOf(...m) { return wd(this, "lastIndexOf", m) }, map(m, x) { return cs(this, "map", m, x, void 0, arguments) }, pop() { return ac(this, "pop") }, push(...m) { return ac(this, "push", m) }, reduce(m, ...x) { return Uf(this, "reduce", m, x) }, reduceRight(m, ...x) { return Uf(this, "reduceRight", m, x) }, shift() { return ac(this, "shift") }, some(m, x) { return cs(this, "some", m, x, void 0, arguments) }, splice(...m) { return ac(this, "splice", m) }, toReversed() { return ka(this).toReversed() }, toSorted(m) { return ka(this).toSorted(m) }, toSpliced(...m) { return ka(this).toSpliced(...m) }, unshift(...m) { return ac(this, "unshift", m) }, values() { return bd(this, "values", on) } }; function bd(m, x, S) { const z = Xd(m), F = z[x](); return z !== m && !Vn(m) && (F._next = F.next, F.next = () => { const Z = F._next(); return Z.value && (Z.value = S(Z.value)), Z }), F } const by = Array.prototype; function cs(m, x, S, z, F, Z) { const P = Xd(m), c = P !== m && !Vn(m), de = P[x]; if (de !== by[x]) { const Fe = de.apply(m, Z); return c ? on(Fe) : Fe } let ze = S; P !== m && (c ? ze = function (Fe, Le) { return S.call(this, on(Fe), Le, m) } : S.length > 2 && (ze = function (Fe, Le) { return S.call(this, Fe, Le, m) })); const xe = de.call(P, ze, z); return c && F ? F(xe) : xe } function Uf(m, x, S, z) { const F = Xd(m); let Z = S; return F !== m && (Vn(m) ? S.length > 3 && (Z = function (P, c, de) { return S.call(this, P, c, de, m) }) : Z = function (P, c, de) { return S.call(this, P, on(c), de, m) }), F[x](Z, ...z) } function wd(m, x, S) { const z = ii(m); gr(z, "iterate", xc); const F = z[x](...S); return (F === -1 || F === !1) && Qd(S[0]) ? (S[0] = ii(S[0]), z[x](...S)) : F } function ac(m, x, S = []) { $s(), qd(); const z = ii(m)[x].apply(m, S); return Hd(), Gs(), z } const wy = Vd("__proto__,__v_isRef,__isVue"), Em = new Set(Object.getOwnPropertyNames(Symbol).filter(m => m !== "arguments" && m !== "caller").map(m => Symbol[m]).filter(Va)); function Ty(m) { Va(m) || (m = String(m)); const x = ii(this); return gr(x, "has", m), x.hasOwnProperty(m) } class Am { constructor(x = !1, S = !1) { this._isReadonly = x, this._isShallow = S } get(x, S, z) { if (S === "__v_skip") return x.__v_skip; const F = this._isReadonly, Z = this._isShallow; if (S === "__v_isReactive") return !F; if (S === "__v_isReadonly") return F; if (S === "__v_isShallow") return Z; if (S === "__v_raw") return z === (F ? Z ? Dy : Rm : Z ? Dm : km).get(x) || Object.getPrototypeOf(x) === Object.getPrototypeOf(z) ? x : void 0; const P = It(x); if (!F) { let de; if (P && (de = vy[S])) return de; if (S === "hasOwnProperty") return Ty } const c = Reflect.get(x, S, Ar(x) ? x : z); return (Va(S) ? Em.has(S) : wy(S)) || (F || gr(x, "get", S), Z) ? c : Ar(c) ? P && Ud(S) ? c : c.value : Ni(c) ? F ? Lm(c) : Jd(c) : c } } class zm extends Am { constructor(x = !1) { super(!1, x) } set(x, S, z, F) { let Z = x[S]; if (!this._isShallow) { const de = Oa(Z); if (!Vn(z) && !Oa(z) && (Z = ii(Z), z = ii(z)), !It(x) && Ar(Z) && !Ar(z)) return de ? !1 : (Z.value = z, !0) } const P = It(x) && Ud(S) ? Number(S) < x.length : Kt(x, S), c = Reflect.set(x, S, z, Ar(x) ? x : F); return x === ii(F) && (P ? To(z, Z) && ds(x, "set", S, z) : ds(x, "add", S, z)), c } deleteProperty(x, S) { const z = Kt(x, S); x[S]; const F = Reflect.deleteProperty(x, S); return F && z && ds(x, "delete", S, void 0), F } has(x, S) { const z = Reflect.has(x, S); return (!Va(S) || !Em.has(S)) && gr(x, "has", S), z } ownKeys(x) { return gr(x, "iterate", It(x) ? "length" : Po), Reflect.ownKeys(x) } } class Py extends Am { constructor(x = !1) { super(!0, x) } set(x, S) { return !0 } deleteProperty(x, S) { return !0 } } const Sy = new zm, My = new Py, Iy = new zm(!0); const kd = m => m, Ou = m => Reflect.getPrototypeOf(m); function Cy(m, x, S) { return function (...z) { const F = this.__v_raw, Z = ii(F), P = uc(Z), c = m === "entries" || m === Symbol.iterator && P, de = m === "keys" && P, ze = F[m](...z), xe = S ? kd : x ? Dd : on; return !x && gr(Z, "iterate", de ? zd : Po), { next() { const { value: Fe, done: Le } = ze.next(); return Le ? { value: Fe, done: Le } : { value: c ? [xe(Fe[0]), xe(Fe[1])] : xe(Fe), done: Le } }, [Symbol.iterator]() { return this } } } } function ju(m) { return function (...x) { return m === "delete" ? !1 : m === "clear" ? void 0 : this } } function Ey(m, x) { const S = { get(F) { const Z = this.__v_raw, P = ii(Z), c = ii(F); m || (To(F, c) && gr(P, "get", F), gr(P, "get", c)); const { has: de } = Ou(P), ze = x ? kd : m ? Dd : on; if (de.call(P, F)) return ze(Z.get(F)); if (de.call(P, c)) return ze(Z.get(c)); Z !== P && Z.get(F) }, get size() { const F = this.__v_raw; return !m && gr(ii(F), "iterate", Po), Reflect.get(F, "size", F) }, has(F) { const Z = this.__v_raw, P = ii(Z), c = ii(F); return m || (To(F, c) && gr(P, "has", F), gr(P, "has", c)), F === c ? Z.has(F) : Z.has(F) || Z.has(c) }, forEach(F, Z) { const P = this, c = P.__v_raw, de = ii(c), ze = x ? kd : m ? Dd : on; return !m && gr(de, "iterate", Po), c.forEach((xe, Fe) => F.call(Z, ze(xe), ze(Fe), P)) } }; return yr(S, m ? { add: ju("add"), set: ju("set"), delete: ju("delete"), clear: ju("clear") } : { add(F) { !x && !Vn(F) && !Oa(F) && (F = ii(F)); const Z = ii(this); return Ou(Z).has.call(Z, F) || (Z.add(F), ds(Z, "add", F, F)), this }, set(F, Z) { !x && !Vn(Z) && !Oa(Z) && (Z = ii(Z)); const P = ii(this), { has: c, get: de } = Ou(P); let ze = c.call(P, F); ze || (F = ii(F), ze = c.call(P, F)); const xe = de.call(P, F); return P.set(F, Z), ze ? To(Z, xe) && ds(P, "set", F, Z) : ds(P, "add", F, Z), this }, delete(F) { const Z = ii(this), { has: P, get: c } = Ou(Z); let de = P.call(Z, F); de || (F = ii(F), de = P.call(Z, F)), c && c.call(Z, F); const ze = Z.delete(F); return de && ds(Z, "delete", F, void 0), ze }, clear() { const F = ii(this), Z = F.size !== 0, P = F.clear(); return Z && ds(F, "clear", void 0, void 0), P } }), ["keys", "values", "entries", Symbol.iterator].forEach(F => { S[F] = Cy(F, m, x) }), S } function Kd(m, x) { const S = Ey(m, x); return (z, F, Z) => F === "__v_isReactive" ? !m : F === "__v_isReadonly" ? m : F === "__v_raw" ? z : Reflect.get(Kt(S, F) && F in z ? S : z, F, Z) } const Ay = { get: Kd(!1, !1) }, zy = { get: Kd(!1, !0) }, ky = { get: Kd(!0, !1) }; const km = new WeakMap, Dm = new WeakMap, Rm = new WeakMap, Dy = new WeakMap; function Ry(m) { switch (m) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function Ly(m) { return m.__v_skip || !Object.isExtensible(m) ? 0 : Ry(sy(m)) } function Jd(m) { return Oa(m) ? m : Yd(m, !1, Sy, Ay, km) } function Fy(m) { return Yd(m, !1, Iy, zy, Dm) } function Lm(m) { return Yd(m, !0, My, ky, Rm) } function Yd(m, x, S, z, F) { if (!Ni(m) || m.__v_raw && !(x && m.__v_isReactive)) return m; const Z = F.get(m); if (Z) return Z; const P = Ly(m); if (P === 0) return m; const c = new Proxy(m, P === 2 ? z : S); return F.set(m, c), c } function fc(m) { return Oa(m) ? fc(m.__v_raw) : !!(m && m.__v_isReactive) } function Oa(m) { return !!(m && m.__v_isReadonly) } function Vn(m) { return !!(m && m.__v_isShallow) } function Qd(m) { return m ? !!m.__v_raw : !1 } function ii(m) { const x = m && m.__v_raw; return x ? ii(x) : m } function By(m) { return !Kt(m, "__v_skip") && Object.isExtensible(m) && ym(m, "__v_skip", !0), m } const on = m => Ni(m) ? Jd(m) : m, Dd = m => Ni(m) ? Lm(m) : m; function Ar(m) { return m ? m.__v_isRef === !0 : !1 } function Oy(m) { return Ar(m) ? m.value : m } const jy = { get: (m, x, S) => x === "__v_raw" ? m : Oy(Reflect.get(m, x, S)), set: (m, x, S, z) => { const F = m[x]; return Ar(F) && !Ar(S) ? (F.value = S, !0) : Reflect.set(m, x, S, z) } }; function Fm(m) { return fc(m) ? m : new Proxy(m, jy) } class Vy { constructor(x, S, z) { this.fn = x, this.setter = S, this._value = void 0, this.dep = new Im(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = yc - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !S, this.isSSR = z } notify() { if (this.flags |= 16, !(this.flags & 8) && li !== this) return wm(this, !0), !0 } get value() { const x = this.dep.track(); return Sm(this), x && (x.version = this.dep.version), this._value } set value(x) { this.setter && this.setter(x) } } function Ny(m, x, S = !1) { let z, F; return Mt(m) ? z = m : (z = m.get, F = m.set), new Vy(z, F, S) } const Vu = {}, Gu = new WeakMap; let bo; function Zy(m, x = !1, S = bo) { if (S) { let z = Gu.get(S); z || Gu.set(S, z = []), z.push(m) } } function Uy(m, x, S = ci) { const { immediate: z, deep: F, once: Z, scheduler: P, augmentJob: c, call: de } = S, ze = ot => F ? ot : Vn(ot) || F === !1 || F === 0 ? Ns(ot, 1) : Ns(ot); let xe, Fe, Le, ae, Ge = !1, Tt = !1; if (Ar(m) ? (Fe = () => m.value, Ge = Vn(m)) : fc(m) ? (Fe = () => ze(m), Ge = !0) : It(m) ? (Tt = !0, Ge = m.some(ot => fc(ot) || Vn(ot)), Fe = () => m.map(ot => { if (Ar(ot)) return ot.value; if (fc(ot)) return ze(ot); if (Mt(ot)) return de ? de(ot, 2) : ot() })) : Mt(m) ? x ? Fe = de ? () => de(m, 2) : m : Fe = () => { if (Le) { $s(); try { Le() } finally { Gs() } } const ot = bo; bo = xe; try { return de ? de(m, 3, [ae]) : m(ae) } finally { bo = ot } } : Fe = jn, x && F) { const ot = Fe, Ht = F === !0 ? 1 / 0 : F; Fe = () => Ns(ot(), Ht) } const ri = gy(), kt = () => { xe.stop(), ri && ri.active && Zd(ri.effects, xe) }; if (Z && x) { const ot = x; x = (...Ht) => { ot(...Ht), kt() } } let Zt = Tt ? new Array(m.length).fill(Vu) : Vu; const qt = ot => { if (!(!(xe.flags & 1) || !xe.dirty && !ot)) if (x) { const Ht = xe.run(); if (F || Ge || (Tt ? Ht.some((Vt, Et) => To(Vt, Zt[Et])) : To(Ht, Zt))) { Le && Le(); const Vt = bo; bo = xe; try { const Et = [Ht, Zt === Vu ? void 0 : Tt && Zt[0] === Vu ? [] : Zt, ae]; de ? de(x, 3, Et) : x(...Et), Zt = Ht } finally { bo = Vt } } } else xe.run() }; return c && c(qt), xe = new vm(Fe), xe.scheduler = P ? () => P(qt, !1) : qt, ae = ot => Zy(ot, !1, xe), Le = xe.onStop = () => { const ot = Gu.get(xe); if (ot) { if (de) de(ot, 4); else for (const Ht of ot) Ht(); Gu.delete(xe) } }, x ? z ? qt(!0) : Zt = xe.run() : P ? P(qt.bind(null, !0), !0) : xe.run(), kt.pause = xe.pause.bind(xe), kt.resume = xe.resume.bind(xe), kt.stop = kt, kt } function Ns(m, x = 1 / 0, S) { if (x <= 0 || !Ni(m) || m.__v_skip || (S = S || new Set, S.has(m))) return m; if (S.add(m), x--, Ar(m)) Ns(m.value, x, S); else if (It(m)) for (let z = 0; z < m.length; z++)Ns(m[z], x, S); else if (ry(m) || uc(m)) m.forEach(z => { Ns(z, x, S) }); else if (oy(m)) { for (const z in m) Ns(m[z], x, S); for (const z of Object.getOwnPropertySymbols(m)) Object.prototype.propertyIsEnumerable.call(m, z) && Ns(m[z], x, S) } return m }/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Pc(m, x, S, z) { try { return z ? m(...z) : m() } catch (F) { th(F, x, S) } } function Nn(m, x, S, z) { if (Mt(m)) { const F = Pc(m, x, S, z); return F && _m(F) && F.catch(Z => { th(Z, x, S) }), F } if (It(m)) { const F = []; for (let Z = 0; Z < m.length; Z++)F.push(Nn(m[Z], x, S, z)); return F } } function th(m, x, S, z = !0) { const F = x ? x.vnode : null, { errorHandler: Z, throwUnhandledErrorInProduction: P } = x && x.appContext.config || ci; if (x) { let c = x.parent; const de = x.proxy, ze = `https://vuejs.org/error-reference/#runtime-${S}`; for (; c;) { const xe = c.ec; if (xe) { for (let Fe = 0; Fe < xe.length; Fe++)if (xe[Fe](m, de, ze) === !1) return } c = c.parent } if (Z) { $s(), Pc(Z, null, 10, [m, de, ze]), Gs(); return } } $y(m, S, F, z, P) } function $y(m, x, S, z = !0, F = !1) { if (F) throw m; console.error(m) } const Cr = []; let Fn = -1; const Fa = []; let js = null, Ra = 0; const Bm = Promise.resolve(); let qu = null; function Gy(m) { const x = qu || Bm; return m ? x.then(this ? m.bind(this) : m) : x } function qy(m) { let x = Fn + 1, S = Cr.length; for (; x < S;) { const z = x + S >>> 1, F = Cr[z], Z = vc(F); Z < m || Z === m && F.flags & 2 ? x = z + 1 : S = z } return x } function ep(m) { if (!(m.flags & 1)) { const x = vc(m), S = Cr[Cr.length - 1]; !S || !(m.flags & 2) && x >= vc(S) ? Cr.push(m) : Cr.splice(qy(x), 0, m), m.flags |= 1, Om() } } function Om() { qu || (qu = Bm.then(Vm)) } function Hy(m) { It(m) ? Fa.push(...m) : js && m.id === -1 ? js.splice(Ra + 1, 0, m) : m.flags & 1 || (Fa.push(m), m.flags |= 1), Om() } function $f(m, x, S = Fn + 1) { for (; S < Cr.length; S++) { const z = Cr[S]; if (z && z.flags & 2) { if (m && z.id !== m.uid) continue; Cr.splice(S, 1), S--, z.flags & 4 && (z.flags &= -2), z(), z.flags & 4 || (z.flags &= -2) } } } function jm(m) { if (Fa.length) { const x = [...new Set(Fa)].sort((S, z) => vc(S) - vc(z)); if (Fa.length = 0, js) { js.push(...x); return } for (js = x, Ra = 0; Ra < js.length; Ra++) { const S = js[Ra]; S.flags & 4 && (S.flags &= -2), S.flags & 8 || S(), S.flags &= -2 } js = null, Ra = 0 } } const vc = m => m.id == null ? m.flags & 2 ? -1 : 1 / 0 : m.id; function Vm(m) { try { for (Fn = 0; Fn < Cr.length; Fn++) { const x = Cr[Fn]; x && !(x.flags & 8) && (x.flags & 4 && (x.flags &= -2), Pc(x, x.i, x.i ? 15 : 14), x.flags & 4 || (x.flags &= -2)) } } finally { for (; Fn < Cr.length; Fn++) { const x = Cr[Fn]; x && (x.flags &= -2) } Fn = -1, Cr.length = 0, jm(), qu = null, (Cr.length || Fa.length) && Vm() } } let On = null, Nm = null; function Hu(m) { const x = On; return On = m, Nm = m && m.type.__scopeId || null, x } function Wy(m, x = On, S) { if (!x || m._n) return m; const z = (...F) => { z._d && Qf(-1); const Z = Hu(x); let P; try { P = m(...F) } finally { Hu(Z), z._d && Qf(1) } return P }; return z._n = !0, z._c = !0, z._d = !0, z } function xo(m, x, S, z) { const F = m.dirs, Z = x && x.dirs; for (let P = 0; P < F.length; P++) { const c = F[P]; Z && (c.oldValue = Z[P].value); let de = c.dir[z]; de && ($s(), Nn(de, S, 8, [m.el, c, m, x]), Gs()) } } const Xy = Symbol("_vte"), Ky = m => m.__isTeleport; function tp(m, x) { m.shapeFlag & 6 && m.component ? (m.transition = x, tp(m.component.subTree, x)) : m.shapeFlag & 128 ? (m.ssContent.transition = x.clone(m.ssContent), m.ssFallback.transition = x.clone(m.ssFallback)) : m.transition = x }/*! #__NO_SIDE_EFFECTS__ */function Jy(m, x) { return Mt(m) ? yr({ name: m.name }, x, { setup: m }) : m } function Zm(m) { m.ids = [m.ids[0] + m.ids[2]++ + "-", 0, 0] } function Wu(m, x, S, z, F = !1) { if (It(m)) { m.forEach((Ge, Tt) => Wu(Ge, x && (It(x) ? x[Tt] : x), S, z, F)); return } if (mc(z) && !F) { z.shapeFlag & 512 && z.type.__asyncResolved && z.component.subTree.component && Wu(m, x, S, z.component.subTree); return } const Z = z.shapeFlag & 4 ? np(z.component) : z.el, P = F ? null : Z, { i: c, r: de } = m, ze = x && x.r, xe = c.refs === ci ? c.refs = {} : c.refs, Fe = c.setupState, Le = ii(Fe), ae = Fe === ci ? () => !1 : Ge => Kt(Le, Ge); if (ze != null && ze !== de && (ir(ze) ? (xe[ze] = null, ae(ze) && (Fe[ze] = null)) : Ar(ze) && (ze.value = null)), Mt(de)) Pc(de, c, 12, [P, xe]); else { const Ge = ir(de), Tt = Ar(de); if (Ge || Tt) { const ri = () => { if (m.f) { const kt = Ge ? ae(de) ? Fe[de] : xe[de] : de.value; F ? It(kt) && Zd(kt, Z) : It(kt) ? kt.includes(Z) || kt.push(Z) : Ge ? (xe[de] = [Z], ae(de) && (Fe[de] = xe[de])) : (de.value = [Z], m.k && (xe[m.k] = de.value)) } else Ge ? (xe[de] = P, ae(de) && (Fe[de] = P)) : Tt && (de.value = P, m.k && (xe[m.k] = P)) }; P ? (ri.id = -1, nn(ri, S)) : ri() } } } eh().requestIdleCallback; eh().cancelIdleCallback; const mc = m => !!m.type.__asyncLoader, Um = m => m.type.__isKeepAlive; function Yy(m, x) { $m(m, "a", x) } function Qy(m, x) { $m(m, "da", x) } function $m(m, x, S = Er) { const z = m.__wdc || (m.__wdc = () => { let F = S; for (; F;) { if (F.isDeactivated) return; F = F.parent } return m() }); if (ih(x, z, S), S) { let F = S.parent; for (; F && F.parent;)Um(F.parent.vnode) && ex(z, x, S, F), F = F.parent } } function ex(m, x, S, z) { const F = ih(x, m, z, !0); Gm(() => { Zd(z[x], F) }, S) } function ih(m, x, S = Er, z = !1) { if (S) { const F = S[m] || (S[m] = []), Z = x.__weh || (x.__weh = (...P) => { $s(); const c = Sc(S), de = Nn(x, S, m, P); return c(), Gs(), de }); return z ? F.unshift(Z) : F.push(Z), Z } } const ps = m => (x, S = Er) => { (!Tc || m === "sp") && ih(m, (...z) => x(...z), S) }, tx = ps("bm"), ix = ps("m"), rx = ps("bu"), nx = ps("u"), sx = ps("bum"), Gm = ps("um"), ox = ps("sp"), ax = ps("rtg"), lx = ps("rtc"); function cx(m, x = Er) { ih("ec", m, x) } const ux = Symbol.for("v-ndc"), Rd = m => m ? f_(m) ? np(m) : Rd(m.parent) : null, _c = yr(Object.create(null), { $: m => m, $el: m => m.vnode.el, $data: m => m.data, $props: m => m.props, $attrs: m => m.attrs, $slots: m => m.slots, $refs: m => m.refs, $parent: m => Rd(m.parent), $root: m => Rd(m.root), $host: m => m.ce, $emit: m => m.emit, $options: m => Hm(m), $forceUpdate: m => m.f || (m.f = () => { ep(m.update) }), $nextTick: m => m.n || (m.n = Gy.bind(m.proxy)), $watch: m => kx.bind(m) }), Td = (m, x) => m !== ci && !m.__isScriptSetup && Kt(m, x), hx = { get({ _: m }, x) { if (x === "__v_skip") return !0; const { ctx: S, setupState: z, data: F, props: Z, accessCache: P, type: c, appContext: de } = m; let ze; if (x[0] !== "$") { const ae = P[x]; if (ae !== void 0) switch (ae) { case 1: return z[x]; case 2: return F[x]; case 4: return S[x]; case 3: return Z[x] } else { if (Td(z, x)) return P[x] = 1, z[x]; if (F !== ci && Kt(F, x)) return P[x] = 2, F[x]; if ((ze = m.propsOptions[0]) && Kt(ze, x)) return P[x] = 3, Z[x]; if (S !== ci && Kt(S, x)) return P[x] = 4, S[x]; Ld && (P[x] = 0) } } const xe = _c[x]; let Fe, Le; if (xe) return x === "$attrs" && gr(m.attrs, "get", ""), xe(m); if ((Fe = c.__cssModules) && (Fe = Fe[x])) return Fe; if (S !== ci && Kt(S, x)) return P[x] = 4, S[x]; if (Le = de.config.globalProperties, Kt(Le, x)) return Le[x] }, set({ _: m }, x, S) { const { data: z, setupState: F, ctx: Z } = m; return Td(F, x) ? (F[x] = S, !0) : z !== ci && Kt(z, x) ? (z[x] = S, !0) : Kt(m.props, x) || x[0] === "$" && x.slice(1) in m ? !1 : (Z[x] = S, !0) }, has({ _: { data: m, setupState: x, accessCache: S, ctx: z, appContext: F, propsOptions: Z } }, P) { let c; return !!S[P] || m !== ci && Kt(m, P) || Td(x, P) || (c = Z[0]) && Kt(c, P) || Kt(z, P) || Kt(_c, P) || Kt(F.config.globalProperties, P) }, defineProperty(m, x, S) { return S.get != null ? m._.accessCache[x] = 0 : Kt(S, "value") && this.set(m, x, S.value, null), Reflect.defineProperty(m, x, S) } }; function Gf(m) { return It(m) ? m.reduce((x, S) => (x[S] = null, x), {}) : m } let Ld = !0; function dx(m) { const x = Hm(m), S = m.proxy, z = m.ctx; Ld = !1, x.beforeCreate && qf(x.beforeCreate, m, "bc"); const { data: F, computed: Z, methods: P, watch: c, provide: de, inject: ze, created: xe, beforeMount: Fe, mounted: Le, beforeUpdate: ae, updated: Ge, activated: Tt, deactivated: ri, beforeDestroy: kt, beforeUnmount: Zt, destroyed: qt, unmounted: ot, render: Ht, renderTracked: Vt, renderTriggered: Et, errorCaptured: Nt, serverPrefetch: ln, expose: zr, inheritAttrs: or, components: ar, directives: Zi, filters: bi } = x; if (ze && px(ze, z, null), P) for (const Ut in P) { const Dt = P[Ut]; Mt(Dt) && (z[Ut] = Dt.bind(S)) } if (F) { const Ut = F.call(S, S); Ni(Ut) && (m.data = Jd(Ut)) } if (Ld = !0, Z) for (const Ut in Z) { const Dt = Z[Ut], rr = Mt(Dt) ? Dt.bind(S, S) : Mt(Dt.get) ? Dt.get.bind(S, S) : jn, kr = !Mt(Dt) && Mt(Dt.set) ? Dt.set.bind(S) : jn, lr = ev({ get: rr, set: kr }); Object.defineProperty(z, Ut, { enumerable: !0, configurable: !0, get: () => lr.value, set: gi => lr.value = gi }) } if (c) for (const Ut in c) qm(c[Ut], z, S, Ut); if (de) { const Ut = Mt(de) ? de.call(S) : de; Reflect.ownKeys(Ut).forEach(Dt => { xx(Dt, Ut[Dt]) }) } xe && qf(xe, m, "c"); function gt(Ut, Dt) { It(Dt) ? Dt.forEach(rr => Ut(rr.bind(S))) : Dt && Ut(Dt.bind(S)) } if (gt(tx, Fe), gt(ix, Le), gt(rx, ae), gt(nx, Ge), gt(Yy, Tt), gt(Qy, ri), gt(cx, Nt), gt(lx, Vt), gt(ax, Et), gt(sx, Zt), gt(Gm, ot), gt(ox, ln), It(zr)) if (zr.length) { const Ut = m.exposed || (m.exposed = {}); zr.forEach(Dt => { Object.defineProperty(Ut, Dt, { get: () => S[Dt], set: rr => S[Dt] = rr }) }) } else m.exposed || (m.exposed = {}); Ht && m.render === jn && (m.render = Ht), or != null && (m.inheritAttrs = or), ar && (m.components = ar), Zi && (m.directives = Zi), ln && Zm(m) } function px(m, x, S = jn) { It(m) && (m = Fd(m)); for (const z in m) { const F = m[z]; let Z; Ni(F) ? "default" in F ? Z = Nu(F.from || z, F.default, !0) : Z = Nu(F.from || z) : Z = Nu(F), Ar(Z) ? Object.defineProperty(x, z, { enumerable: !0, configurable: !0, get: () => Z.value, set: P => Z.value = P }) : x[z] = Z } } function qf(m, x, S) { Nn(It(m) ? m.map(z => z.bind(x.proxy)) : m.bind(x.proxy), x, S) } function qm(m, x, S, z) { let F = z.includes(".") ? a_(S, z) : () => S[z]; if (ir(m)) { const Z = x[m]; Mt(Z) && Sd(F, Z) } else if (Mt(m)) Sd(F, m.bind(S)); else if (Ni(m)) if (It(m)) m.forEach(Z => qm(Z, x, S, z)); else { const Z = Mt(m.handler) ? m.handler.bind(S) : x[m.handler]; Mt(Z) && Sd(F, Z, m) } } function Hm(m) { const x = m.type, { mixins: S, extends: z } = x, { mixins: F, optionsCache: Z, config: { optionMergeStrategies: P } } = m.appContext, c = Z.get(x); let de; return c ? de = c : !F.length && !S && !z ? de = x : (de = {}, F.length && F.forEach(ze => Xu(de, ze, P, !0)), Xu(de, x, P)), Ni(x) && Z.set(x, de), de } function Xu(m, x, S, z = !1) { const { mixins: F, extends: Z } = x; Z && Xu(m, Z, S, !0), F && F.forEach(P => Xu(m, P, S, !0)); for (const P in x) if (!(z && P === "expose")) { const c = fx[P] || S && S[P]; m[P] = c ? c(m[P], x[P]) : x[P] } return m } const fx = { data: Hf, props: Wf, emits: Wf, methods: cc, computed: cc, beforeCreate: Ir, created: Ir, beforeMount: Ir, mounted: Ir, beforeUpdate: Ir, updated: Ir, beforeDestroy: Ir, beforeUnmount: Ir, destroyed: Ir, unmounted: Ir, activated: Ir, deactivated: Ir, errorCaptured: Ir, serverPrefetch: Ir, components: cc, directives: cc, watch: _x, provide: Hf, inject: mx }; function Hf(m, x) { return x ? m ? function () { return yr(Mt(m) ? m.call(this, this) : m, Mt(x) ? x.call(this, this) : x) } : x : m } function mx(m, x) { return cc(Fd(m), Fd(x)) } function Fd(m) { if (It(m)) { const x = {}; for (let S = 0; S < m.length; S++)x[m[S]] = m[S]; return x } return m } function Ir(m, x) { return m ? [...new Set([].concat(m, x))] : x } function cc(m, x) { return m ? yr(Object.create(null), m, x) : x } function Wf(m, x) { return m ? It(m) && It(x) ? [...new Set([...m, ...x])] : yr(Object.create(null), Gf(m), Gf(x ?? {})) : x } function _x(m, x) { if (!m) return x; if (!x) return m; const S = yr(Object.create(null), m); for (const z in x) S[z] = Ir(m[z], x[z]); return S } function Wm() { return { app: null, config: { isNativeTag: ty, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let gx = 0; function yx(m, x) { return function (z, F = null) { Mt(z) || (z = yr({}, z)), F != null && !Ni(F) && (F = null); const Z = Wm(), P = new WeakSet, c = []; let de = !1; const ze = Z.app = { _uid: gx++, _component: z, _props: F, _container: null, _context: Z, _instance: null, version: tv, get config() { return Z.config }, set config(xe) { }, use(xe, ...Fe) { return P.has(xe) || (xe && Mt(xe.install) ? (P.add(xe), xe.install(ze, ...Fe)) : Mt(xe) && (P.add(xe), xe(ze, ...Fe))), ze }, mixin(xe) { return Z.mixins.includes(xe) || Z.mixins.push(xe), ze }, component(xe, Fe) { return Fe ? (Z.components[xe] = Fe, ze) : Z.components[xe] }, directive(xe, Fe) { return Fe ? (Z.directives[xe] = Fe, ze) : Z.directives[xe] }, mount(xe, Fe, Le) { if (!de) { const ae = ze._ceVNode || Zs(z, F); return ae.appContext = Z, Le === !0 ? Le = "svg" : Le === !1 && (Le = void 0), m(ae, xe, Le), de = !0, ze._container = xe, xe.__vue_app__ = ze, np(ae.component) } }, onUnmount(xe) { c.push(xe) }, unmount() { de && (Nn(c, ze._instance, 16), m(null, ze._container), delete ze._container.__vue_app__) }, provide(xe, Fe) { return Z.provides[xe] = Fe, ze }, runWithContext(xe) { const Fe = Ba; Ba = ze; try { return xe() } finally { Ba = Fe } } }; return ze } } let Ba = null; function xx(m, x) { if (Er) { let S = Er.provides; const z = Er.parent && Er.parent.provides; z === S && (S = Er.provides = Object.create(z)), S[m] = x } } function Nu(m, x, S = !1) { const z = Er || On; if (z || Ba) { const F = Ba ? Ba._context.provides : z ? z.parent == null ? z.vnode.appContext && z.vnode.appContext.provides : z.parent.provides : void 0; if (F && m in F) return F[m]; if (arguments.length > 1) return S && Mt(x) ? x.call(z && z.proxy) : x } } const Xm = {}, Km = () => Object.create(Xm), Jm = m => Object.getPrototypeOf(m) === Xm; function vx(m, x, S, z = !1) { const F = {}, Z = Km(); m.propsDefaults = Object.create(null), Ym(m, x, F, Z); for (const P in m.propsOptions[0]) P in F || (F[P] = void 0); S ? m.props = z ? F : Fy(F) : m.type.props ? m.props = F : m.props = Z, m.attrs = Z } function bx(m, x, S, z) { const { props: F, attrs: Z, vnode: { patchFlag: P } } = m, c = ii(F), [de] = m.propsOptions; let ze = !1; if ((z || P > 0) && !(P & 16)) { if (P & 8) { const xe = m.vnode.dynamicProps; for (let Fe = 0; Fe < xe.length; Fe++) { let Le = xe[Fe]; if (rh(m.emitsOptions, Le)) continue; const ae = x[Le]; if (de) if (Kt(Z, Le)) ae !== Z[Le] && (Z[Le] = ae, ze = !0); else { const Ge = Us(Le); F[Ge] = Bd(de, c, Ge, ae, m, !1) } else ae !== Z[Le] && (Z[Le] = ae, ze = !0) } } } else { Ym(m, x, F, Z) && (ze = !0); let xe; for (const Fe in c) (!x || !Kt(x, Fe) && ((xe = So(Fe)) === Fe || !Kt(x, xe))) && (de ? S && (S[Fe] !== void 0 || S[xe] !== void 0) && (F[Fe] = Bd(de, c, Fe, void 0, m, !0)) : delete F[Fe]); if (Z !== c) for (const Fe in Z) (!x || !Kt(x, Fe)) && (delete Z[Fe], ze = !0) } ze && ds(m.attrs, "set", "") } function Ym(m, x, S, z) { const [F, Z] = m.propsOptions; let P = !1, c; if (x) for (let de in x) { if (hc(de)) continue; const ze = x[de]; let xe; F && Kt(F, xe = Us(de)) ? !Z || !Z.includes(xe) ? S[xe] = ze : (c || (c = {}))[xe] = ze : rh(m.emitsOptions, de) || (!(de in z) || ze !== z[de]) && (z[de] = ze, P = !0) } if (Z) { const de = ii(S), ze = c || ci; for (let xe = 0; xe < Z.length; xe++) { const Fe = Z[xe]; S[Fe] = Bd(F, de, Fe, ze[Fe], m, !Kt(ze, Fe)) } } return P } function Bd(m, x, S, z, F, Z) { const P = m[S]; if (P != null) { const c = Kt(P, "default"); if (c && z === void 0) { const de = P.default; if (P.type !== Function && !P.skipFactory && Mt(de)) { const { propsDefaults: ze } = F; if (S in ze) z = ze[S]; else { const xe = Sc(F); z = ze[S] = de.call(null, x), xe() } } else z = de; F.ce && F.ce._setProp(S, z) } P[0] && (Z && !c ? z = !1 : P[1] && (z === "" || z === So(S)) && (z = !0)) } return z } const wx = new WeakMap; function Qm(m, x, S = !1) { const z = S ? wx : x.propsCache, F = z.get(m); if (F) return F; const Z = m.props, P = {}, c = []; let de = !1; if (!Mt(m)) { const xe = Fe => { de = !0; const [Le, ae] = Qm(Fe, x, !0); yr(P, Le), ae && c.push(...ae) }; !S && x.mixins.length && x.mixins.forEach(xe), m.extends && xe(m.extends), m.mixins && m.mixins.forEach(xe) } if (!Z && !de) return Ni(m) && z.set(m, La), La; if (It(Z)) for (let xe = 0; xe < Z.length; xe++) { const Fe = Us(Z[xe]); Xf(Fe) && (P[Fe] = ci) } else if (Z) for (const xe in Z) { const Fe = Us(xe); if (Xf(Fe)) { const Le = Z[xe], ae = P[Fe] = It(Le) || Mt(Le) ? { type: Le } : yr({}, Le), Ge = ae.type; let Tt = !1, ri = !0; if (It(Ge)) for (let kt = 0; kt < Ge.length; ++kt) { const Zt = Ge[kt], qt = Mt(Zt) && Zt.name; if (qt === "Boolean") { Tt = !0; break } else qt === "String" && (ri = !1) } else Tt = Mt(Ge) && Ge.name === "Boolean"; ae[0] = Tt, ae[1] = ri, (Tt || Kt(ae, "default")) && c.push(Fe) } } const ze = [P, c]; return Ni(m) && z.set(m, ze), ze } function Xf(m) { return m[0] !== "$" && !hc(m) } const e_ = m => m[0] === "_" || m === "$stable", ip = m => It(m) ? m.map(Bn) : [Bn(m)], Tx = (m, x, S) => { if (x._n) return x; const z = Wy((...F) => ip(x(...F)), S); return z._c = !1, z }, t_ = (m, x, S) => { const z = m._ctx; for (const F in m) { if (e_(F)) continue; const Z = m[F]; if (Mt(Z)) x[F] = Tx(F, Z, z); else if (Z != null) { const P = ip(Z); x[F] = () => P } } }, i_ = (m, x) => { const S = ip(x); m.slots.default = () => S }, r_ = (m, x, S) => { for (const z in x) (S || z !== "_") && (m[z] = x[z]) }, Px = (m, x, S) => { const z = m.slots = Km(); if (m.vnode.shapeFlag & 32) { const F = x._; F ? (r_(z, x, S), S && ym(z, "_", F, !0)) : t_(x, z) } else x && i_(m, x) }, Sx = (m, x, S) => { const { vnode: z, slots: F } = m; let Z = !0, P = ci; if (z.shapeFlag & 32) { const c = x._; c ? S && c === 1 ? Z = !1 : r_(F, x, S) : (Z = !x.$stable, t_(x, F)), P = x } else x && (i_(m, x), P = { default: 1 }); if (Z) for (const c in F) !e_(c) && P[c] == null && delete F[c] }, nn = jx; function Mx(m) { return Ix(m) } function Ix(m, x) { const S = eh(); S.__VUE__ = !0; const { insert: z, remove: F, patchProp: Z, createElement: P, createText: c, createComment: de, setText: ze, setElementText: xe, parentNode: Fe, nextSibling: Le, setScopeId: ae = jn, insertStaticContent: Ge } = m, Tt = (te, le, we, Ze = null, Be = null, Oe = null, Xe = void 0, We = null, qe = !!le.dynamicChildren) => { if (te === le) return; te && !lc(te, le) && (Ze = Dr(te), gi(te, Be, Oe, !0), te = null), le.patchFlag === -2 && (qe = !1, le.dynamicChildren = null); const { type: Ve, ref: dt, shapeFlag: Ke } = le; switch (Ve) { case nh: ri(te, le, we, Ze); break; case bc: kt(te, le, we, Ze); break; case Md: te == null && Zt(le, we, Ze, Xe); break; case hs: ar(te, le, we, Ze, Be, Oe, Xe, We, qe); break; default: Ke & 1 ? Ht(te, le, we, Ze, Be, Oe, Xe, We, qe) : Ke & 6 ? Zi(te, le, we, Ze, Be, Oe, Xe, We, qe) : (Ke & 64 || Ke & 128) && Ve.process(te, le, we, Ze, Be, Oe, Xe, We, qe, qr) }dt != null && Be && Wu(dt, te && te.ref, Oe, le || te, !le) }, ri = (te, le, we, Ze) => { if (te == null) z(le.el = c(le.children), we, Ze); else { const Be = le.el = te.el; le.children !== te.children && ze(Be, le.children) } }, kt = (te, le, we, Ze) => { te == null ? z(le.el = de(le.children || ""), we, Ze) : le.el = te.el }, Zt = (te, le, we, Ze) => { [te.el, te.anchor] = Ge(te.children, le, we, Ze, te.el, te.anchor) }, qt = ({ el: te, anchor: le }, we, Ze) => { let Be; for (; te && te !== le;)Be = Le(te), z(te, we, Ze), te = Be; z(le, we, Ze) }, ot = ({ el: te, anchor: le }) => { let we; for (; te && te !== le;)we = Le(te), F(te), te = we; F(le) }, Ht = (te, le, we, Ze, Be, Oe, Xe, We, qe) => { le.type === "svg" ? Xe = "svg" : le.type === "math" && (Xe = "mathml"), te == null ? Vt(le, we, Ze, Be, Oe, Xe, We, qe) : ln(te, le, Be, Oe, Xe, We, qe) }, Vt = (te, le, we, Ze, Be, Oe, Xe, We) => { let qe, Ve; const { props: dt, shapeFlag: Ke, transition: ct, dirs: mt } = te; if (qe = te.el = P(te.type, Oe, dt && dt.is, dt), Ke & 8 ? xe(qe, te.children) : Ke & 16 && Nt(te.children, qe, null, Ze, Be, Pd(te, Oe), Xe, We), mt && xo(te, null, Ze, "created"), Et(qe, te, te.scopeId, Xe, Ze), dt) { for (const At in dt) At !== "value" && !hc(At) && Z(qe, At, null, dt[At], Oe, Ze); "value" in dt && Z(qe, "value", null, dt.value, Oe), (Ve = dt.onVnodeBeforeMount) && Ln(Ve, Ze, te) } mt && xo(te, null, Ze, "beforeMount"); const vt = Cx(Be, ct); vt && ct.beforeEnter(qe), z(qe, le, we), ((Ve = dt && dt.onVnodeMounted) || vt || mt) && nn(() => { Ve && Ln(Ve, Ze, te), vt && ct.enter(qe), mt && xo(te, null, Ze, "mounted") }, Be) }, Et = (te, le, we, Ze, Be) => { if (we && ae(te, we), Ze) for (let Oe = 0; Oe < Ze.length; Oe++)ae(te, Ze[Oe]); if (Be) { let Oe = Be.subTree; if (le === Oe || c_(Oe.type) && (Oe.ssContent === le || Oe.ssFallback === le)) { const Xe = Be.vnode; Et(te, Xe, Xe.scopeId, Xe.slotScopeIds, Be.parent) } } }, Nt = (te, le, we, Ze, Be, Oe, Xe, We, qe = 0) => { for (let Ve = qe; Ve < te.length; Ve++) { const dt = te[Ve] = We ? Vs(te[Ve]) : Bn(te[Ve]); Tt(null, dt, le, we, Ze, Be, Oe, Xe, We) } }, ln = (te, le, we, Ze, Be, Oe, Xe) => { const We = le.el = te.el; let { patchFlag: qe, dynamicChildren: Ve, dirs: dt } = le; qe |= te.patchFlag & 16; const Ke = te.props || ci, ct = le.props || ci; let mt; if (we && vo(we, !1), (mt = ct.onVnodeBeforeUpdate) && Ln(mt, we, le, te), dt && xo(le, te, we, "beforeUpdate"), we && vo(we, !0), (Ke.innerHTML && ct.innerHTML == null || Ke.textContent && ct.textContent == null) && xe(We, ""), Ve ? zr(te.dynamicChildren, Ve, We, we, Ze, Pd(le, Be), Oe) : Xe || Dt(te, le, We, null, we, Ze, Pd(le, Be), Oe, !1), qe > 0) { if (qe & 16) or(We, Ke, ct, we, Be); else if (qe & 2 && Ke.class !== ct.class && Z(We, "class", null, ct.class, Be), qe & 4 && Z(We, "style", Ke.style, ct.style, Be), qe & 8) { const vt = le.dynamicProps; for (let At = 0; At < vt.length; At++) { const Pt = vt[At], mi = Ke[Pt], ui = ct[Pt]; (ui !== mi || Pt === "value") && Z(We, Pt, mi, ui, Be, we) } } qe & 1 && te.children !== le.children && xe(We, le.children) } else !Xe && Ve == null && or(We, Ke, ct, we, Be); ((mt = ct.onVnodeUpdated) || dt) && nn(() => { mt && Ln(mt, we, le, te), dt && xo(le, te, we, "updated") }, Ze) }, zr = (te, le, we, Ze, Be, Oe, Xe) => { for (let We = 0; We < le.length; We++) { const qe = te[We], Ve = le[We], dt = qe.el && (qe.type === hs || !lc(qe, Ve) || qe.shapeFlag & 70) ? Fe(qe.el) : we; Tt(qe, Ve, dt, null, Ze, Be, Oe, Xe, !0) } }, or = (te, le, we, Ze, Be) => { if (le !== we) { if (le !== ci) for (const Oe in le) !hc(Oe) && !(Oe in we) && Z(te, Oe, le[Oe], null, Be, Ze); for (const Oe in we) { if (hc(Oe)) continue; const Xe = we[Oe], We = le[Oe]; Xe !== We && Oe !== "value" && Z(te, Oe, We, Xe, Be, Ze) } "value" in we && Z(te, "value", le.value, we.value, Be) } }, ar = (te, le, we, Ze, Be, Oe, Xe, We, qe) => { const Ve = le.el = te ? te.el : c(""), dt = le.anchor = te ? te.anchor : c(""); let { patchFlag: Ke, dynamicChildren: ct, slotScopeIds: mt } = le; mt && (We = We ? We.concat(mt) : mt), te == null ? (z(Ve, we, Ze), z(dt, we, Ze), Nt(le.children || [], we, dt, Be, Oe, Xe, We, qe)) : Ke > 0 && Ke & 64 && ct && te.dynamicChildren ? (zr(te.dynamicChildren, ct, we, Be, Oe, Xe, We), (le.key != null || Be && le === Be.subTree) && n_(te, le, !0)) : Dt(te, le, we, dt, Be, Oe, Xe, We, qe) }, Zi = (te, le, we, Ze, Be, Oe, Xe, We, qe) => { le.slotScopeIds = We, te == null ? le.shapeFlag & 512 ? Be.ctx.activate(le, we, Ze, Xe, qe) : bi(le, we, Ze, Be, Oe, Xe, qe) : Pn(te, le, qe) }, bi = (te, le, we, Ze, Be, Oe, Xe) => { const We = te.component = Wx(te, Ze, Be); if (Um(te) && (We.ctx.renderer = qr), Xx(We, !1, Xe), We.asyncDep) { if (Be && Be.registerDep(We, gt, Xe), !te.el) { const qe = We.subTree = Zs(bc); kt(null, qe, le, we) } } else gt(We, te, le, we, Be, Oe, Xe) }, Pn = (te, le, we) => { const Ze = le.component = te.component; if (Bx(te, le, we)) if (Ze.asyncDep && !Ze.asyncResolved) { Ut(Ze, le, we); return } else Ze.next = le, Ze.update(); else le.el = te.el, Ze.vnode = le }, gt = (te, le, we, Ze, Be, Oe, Xe) => { const We = () => { if (te.isMounted) { let { next: Ke, bu: ct, u: mt, parent: vt, vnode: At } = te; { const $i = s_(te); if ($i) { Ke && (Ke.el = At.el, Ut(te, Ke, Xe)), $i.asyncDep.then(() => { te.isUnmounted || We() }); return } } let Pt = Ke, mi; vo(te, !1), Ke ? (Ke.el = At.el, Ut(te, Ke, Xe)) : Ke = At, ct && xd(ct), (mi = Ke.props && Ke.props.onVnodeBeforeUpdate) && Ln(mi, vt, Ke, At), vo(te, !0); const ui = Jf(te), Ji = te.subTree; te.subTree = ui, Tt(Ji, ui, Fe(Ji.el), Dr(Ji), te, Be, Oe), Ke.el = ui.el, Pt === null && Ox(te, ui.el), mt && nn(mt, Be), (mi = Ke.props && Ke.props.onVnodeUpdated) && nn(() => Ln(mi, vt, Ke, At), Be) } else { let Ke; const { el: ct, props: mt } = le, { bm: vt, m: At, parent: Pt, root: mi, type: ui } = te, Ji = mc(le); vo(te, !1), vt && xd(vt), !Ji && (Ke = mt && mt.onVnodeBeforeMount) && Ln(Ke, Pt, le), vo(te, !0); { mi.ce && mi.ce._injectChildStyle(ui); const $i = te.subTree = Jf(te); Tt(null, $i, we, Ze, te, Be, Oe), le.el = $i.el } if (At && nn(At, Be), !Ji && (Ke = mt && mt.onVnodeMounted)) { const $i = le; nn(() => Ln(Ke, Pt, $i), Be) } (le.shapeFlag & 256 || Pt && mc(Pt.vnode) && Pt.vnode.shapeFlag & 256) && te.a && nn(te.a, Be), te.isMounted = !0, le = we = Ze = null } }; te.scope.on(); const qe = te.effect = new vm(We); te.scope.off(); const Ve = te.update = qe.run.bind(qe), dt = te.job = qe.runIfDirty.bind(qe); dt.i = te, dt.id = te.uid, qe.scheduler = () => ep(dt), vo(te, !0), Ve() }, Ut = (te, le, we) => { le.component = te; const Ze = te.vnode.props; te.vnode = le, te.next = null, bx(te, le.props, Ze, we), Sx(te, le.children, we), $s(), $f(te), Gs() }, Dt = (te, le, we, Ze, Be, Oe, Xe, We, qe = !1) => { const Ve = te && te.children, dt = te ? te.shapeFlag : 0, Ke = le.children, { patchFlag: ct, shapeFlag: mt } = le; if (ct > 0) { if (ct & 128) { kr(Ve, Ke, we, Ze, Be, Oe, Xe, We, qe); return } else if (ct & 256) { rr(Ve, Ke, we, Ze, Be, Oe, Xe, We, qe); return } } mt & 8 ? (dt & 16 && xr(Ve, Be, Oe), Ke !== Ve && xe(we, Ke)) : dt & 16 ? mt & 16 ? kr(Ve, Ke, we, Ze, Be, Oe, Xe, We, qe) : xr(Ve, Be, Oe, !0) : (dt & 8 && xe(we, ""), mt & 16 && Nt(Ke, we, Ze, Be, Oe, Xe, We, qe)) }, rr = (te, le, we, Ze, Be, Oe, Xe, We, qe) => { te = te || La, le = le || La; const Ve = te.length, dt = le.length, Ke = Math.min(Ve, dt); let ct; for (ct = 0; ct < Ke; ct++) { const mt = le[ct] = qe ? Vs(le[ct]) : Bn(le[ct]); Tt(te[ct], mt, we, null, Be, Oe, Xe, We, qe) } Ve > dt ? xr(te, Be, Oe, !0, !1, Ke) : Nt(le, we, Ze, Be, Oe, Xe, We, qe, Ke) }, kr = (te, le, we, Ze, Be, Oe, Xe, We, qe) => { let Ve = 0; const dt = le.length; let Ke = te.length - 1, ct = dt - 1; for (; Ve <= Ke && Ve <= ct;) { const mt = te[Ve], vt = le[Ve] = qe ? Vs(le[Ve]) : Bn(le[Ve]); if (lc(mt, vt)) Tt(mt, vt, we, null, Be, Oe, Xe, We, qe); else break; Ve++ } for (; Ve <= Ke && Ve <= ct;) { const mt = te[Ke], vt = le[ct] = qe ? Vs(le[ct]) : Bn(le[ct]); if (lc(mt, vt)) Tt(mt, vt, we, null, Be, Oe, Xe, We, qe); else break; Ke--, ct-- } if (Ve > Ke) { if (Ve <= ct) { const mt = ct + 1, vt = mt < dt ? le[mt].el : Ze; for (; Ve <= ct;)Tt(null, le[Ve] = qe ? Vs(le[Ve]) : Bn(le[Ve]), we, vt, Be, Oe, Xe, We, qe), Ve++ } } else if (Ve > ct) for (; Ve <= Ke;)gi(te[Ve], Be, Oe, !0), Ve++; else { const mt = Ve, vt = Ve, At = new Map; for (Ve = vt; Ve <= ct; Ve++) { const ue = le[Ve] = qe ? Vs(le[Ve]) : Bn(le[Ve]); ue.key != null && At.set(ue.key, Ve) } let Pt, mi = 0; const ui = ct - vt + 1; let Ji = !1, $i = 0; const Hr = new Array(ui); for (Ve = 0; Ve < ui; Ve++)Hr[Ve] = 0; for (Ve = mt; Ve <= Ke; Ve++) { const ue = te[Ve]; if (mi >= ui) { gi(ue, Be, Oe, !0); continue } let C; if (ue.key != null) C = At.get(ue.key); else for (Pt = vt; Pt <= ct; Pt++)if (Hr[Pt - vt] === 0 && lc(ue, le[Pt])) { C = Pt; break } C === void 0 ? gi(ue, Be, Oe, !0) : (Hr[C - vt] = Ve + 1, C >= $i ? $i = C : Ji = !0, Tt(ue, le[C], we, null, Be, Oe, Xe, We, qe), mi++) } const Rr = Ji ? Ex(Hr) : La; for (Pt = Rr.length - 1, Ve = ui - 1; Ve >= 0; Ve--) { const ue = vt + Ve, C = le[ue], V = ue + 1 < dt ? le[ue + 1].el : Ze; Hr[Ve] === 0 ? Tt(null, C, we, V, Be, Oe, Xe, We, qe) : Ji && (Pt < 0 || Ve !== Rr[Pt] ? lr(C, we, V, 2) : Pt--) } } }, lr = (te, le, we, Ze, Be = null) => { const { el: Oe, type: Xe, transition: We, children: qe, shapeFlag: Ve } = te; if (Ve & 6) { lr(te.component.subTree, le, we, Ze); return } if (Ve & 128) { te.suspense.move(le, we, Ze); return } if (Ve & 64) { Xe.move(te, le, we, qr); return } if (Xe === hs) { z(Oe, le, we); for (let Ke = 0; Ke < qe.length; Ke++)lr(qe[Ke], le, we, Ze); z(te.anchor, le, we); return } if (Xe === Md) { qt(te, le, we); return } if (Ze !== 2 && Ve & 1 && We) if (Ze === 0) We.beforeEnter(Oe), z(Oe, le, we), nn(() => We.enter(Oe), Be); else { const { leave: Ke, delayLeave: ct, afterLeave: mt } = We, vt = () => z(Oe, le, we), At = () => { Ke(Oe, () => { vt(), mt && mt() }) }; ct ? ct(Oe, vt, At) : At() } else z(Oe, le, we) }, gi = (te, le, we, Ze = !1, Be = !1) => { const { type: Oe, props: Xe, ref: We, children: qe, dynamicChildren: Ve, shapeFlag: dt, patchFlag: Ke, dirs: ct, cacheIndex: mt } = te; if (Ke === -2 && (Be = !1), We != null && Wu(We, null, we, te, !0), mt != null && (le.renderCache[mt] = void 0), dt & 256) { le.ctx.deactivate(te); return } const vt = dt & 1 && ct, At = !mc(te); let Pt; if (At && (Pt = Xe && Xe.onVnodeBeforeUnmount) && Ln(Pt, le, te), dt & 6) Si(te.component, we, Ze); else { if (dt & 128) { te.suspense.unmount(we, Ze); return } vt && xo(te, null, le, "beforeUnmount"), dt & 64 ? te.type.remove(te, le, we, qr, Ze) : Ve && !Ve.hasOnce && (Oe !== hs || Ke > 0 && Ke & 64) ? xr(Ve, le, we, !1, !0) : (Oe === hs && Ke & 384 || !Be && dt & 16) && xr(qe, le, we), Ze && cr(te) } (At && (Pt = Xe && Xe.onVnodeUnmounted) || vt) && nn(() => { Pt && Ln(Pt, le, te), vt && xo(te, null, le, "unmounted") }, we) }, cr = te => { const { type: le, el: we, anchor: Ze, transition: Be } = te; if (le === hs) { ur(we, Ze); return } if (le === Md) { ot(te); return } const Oe = () => { F(we), Be && !Be.persisted && Be.afterLeave && Be.afterLeave() }; if (te.shapeFlag & 1 && Be && !Be.persisted) { const { leave: Xe, delayLeave: We } = Be, qe = () => Xe(we, Oe); We ? We(te.el, Oe, qe) : qe() } else Oe() }, ur = (te, le) => { let we; for (; te !== le;)we = Le(te), F(te), te = we; F(le) }, Si = (te, le, we) => { const { bum: Ze, scope: Be, job: Oe, subTree: Xe, um: We, m: qe, a: Ve } = te; Kf(qe), Kf(Ve), Ze && xd(Ze), Be.stop(), Oe && (Oe.flags |= 8, gi(Xe, te, le, we)), We && nn(We, le), nn(() => { te.isUnmounted = !0 }, le), le && le.pendingBranch && !le.isUnmounted && te.asyncDep && !te.asyncResolved && te.suspenseId === le.pendingId && (le.deps--, le.deps === 0 && le.resolve()) }, xr = (te, le, we, Ze = !1, Be = !1, Oe = 0) => { for (let Xe = Oe; Xe < te.length; Xe++)gi(te[Xe], le, we, Ze, Be) }, Dr = te => { if (te.shapeFlag & 6) return Dr(te.component.subTree); if (te.shapeFlag & 128) return te.suspense.next(); const le = Le(te.anchor || te.el), we = le && le[Xy]; return we ? Le(we) : le }; let Gr = !1; const Ki = (te, le, we) => { te == null ? le._vnode && gi(le._vnode, null, null, !0) : Tt(le._vnode || null, te, le, null, null, null, we), le._vnode = te, Gr || (Gr = !0, $f(), jm(), Gr = !1) }, qr = { p: Tt, um: gi, m: lr, r: cr, mt: bi, mc: Nt, pc: Dt, pbc: zr, n: Dr, o: m }; return { render: Ki, hydrate: void 0, createApp: yx(Ki) } } function Pd({ type: m, props: x }, S) { return S === "svg" && m === "foreignObject" || S === "mathml" && m === "annotation-xml" && x && x.encoding && x.encoding.includes("html") ? void 0 : S } function vo({ effect: m, job: x }, S) { S ? (m.flags |= 32, x.flags |= 4) : (m.flags &= -33, x.flags &= -5) } function Cx(m, x) { return (!m || m && !m.pendingBranch) && x && !x.persisted } function n_(m, x, S = !1) { const z = m.children, F = x.children; if (It(z) && It(F)) for (let Z = 0; Z < z.length; Z++) { const P = z[Z]; let c = F[Z]; c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = F[Z] = Vs(F[Z]), c.el = P.el), !S && c.patchFlag !== -2 && n_(P, c)), c.type === nh && (c.el = P.el) } } function Ex(m) { const x = m.slice(), S = [0]; let z, F, Z, P, c; const de = m.length; for (z = 0; z < de; z++) { const ze = m[z]; if (ze !== 0) { if (F = S[S.length - 1], m[F] < ze) { x[z] = F, S.push(z); continue } for (Z = 0, P = S.length - 1; Z < P;)c = Z + P >> 1, m[S[c]] < ze ? Z = c + 1 : P = c; ze < m[S[Z]] && (Z > 0 && (x[z] = S[Z - 1]), S[Z] = z) } } for (Z = S.length, P = S[Z - 1]; Z-- > 0;)S[Z] = P, P = x[P]; return S } function s_(m) { const x = m.subTree.component; if (x) return x.asyncDep && !x.asyncResolved ? x : s_(x) } function Kf(m) { if (m) for (let x = 0; x < m.length; x++)m[x].flags |= 8 } const Ax = Symbol.for("v-scx"), zx = () => Nu(Ax); function Sd(m, x, S) { return o_(m, x, S) } function o_(m, x, S = ci) { const { immediate: z, deep: F, flush: Z, once: P } = S, c = yr({}, S), de = x && z || !x && Z !== "post"; let ze; if (Tc) { if (Z === "sync") { const ae = zx(); ze = ae.__watcherHandles || (ae.__watcherHandles = []) } else if (!de) { const ae = () => { }; return ae.stop = jn, ae.resume = jn, ae.pause = jn, ae } } const xe = Er; c.call = (ae, Ge, Tt) => Nn(ae, xe, Ge, Tt); let Fe = !1; Z === "post" ? c.scheduler = ae => { nn(ae, xe && xe.suspense) } : Z !== "sync" && (Fe = !0, c.scheduler = (ae, Ge) => { Ge ? ae() : ep(ae) }), c.augmentJob = ae => { x && (ae.flags |= 4), Fe && (ae.flags |= 2, xe && (ae.id = xe.uid, ae.i = xe)) }; const Le = Uy(m, x, c); return Tc && (ze ? ze.push(Le) : de && Le()), Le } function kx(m, x, S) { const z = this.proxy, F = ir(m) ? m.includes(".") ? a_(z, m) : () => z[m] : m.bind(z, z); let Z; Mt(x) ? Z = x : (Z = x.handler, S = x); const P = Sc(this), c = o_(F, Z.bind(z), S); return P(), c } function a_(m, x) { const S = x.split("."); return () => { let z = m; for (let F = 0; F < S.length && z; F++)z = z[S[F]]; return z } } const Dx = (m, x) => x === "modelValue" || x === "model-value" ? m.modelModifiers : m[`${x}Modifiers`] || m[`${Us(x)}Modifiers`] || m[`${So(x)}Modifiers`]; function Rx(m, x, ...S) { if (m.isUnmounted) return; const z = m.vnode.props || ci; let F = S; const Z = x.startsWith("update:"), P = Z && Dx(z, x.slice(7)); P && (P.trim && (F = S.map(xe => ir(xe) ? xe.trim() : xe)), P.number && (F = S.map(cy))); let c, de = z[c = yd(x)] || z[c = yd(Us(x))]; !de && Z && (de = z[c = yd(So(x))]), de && Nn(de, m, 6, F); const ze = z[c + "Once"]; if (ze) { if (!m.emitted) m.emitted = {}; else if (m.emitted[c]) return; m.emitted[c] = !0, Nn(ze, m, 6, F) } } function l_(m, x, S = !1) { const z = x.emitsCache, F = z.get(m); if (F !== void 0) return F; const Z = m.emits; let P = {}, c = !1; if (!Mt(m)) { const de = ze => { const xe = l_(ze, x, !0); xe && (c = !0, yr(P, xe)) }; !S && x.mixins.length && x.mixins.forEach(de), m.extends && de(m.extends), m.mixins && m.mixins.forEach(de) } return !Z && !c ? (Ni(m) && z.set(m, null), null) : (It(Z) ? Z.forEach(de => P[de] = null) : yr(P, Z), Ni(m) && z.set(m, P), P) } function rh(m, x) { return !m || !Ju(x) ? !1 : (x = x.slice(2).replace(/Once$/, ""), Kt(m, x[0].toLowerCase() + x.slice(1)) || Kt(m, So(x)) || Kt(m, x)) } function Jf(m) { const { type: x, vnode: S, proxy: z, withProxy: F, propsOptions: [Z], slots: P, attrs: c, emit: de, render: ze, renderCache: xe, props: Fe, data: Le, setupState: ae, ctx: Ge, inheritAttrs: Tt } = m, ri = Hu(m); let kt, Zt; try { if (S.shapeFlag & 4) { const ot = F || z, Ht = ot; kt = Bn(ze.call(Ht, ot, xe, Fe, ae, Le, Ge)), Zt = c } else { const ot = x; kt = Bn(ot.length > 1 ? ot(Fe, { attrs: c, slots: P, emit: de }) : ot(Fe, null)), Zt = x.props ? c : Lx(c) } } catch (ot) { gc.length = 0, th(ot, m, 1), kt = Zs(bc) } let qt = kt; if (Zt && Tt !== !1) { const ot = Object.keys(Zt), { shapeFlag: Ht } = qt; ot.length && Ht & 7 && (Z && ot.some(Nd) && (Zt = Fx(Zt, Z)), qt = ja(qt, Zt, !1, !0)) } return S.dirs && (qt = ja(qt, null, !1, !0), qt.dirs = qt.dirs ? qt.dirs.concat(S.dirs) : S.dirs), S.transition && tp(qt, S.transition), kt = qt, Hu(ri), kt } const Lx = m => { let x; for (const S in m) (S === "class" || S === "style" || Ju(S)) && ((x || (x = {}))[S] = m[S]); return x }, Fx = (m, x) => { const S = {}; for (const z in m) (!Nd(z) || !(z.slice(9) in x)) && (S[z] = m[z]); return S }; function Bx(m, x, S) { const { props: z, children: F, component: Z } = m, { props: P, children: c, patchFlag: de } = x, ze = Z.emitsOptions; if (x.dirs || x.transition) return !0; if (S && de >= 0) { if (de & 1024) return !0; if (de & 16) return z ? Yf(z, P, ze) : !!P; if (de & 8) { const xe = x.dynamicProps; for (let Fe = 0; Fe < xe.length; Fe++) { const Le = xe[Fe]; if (P[Le] !== z[Le] && !rh(ze, Le)) return !0 } } } else return (F || c) && (!c || !c.$stable) ? !0 : z === P ? !1 : z ? P ? Yf(z, P, ze) : !0 : !!P; return !1 } function Yf(m, x, S) { const z = Object.keys(x); if (z.length !== Object.keys(m).length) return !0; for (let F = 0; F < z.length; F++) { const Z = z[F]; if (x[Z] !== m[Z] && !rh(S, Z)) return !0 } return !1 } function Ox({ vnode: m, parent: x }, S) { for (; x;) { const z = x.subTree; if (z.suspense && z.suspense.activeBranch === m && (z.el = m.el), z === m) (m = x.vnode).el = S, x = x.parent; else break } } const c_ = m => m.__isSuspense; function jx(m, x) { x && x.pendingBranch ? It(m) ? x.effects.push(...m) : x.effects.push(m) : Hy(m) } const hs = Symbol.for("v-fgt"), nh = Symbol.for("v-txt"), bc = Symbol.for("v-cmt"), Md = Symbol.for("v-stc"), gc = []; let an = null; function u_(m = !1) { gc.push(an = m ? null : []) } function Vx() { gc.pop(), an = gc[gc.length - 1] || null } let wc = 1; function Qf(m, x = !1) { wc += m, m < 0 && an && x && (an.hasOnce = !0) } function Nx(m) { return m.dynamicChildren = wc > 0 ? an || La : null, Vx(), wc > 0 && an && an.push(m), m } function h_(m, x, S, z, F, Z) { return Nx(wo(m, x, S, z, F, Z, !0)) } function d_(m) { return m ? m.__v_isVNode === !0 : !1 } function lc(m, x) { return m.type === x.type && m.key === x.key } const p_ = ({ key: m }) => m ?? null, Zu = ({ ref: m, ref_key: x, ref_for: S }) => (typeof m == "number" && (m = "" + m), m != null ? ir(m) || Ar(m) || Mt(m) ? { i: On, r: m, k: x, f: !!S } : m : null); function wo(m, x = null, S = null, z = 0, F = null, Z = m === hs ? 0 : 1, P = !1, c = !1) { const de = { __v_isVNode: !0, __v_skip: !0, type: m, props: x, key: x && p_(x), ref: x && Zu(x), scopeId: Nm, slotScopeIds: null, children: S, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: Z, patchFlag: z, dynamicProps: F, dynamicChildren: null, appContext: null, ctx: On }; return c ? (rp(de, S), Z & 128 && m.normalize(de)) : S && (de.shapeFlag |= ir(S) ? 8 : 16), wc > 0 && !P && an && (de.patchFlag > 0 || Z & 6) && de.patchFlag !== 32 && an.push(de), de } const Zs = Zx; function Zx(m, x = null, S = null, z = 0, F = null, Z = !1) { if ((!m || m === ux) && (m = bc), d_(m)) { const c = ja(m, x, !0); return S && rp(c, S), wc > 0 && !Z && an && (c.shapeFlag & 6 ? an[an.indexOf(m)] = c : an.push(c)), c.patchFlag = -2, c } if (Qx(m) && (m = m.__vccOpts), x) { x = Ux(x); let { class: c, style: de } = x; c && !ir(c) && (x.class = Gd(c)), Ni(de) && (Qd(de) && !It(de) && (de = yr({}, de)), x.style = $d(de)) } const P = ir(m) ? 1 : c_(m) ? 128 : Ky(m) ? 64 : Ni(m) ? 4 : Mt(m) ? 2 : 0; return wo(m, x, S, z, F, P, Z, !0) } function Ux(m) { return m ? Qd(m) || Jm(m) ? yr({}, m) : m : null } function ja(m, x, S = !1, z = !1) { const { props: F, ref: Z, patchFlag: P, children: c, transition: de } = m, ze = x ? Gx(F || {}, x) : F, xe = { __v_isVNode: !0, __v_skip: !0, type: m.type, props: ze, key: ze && p_(ze), ref: x && x.ref ? S && Z ? It(Z) ? Z.concat(Zu(x)) : [Z, Zu(x)] : Zu(x) : Z, scopeId: m.scopeId, slotScopeIds: m.slotScopeIds, children: c, target: m.target, targetStart: m.targetStart, targetAnchor: m.targetAnchor, staticCount: m.staticCount, shapeFlag: m.shapeFlag, patchFlag: x && m.type !== hs ? P === -1 ? 16 : P | 16 : P, dynamicProps: m.dynamicProps, dynamicChildren: m.dynamicChildren, appContext: m.appContext, dirs: m.dirs, transition: de, component: m.component, suspense: m.suspense, ssContent: m.ssContent && ja(m.ssContent), ssFallback: m.ssFallback && ja(m.ssFallback), el: m.el, anchor: m.anchor, ctx: m.ctx, ce: m.ce }; return de && z && tp(xe, de.clone(xe)), xe } function $x(m = " ", x = 0) { return Zs(nh, null, m, x) } function Bn(m) { return m == null || typeof m == "boolean" ? Zs(bc) : It(m) ? Zs(hs, null, m.slice()) : d_(m) ? Vs(m) : Zs(nh, null, String(m)) } function Vs(m) { return m.el === null && m.patchFlag !== -1 || m.memo ? m : ja(m) } function rp(m, x) { let S = 0; const { shapeFlag: z } = m; if (x == null) x = null; else if (It(x)) S = 16; else if (typeof x == "object") if (z & 65) { const F = x.default; F && (F._c && (F._d = !1), rp(m, F()), F._c && (F._d = !0)); return } else { S = 32; const F = x._; !F && !Jm(x) ? x._ctx = On : F === 3 && On && (On.slots._ === 1 ? x._ = 1 : (x._ = 2, m.patchFlag |= 1024)) } else Mt(x) ? (x = { default: x, _ctx: On }, S = 32) : (x = String(x), z & 64 ? (S = 16, x = [$x(x)]) : S = 8); m.children = x, m.shapeFlag |= S } function Gx(...m) { const x = {}; for (let S = 0; S < m.length; S++) { const z = m[S]; for (const F in z) if (F === "class") x.class !== z.class && (x.class = Gd([x.class, z.class])); else if (F === "style") x.style = $d([x.style, z.style]); else if (Ju(F)) { const Z = x[F], P = z[F]; P && Z !== P && !(It(Z) && Z.includes(P)) && (x[F] = Z ? [].concat(Z, P) : P) } else F !== "" && (x[F] = z[F]) } return x } function Ln(m, x, S, z = null) { Nn(m, x, 7, [S, z]) } const qx = Wm(); let Hx = 0; function Wx(m, x, S) { const z = m.type, F = (x ? x.appContext : m.appContext) || qx, Z = { uid: Hx++, vnode: m, type: z, parent: x, appContext: F, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new _y(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: x ? x.provides : Object.create(F.provides), ids: x ? x.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: Qm(z, F), emitsOptions: l_(z, F), emit: null, emitted: null, propsDefaults: ci, inheritAttrs: z.inheritAttrs, ctx: ci, data: ci, props: ci, attrs: ci, slots: ci, refs: ci, setupState: ci, setupContext: null, suspense: S, suspenseId: S ? S.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return Z.ctx = { _: Z }, Z.root = x ? x.root : Z, Z.emit = Rx.bind(null, Z), m.ce && m.ce(Z), Z } let Er = null, Ku, Od; { const m = eh(), x = (S, z) => { let F; return (F = m[S]) || (F = m[S] = []), F.push(z), Z => { F.length > 1 ? F.forEach(P => P(Z)) : F[0](Z) } }; Ku = x("__VUE_INSTANCE_SETTERS__", S => Er = S), Od = x("__VUE_SSR_SETTERS__", S => Tc = S) } const Sc = m => { const x = Er; return Ku(m), m.scope.on(), () => { m.scope.off(), Ku(x) } }, em = () => { Er && Er.scope.off(), Ku(null) }; function f_(m) { return m.vnode.shapeFlag & 4 } let Tc = !1; function Xx(m, x = !1, S = !1) { x && Od(x); const { props: z, children: F } = m.vnode, Z = f_(m); vx(m, z, Z, x), Px(m, F, S); const P = Z ? Kx(m, x) : void 0; return x && Od(!1), P } function Kx(m, x) { const S = m.type; m.accessCache = Object.create(null), m.proxy = new Proxy(m.ctx, hx); const { setup: z } = S; if (z) { $s(); const F = m.setupContext = z.length > 1 ? Yx(m) : null, Z = Sc(m), P = Pc(z, m, 0, [m.props, F]), c = _m(P); if (Gs(), Z(), (c || m.sp) && !mc(m) && Zm(m), c) { if (P.then(em, em), x) return P.then(de => { tm(m, de) }).catch(de => { th(de, m, 0) }); m.asyncDep = P } else tm(m, P) } else m_(m) } function tm(m, x, S) { Mt(x) ? m.type.__ssrInlineRender ? m.ssrRender = x : m.render = x : Ni(x) && (m.setupState = Fm(x)), m_(m) } function m_(m, x, S) { const z = m.type; m.render || (m.render = z.render || jn); { const F = Sc(m); $s(); try { dx(m) } finally { Gs(), F() } } } const Jx = { get(m, x) { return gr(m, "get", ""), m[x] } }; function Yx(m) { const x = S => { m.exposed = S || {} }; return { attrs: new Proxy(m.attrs, Jx), slots: m.slots, emit: m.emit, expose: x } } function np(m) { return m.exposed ? m.exposeProxy || (m.exposeProxy = new Proxy(Fm(By(m.exposed)), { get(x, S) { if (S in x) return x[S]; if (S in _c) return _c[S](m) }, has(x, S) { return S in x || S in _c } })) : m.proxy } function Qx(m) { return Mt(m) && "__vccOpts" in m } const ev = (m, x) => Ny(m, x, Tc), tv = "3.5.13";/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let jd; const im = typeof window < "u" && window.trustedTypes; if (im) try { jd = im.createPolicy("vue", { createHTML: m => m }) } catch { } const __ = jd ? m => jd.createHTML(m) : m => m, iv = "http://www.w3.org/2000/svg", rv = "http://www.w3.org/1998/Math/MathML", us = typeof document < "u" ? document : null, rm = us && us.createElement("template"), nv = { insert: (m, x, S) => { x.insertBefore(m, S || null) }, remove: m => { const x = m.parentNode; x && x.removeChild(m) }, createElement: (m, x, S, z) => { const F = x === "svg" ? us.createElementNS(iv, m) : x === "mathml" ? us.createElementNS(rv, m) : S ? us.createElement(m, { is: S }) : us.createElement(m); return m === "select" && z && z.multiple != null && F.setAttribute("multiple", z.multiple), F }, createText: m => us.createTextNode(m), createComment: m => us.createComment(m), setText: (m, x) => { m.nodeValue = x }, setElementText: (m, x) => { m.textContent = x }, parentNode: m => m.parentNode, nextSibling: m => m.nextSibling, querySelector: m => us.querySelector(m), setScopeId(m, x) { m.setAttribute(x, "") }, insertStaticContent(m, x, S, z, F, Z) { const P = S ? S.previousSibling : x.lastChild; if (F && (F === Z || F.nextSibling)) for (; x.insertBefore(F.cloneNode(!0), S), !(F === Z || !(F = F.nextSibling));); else { rm.innerHTML = __(z === "svg" ? `<svg>${m}</svg>` : z === "mathml" ? `<math>${m}</math>` : m); const c = rm.content; if (z === "svg" || z === "mathml") { const de = c.firstChild; for (; de.firstChild;)c.appendChild(de.firstChild); c.removeChild(de) } x.insertBefore(c, S) } return [P ? P.nextSibling : x.firstChild, S ? S.previousSibling : x.lastChild] } }, sv = Symbol("_vtc"); function ov(m, x, S) { const z = m[sv]; z && (x = (x ? [x, ...z] : [...z]).join(" ")), x == null ? m.removeAttribute("class") : S ? m.setAttribute("class", x) : m.className = x } const nm = Symbol("_vod"), av = Symbol("_vsh"), lv = Symbol(""), cv = /(^|;)\s*display\s*:/; function uv(m, x, S) { const z = m.style, F = ir(S); let Z = !1; if (S && !F) { if (x) if (ir(x)) for (const P of x.split(";")) { const c = P.slice(0, P.indexOf(":")).trim(); S[c] == null && Uu(z, c, "") } else for (const P in x) S[P] == null && Uu(z, P, ""); for (const P in S) P === "display" && (Z = !0), Uu(z, P, S[P]) } else if (F) { if (x !== S) { const P = z[lv]; P && (S += ";" + P), z.cssText = S, Z = cv.test(S) } } else x && m.removeAttribute("style"); nm in m && (m[nm] = Z ? z.display : "", m[av] && (z.display = "none")) } const sm = /\s*!important$/; function Uu(m, x, S) { if (It(S)) S.forEach(z => Uu(m, x, z)); else if (S == null && (S = ""), x.startsWith("--")) m.setProperty(x, S); else { const z = hv(m, x); sm.test(S) ? m.setProperty(So(z), S.replace(sm, ""), "important") : m[z] = S } } const om = ["Webkit", "Moz", "ms"], Id = {}; function hv(m, x) { const S = Id[x]; if (S) return S; let z = Us(x); if (z !== "filter" && z in m) return Id[x] = z; z = gm(z); for (let F = 0; F < om.length; F++) { const Z = om[F] + z; if (Z in m) return Id[x] = Z } return x } const am = "http://www.w3.org/1999/xlink"; function lm(m, x, S, z, F, Z = my(x)) { z && x.startsWith("xlink:") ? S == null ? m.removeAttributeNS(am, x.slice(6, x.length)) : m.setAttributeNS(am, x, S) : S == null || Z && !xm(S) ? m.removeAttribute(x) : m.setAttribute(x, Z ? "" : Va(S) ? String(S) : S) } function cm(m, x, S, z, F) { if (x === "innerHTML" || x === "textContent") { S != null && (m[x] = x === "innerHTML" ? __(S) : S); return } const Z = m.tagName; if (x === "value" && Z !== "PROGRESS" && !Z.includes("-")) { const c = Z === "OPTION" ? m.getAttribute("value") || "" : m.value, de = S == null ? m.type === "checkbox" ? "on" : "" : String(S); (c !== de || !("_value" in m)) && (m.value = de), S == null && m.removeAttribute(x), m._value = S; return } let P = !1; if (S === "" || S == null) { const c = typeof m[x]; c === "boolean" ? S = xm(S) : S == null && c === "string" ? (S = "", P = !0) : c === "number" && (S = 0, P = !0) } try { m[x] = S } catch { } P && m.removeAttribute(F || x) } function dv(m, x, S, z) { m.addEventListener(x, S, z) } function pv(m, x, S, z) { m.removeEventListener(x, S, z) } const um = Symbol("_vei"); function fv(m, x, S, z, F = null) { const Z = m[um] || (m[um] = {}), P = Z[x]; if (z && P) P.value = z; else { const [c, de] = mv(x); if (z) { const ze = Z[x] = yv(z, F); dv(m, c, ze, de) } else P && (pv(m, c, P, de), Z[x] = void 0) } } const hm = /(?:Once|Passive|Capture)$/; function mv(m) { let x; if (hm.test(m)) { x = {}; let z; for (; z = m.match(hm);)m = m.slice(0, m.length - z[0].length), x[z[0].toLowerCase()] = !0 } return [m[2] === ":" ? m.slice(3) : So(m.slice(2)), x] } let Cd = 0; const _v = Promise.resolve(), gv = () => Cd || (_v.then(() => Cd = 0), Cd = Date.now()); function yv(m, x) { const S = z => { if (!z._vts) z._vts = Date.now(); else if (z._vts <= S.attached) return; Nn(xv(z, S.value), x, 5, [z]) }; return S.value = m, S.attached = gv(), S } function xv(m, x) { if (It(x)) { const S = m.stopImmediatePropagation; return m.stopImmediatePropagation = () => { S.call(m), m._stopped = !0 }, x.map(z => F => !F._stopped && z && z(F)) } else return x } const dm = m => m.charCodeAt(0) === 111 && m.charCodeAt(1) === 110 && m.charCodeAt(2) > 96 && m.charCodeAt(2) < 123, vv = (m, x, S, z, F, Z) => { const P = F === "svg"; x === "class" ? ov(m, z, P) : x === "style" ? uv(m, S, z) : Ju(x) ? Nd(x) || fv(m, x, S, z, Z) : (x[0] === "." ? (x = x.slice(1), !0) : x[0] === "^" ? (x = x.slice(1), !1) : bv(m, x, z, P)) ? (cm(m, x, z), !m.tagName.includes("-") && (x === "value" || x === "checked" || x === "selected") && lm(m, x, z, P, Z, x !== "value")) : m._isVueCE && (/[A-Z]/.test(x) || !ir(z)) ? cm(m, Us(x), z, Z, x) : (x === "true-value" ? m._trueValue = z : x === "false-value" && (m._falseValue = z), lm(m, x, z, P)) }; function bv(m, x, S, z) { if (z) return !!(x === "innerHTML" || x === "textContent" || x in m && dm(x) && Mt(S)); if (x === "spellcheck" || x === "draggable" || x === "translate" || x === "form" || x === "list" && m.tagName === "INPUT" || x === "type" && m.tagName === "TEXTAREA") return !1; if (x === "width" || x === "height") { const F = m.tagName; if (F === "IMG" || F === "VIDEO" || F === "CANVAS" || F === "SOURCE") return !1 } return dm(x) && ir(S) ? !1 : x in m } const wv = yr({ patchProp: vv }, nv); let pm; function Tv() { return pm || (pm = Mx(wv)) } const Pv = (...m) => { const x = Tv().createApp(...m), { mount: S } = x; return x.mount = z => { const F = Mv(z); if (!F) return; const Z = x._component; !Mt(Z) && !Z.render && !Z.template && (Z.template = F.innerHTML), F.nodeType === 1 && (F.textContent = ""); const P = S(F, !1, Sv(F)); return F instanceof Element && (F.removeAttribute("v-cloak"), F.setAttribute("data-v-app", "")), P }, x }; function Sv(m) { if (m instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && m instanceof MathMLElement) return "mathml" } function Mv(m) { return ir(m) ? document.querySelector(m) : m } const Iv = "/alta-bikes/images/alta-brand.svg"; function Cv(m) { return m && m.__esModule && Object.prototype.hasOwnProperty.call(m, "default") ? m.default : m } var $u = { exports: {} };/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.2.0/LICENSE.txt
 */var Ev = $u.exports, fm; function Av() {
  return fm || (fm = 1, function (m, x) {
    (function (S, z) { m.exports = z() })(Ev, function () {
      var S = {}, z = {}; function F(P, c, de) { if (z[P] = de, P === "index") { var ze = "var sharedModule = {}; (" + z.shared + ")(sharedModule); (" + z.worker + ")(sharedModule);", xe = {}; return z.shared(xe), z.index(S, xe), typeof window < "u" && S.setWorkerUrl(window.URL.createObjectURL(new Blob([ze], { type: "text/javascript" }))), S } } F("shared", ["exports"], function (P) {
        function c(r, t, n, s) { return new (n || (n = Promise))(function (l, d) { function p(b) { try { y(s.next(b)) } catch (T) { d(T) } } function _(b) { try { y(s.throw(b)) } catch (T) { d(T) } } function y(b) { var T; b.done ? l(b.value) : (T = b.value, T instanceof n ? T : new n(function (M) { M(T) })).then(p, _) } y((s = s.apply(r, t || [])).next()) }) } function de(r) { return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r } var ze, xe; function Fe() { if (xe) return ze; function r(t, n) { this.x = t, this.y = n } return xe = 1, ze = r, r.prototype = { clone: function () { return new r(this.x, this.y) }, add: function (t) { return this.clone()._add(t) }, sub: function (t) { return this.clone()._sub(t) }, multByPoint: function (t) { return this.clone()._multByPoint(t) }, divByPoint: function (t) { return this.clone()._divByPoint(t) }, mult: function (t) { return this.clone()._mult(t) }, div: function (t) { return this.clone()._div(t) }, rotate: function (t) { return this.clone()._rotate(t) }, rotateAround: function (t, n) { return this.clone()._rotateAround(t, n) }, matMult: function (t) { return this.clone()._matMult(t) }, unit: function () { return this.clone()._unit() }, perp: function () { return this.clone()._perp() }, round: function () { return this.clone()._round() }, mag: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, equals: function (t) { return this.x === t.x && this.y === t.y }, dist: function (t) { return Math.sqrt(this.distSqr(t)) }, distSqr: function (t) { var n = t.x - this.x, s = t.y - this.y; return n * n + s * s }, angle: function () { return Math.atan2(this.y, this.x) }, angleTo: function (t) { return Math.atan2(this.y - t.y, this.x - t.x) }, angleWith: function (t) { return this.angleWithSep(t.x, t.y) }, angleWithSep: function (t, n) { return Math.atan2(this.x * n - this.y * t, this.x * t + this.y * n) }, _matMult: function (t) { var n = t[2] * this.x + t[3] * this.y; return this.x = t[0] * this.x + t[1] * this.y, this.y = n, this }, _add: function (t) { return this.x += t.x, this.y += t.y, this }, _sub: function (t) { return this.x -= t.x, this.y -= t.y, this }, _mult: function (t) { return this.x *= t, this.y *= t, this }, _div: function (t) { return this.x /= t, this.y /= t, this }, _multByPoint: function (t) { return this.x *= t.x, this.y *= t.y, this }, _divByPoint: function (t) { return this.x /= t.x, this.y /= t.y, this }, _unit: function () { return this._div(this.mag()), this }, _perp: function () { var t = this.y; return this.y = this.x, this.x = -t, this }, _rotate: function (t) { var n = Math.cos(t), s = Math.sin(t), l = s * this.x + n * this.y; return this.x = n * this.x - s * this.y, this.y = l, this }, _rotateAround: function (t, n) { var s = Math.cos(t), l = Math.sin(t), d = n.y + l * (this.x - n.x) + s * (this.y - n.y); return this.x = n.x + s * (this.x - n.x) - l * (this.y - n.y), this.y = d, this }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } }, r.convert = function (t) { return t instanceof r ? t : Array.isArray(t) ? new r(t[0], t[1]) : t }, ze } typeof SuppressedError == "function" && SuppressedError; var Le, ae, Ge = de(Fe()), Tt = function () { if (ae) return Le; function r(t, n, s, l) { this.cx = 3 * t, this.bx = 3 * (s - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (l - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = s, this.p2y = l } return ae = 1, Le = r, r.prototype = { sampleCurveX: function (t) { return ((this.ax * t + this.bx) * t + this.cx) * t }, sampleCurveY: function (t) { return ((this.ay * t + this.by) * t + this.cy) * t }, sampleCurveDerivativeX: function (t) { return (3 * this.ax * t + 2 * this.bx) * t + this.cx }, solveCurveX: function (t, n) { if (n === void 0 && (n = 1e-6), t < 0) return 0; if (t > 1) return 1; for (var s = t, l = 0; l < 8; l++) { var d = this.sampleCurveX(s) - t; if (Math.abs(d) < n) return s; var p = this.sampleCurveDerivativeX(s); if (Math.abs(p) < 1e-6) break; s -= d / p } var _ = 0, y = 1; for (s = t, l = 0; l < 20 && (d = this.sampleCurveX(s), !(Math.abs(d - t) < n)); l++)t > d ? _ = s : y = s, s = .5 * (y - _) + _; return s }, solve: function (t, n) { return this.sampleCurveY(this.solveCurveX(t, n)) } }, Le }(), ri = de(Tt); let kt, Zt; function qt() { return kt == null && (kt = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), kt } function ot() { if (Zt == null && (Zt = !1, qt())) { const t = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 }); if (t) { for (let s = 0; s < 5 * 5; s++) { const l = 4 * s; t.fillStyle = `rgb(${l},${l + 1},${l + 2})`, t.fillRect(s % 5, Math.floor(s / 5), 1, 1) } const n = t.getImageData(0, 0, 5, 5).data; for (let s = 0; s < 5 * 5 * 4; s++)if (s % 4 != 3 && n[s] !== s) { Zt = !0; break } } } return Zt || !1 } var Ht, Vt = 1e-6, Et = typeof Float32Array < "u" ? Float32Array : Array; function Nt() { var r = new Et(9); return Et != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r } function ln(r) { return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r } function zr() { var r = new Et(3); return Et != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r } function or(r, t, n) { var s = new Et(3); return s[0] = r, s[1] = t, s[2] = n, s } function ar(r, t, n) { var s = t[0], l = t[1], d = t[2], p = t[3]; return r[0] = n[0] * s + n[4] * l + n[8] * d + n[12] * p, r[1] = n[1] * s + n[5] * l + n[9] * d + n[13] * p, r[2] = n[2] * s + n[6] * l + n[10] * d + n[14] * p, r[3] = n[3] * s + n[7] * l + n[11] * d + n[15] * p, r } function Zi() { var r = new Et(4); return Et != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r[3] = 1, r } function bi() { var r = new Et(2); return Et != Float32Array && (r[0] = 0, r[1] = 0), r } function Pn(r, t) { var n = new Et(2); return n[0] = r, n[1] = t, n } Math.hypot || (Math.hypot = function () { for (var r = 0, t = arguments.length; t--;)r += arguments[t] * arguments[t]; return Math.sqrt(r) }), zr(), Ht = new Et(4), Et != Float32Array && (Ht[0] = 0, Ht[1] = 0, Ht[2] = 0, Ht[3] = 0), zr(), or(1, 0, 0), or(0, 1, 0), Zi(), Zi(), Nt(), bi(); const gt = 8192; function Ut(r, t, n) { return t * (gt / (r.tileSize * Math.pow(2, n - r.tileID.overscaledZ))) } function Dt(r, t) { return (r % t + t) % t } function rr(r, t, n) { return r * (1 - n) + t * n } function kr(r) { if (r <= 0) return 0; if (r >= 1) return 1; const t = r * r, n = t * r; return 4 * (r < .5 ? n : 3 * (r - t) + n - .75) } function lr(r, t, n, s) { const l = new ri(r, t, n, s); return d => l.solve(d) } const gi = lr(.25, .1, .25, 1); function cr(r, t, n) { return Math.min(n, Math.max(t, r)) } function ur(r, t, n) { const s = n - t, l = ((r - t) % s + s) % s + t; return l === t ? n : l } function Si(r, ...t) { for (const n of t) for (const s in n) r[s] = n[s]; return r } let xr = 1; function Dr(r, t, n) { const s = {}; for (const l in r) s[l] = t.call(this, r[l], l, r); return s } function Gr(r, t, n) { const s = {}; for (const l in r) t.call(this, r[l], l, r) && (s[l] = r[l]); return s } function Ki(r) { return Array.isArray(r) ? r.map(Ki) : typeof r == "object" && r ? Dr(r, Ki) : r } const qr = {}; function Ui(r) { qr[r] || (typeof console < "u" && console.warn(r), qr[r] = !0) } function te(r, t, n) { return (n.y - r.y) * (t.x - r.x) > (t.y - r.y) * (n.x - r.x) } function le(r) { return typeof WorkerGlobalScope < "u" && r !== void 0 && r instanceof WorkerGlobalScope } let we = null; function Ze(r) { return typeof ImageBitmap < "u" && r instanceof ImageBitmap } const Be = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII="; function Oe(r, t, n, s, l) { return c(this, void 0, void 0, function* () { if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported"); const d = new VideoFrame(r, { timestamp: 0 }); try { const p = d == null ? void 0 : d.format; if (!p || !p.startsWith("BGR") && !p.startsWith("RGB")) throw new Error(`Unrecognized format ${p}`); const _ = p.startsWith("BGR"), y = new Uint8ClampedArray(s * l * 4); if (yield d.copyTo(y, function (b, T, M, k, R) { const L = 4 * Math.max(1, 0), O = (Math.max(0, M) - M) * k * 4 + L, U = 4 * k, W = Math.max(0, T), se = Math.max(0, M); return { rect: { x: W, y: se, width: Math.min(b.width, T + k) - W, height: Math.min(b.height, M + R) - se }, layout: [{ offset: O, stride: U }] } }(r, t, n, s, l)), _) for (let b = 0; b < y.length; b += 4) { const T = y[b]; y[b] = y[b + 2], y[b + 2] = T } return y } finally { d.close() } }) } let Xe, We; function qe(r, t, n, s) { return r.addEventListener(t, n, s), { unsubscribe: () => { r.removeEventListener(t, n, s) } } } function Ve(r) { return r / Math.PI * 180 } const dt = "AbortError"; function Ke() { return new Error(dt) } const ct = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" }; function mt(r) { return ct.REGISTERED_PROTOCOLS[r.substring(0, r.indexOf("://"))] } const vt = "global-dispatcher"; class At extends Error { constructor(t, n, s, l) { super(`AJAXError: ${n} (${t}): ${s}`), this.status = t, this.statusText = n, this.url = s, this.body = l } } const Pt = () => le(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, mi = function (r, t) { if (/:\/\//.test(r.url) && !/^https?:|^file:/.test(r.url)) { const s = mt(r.url); if (s) return s(r, t); if (le(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r, targetMapId: vt }, t) } if (!(/^file:/.test(n = r.url) || /^file:/.test(Pt()) && !/^\w+:/.test(n))) { if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function (s, l) { return c(this, void 0, void 0, function* () { const d = new Request(s.url, { method: s.method || "GET", body: s.body, credentials: s.credentials, headers: s.headers, cache: s.cache, referrer: Pt(), signal: l.signal }); let p, _; s.type !== "json" || d.headers.has("Accept") || d.headers.set("Accept", "application/json"); try { p = yield fetch(d) } catch (b) { throw new At(0, b.message, s.url, new Blob) } if (!p.ok) { const b = yield p.blob(); throw new At(p.status, p.statusText, s.url, b) } _ = s.type === "arrayBuffer" || s.type === "image" ? p.arrayBuffer() : s.type === "json" ? p.json() : p.text(); const y = yield _; if (l.signal.aborted) throw Ke(); return { data: y, cacheControl: p.headers.get("Cache-Control"), expires: p.headers.get("Expires") } }) }(r, t); if (le(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: r, mustQueue: !0, targetMapId: vt }, t) } var n; return function (s, l) { return new Promise((d, p) => { var _; const y = new XMLHttpRequest; y.open(s.method || "GET", s.url, !0), s.type !== "arrayBuffer" && s.type !== "image" || (y.responseType = "arraybuffer"); for (const b in s.headers) y.setRequestHeader(b, s.headers[b]); s.type === "json" && (y.responseType = "text", !((_ = s.headers) === null || _ === void 0) && _.Accept || y.setRequestHeader("Accept", "application/json")), y.withCredentials = s.credentials === "include", y.onerror = () => { p(new Error(y.statusText)) }, y.onload = () => { if (!l.signal.aborted) if ((y.status >= 200 && y.status < 300 || y.status === 0) && y.response !== null) { let b = y.response; if (s.type === "json") try { b = JSON.parse(y.response) } catch (T) { return void p(T) } d({ data: b, cacheControl: y.getResponseHeader("Cache-Control"), expires: y.getResponseHeader("Expires") }) } else { const b = new Blob([y.response], { type: y.getResponseHeader("Content-Type") }); p(new At(y.status, y.statusText, s.url, b)) } }, l.signal.addEventListener("abort", () => { y.abort(), p(Ke()) }), y.send(s.body) }) }(r, t) }; function ui(r) { if (!r || r.indexOf("://") <= 0 || r.indexOf("data:image/") === 0 || r.indexOf("blob:") === 0) return !0; const t = new URL(r), n = window.location; return t.protocol === n.protocol && t.host === n.host } function Ji(r, t, n) { n[r] && n[r].indexOf(t) !== -1 || (n[r] = n[r] || [], n[r].push(t)) } function $i(r, t, n) { if (n && n[r]) { const s = n[r].indexOf(t); s !== -1 && n[r].splice(s, 1) } } class Hr { constructor(t, n = {}) { Si(this, n), this.type = t } } class Rr extends Hr { constructor(t, n = {}) { super("error", Si({ error: t }, n)) } } class ue { on(t, n) { return this._listeners = this._listeners || {}, Ji(t, n, this._listeners), { unsubscribe: () => { this.off(t, n) } } } off(t, n) { return $i(t, n, this._listeners), $i(t, n, this._oneTimeListeners), this } once(t, n) { return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, Ji(t, n, this._oneTimeListeners), this) : new Promise(s => this.once(t, s)) } fire(t, n) { typeof t == "string" && (t = new Hr(t, n || {})); const s = t.type; if (this.listens(s)) { t.target = this; const l = this._listeners && this._listeners[s] ? this._listeners[s].slice() : []; for (const _ of l) _.call(this, t); const d = this._oneTimeListeners && this._oneTimeListeners[s] ? this._oneTimeListeners[s].slice() : []; for (const _ of d) $i(s, _, this._oneTimeListeners), _.call(this, t); const p = this._eventedParent; p && (Si(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), p.fire(t)) } else t instanceof Rr && console.error(t.error); return this } listens(t) { return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t) } setEventedParent(t, n) { return this._eventedParent = t, this._eventedParentData = n, this } } var C = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: .375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: .5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: .5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: .8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: .8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: .8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: .5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }; const V = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"]; function $(r, t) { const n = {}; for (const s in r) s !== "ref" && (n[s] = r[s]); return V.forEach(s => { s in t && (n[s] = t[s]) }), n } function X(r, t) { if (Array.isArray(r)) { if (!Array.isArray(t) || r.length !== t.length) return !1; for (let n = 0; n < r.length; n++)if (!X(r[n], t[n])) return !1; return !0 } if (typeof r == "object" && r !== null && t !== null) { if (typeof t != "object" || Object.keys(r).length !== Object.keys(t).length) return !1; for (const n in r) if (!X(r[n], t[n])) return !1; return !0 } return r === t } function ie(r, t) { r.push(t) } function he(r, t, n) { ie(n, { command: "addSource", args: [r, t[r]] }) } function ye(r, t, n) { ie(t, { command: "removeSource", args: [r] }), n[r] = !0 } function ce(r, t, n, s) { ye(r, n, s), he(r, t, n) } function Me(r, t, n) { let s; for (s in r[n]) if (Object.prototype.hasOwnProperty.call(r[n], s) && s !== "data" && !X(r[n][s], t[n][s])) return !1; for (s in t[n]) if (Object.prototype.hasOwnProperty.call(t[n], s) && s !== "data" && !X(r[n][s], t[n][s])) return !1; return !0 } function be(r, t, n, s, l, d) { r = r || {}, t = t || {}; for (const p in r) Object.prototype.hasOwnProperty.call(r, p) && (X(r[p], t[p]) || n.push({ command: d, args: [s, p, t[p], l] })); for (const p in t) Object.prototype.hasOwnProperty.call(t, p) && !Object.prototype.hasOwnProperty.call(r, p) && (X(r[p], t[p]) || n.push({ command: d, args: [s, p, t[p], l] })) } function pe(r) { return r.id } function Ae(r, t) { return r[t.id] = t, r } class fe { constructor(t, n, s, l) { this.message = (t ? `${t}: ` : "") + s, l && (this.identifier = l), n != null && n.__line__ && (this.line = n.__line__) } } function He(r, ...t) { for (const n of t) for (const s in n) r[s] = n[s]; return r } class rt extends Error { constructor(t, n) { super(n), this.message = n, this.key = t } } class _t { constructor(t, n = []) { this.parent = t, this.bindings = {}; for (const [s, l] of n) this.bindings[s] = l } concat(t) { return new _t(this, t) } get(t) { if (this.bindings[t]) return this.bindings[t]; if (this.parent) return this.parent.get(t); throw new Error(`${t} not found in scope.`) } has(t) { return !!this.bindings[t] || !!this.parent && this.parent.has(t) } } const pt = { kind: "null" }, Ee = { kind: "number" }, et = { kind: "string" }, Qe = { kind: "boolean" }, xt = { kind: "color" }, ft = { kind: "projectionDefinition" }, bt = { kind: "object" }, at = { kind: "value" }, Zn = { kind: "collator" }, wi = { kind: "formatted" }, Mi = { kind: "padding" }, Qt = { kind: "resolvedImage" }, Mo = { kind: "variableAnchorOffsetCollection" }; function hr(r, t) { return { kind: "array", itemType: r, N: t } } function Wt(r) { if (r.kind === "array") { const t = Wt(r.itemType); return typeof r.N == "number" ? `array<${t}, ${r.N}>` : r.itemType.kind === "value" ? "array" : `array<${t}>` } return r.kind } const Mc = [pt, Ee, et, Qe, xt, ft, wi, bt, hr(at), Mi, Qt, Mo]; function qs(r, t) { if (t.kind === "error") return null; if (r.kind === "array") { if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !qs(r.itemType, t.itemType)) && (typeof r.N != "number" || r.N === t.N)) return null } else { if (r.kind === t.kind) return null; if (r.kind === "value") { for (const n of Mc) if (!qs(n, t)) return null } } return `Expected ${Wt(r)} but found ${Wt(t)} instead.` } function Na(r, t) { return t.some(n => n.kind === r.kind) } function Sn(r, t) { return t.some(n => n === "null" ? r === null : n === "array" ? Array.isArray(r) : n === "object" ? r && !Array.isArray(r) && typeof r == "object" : n === typeof r) } function fs(r, t) { return r.kind === "array" && t.kind === "array" ? r.itemType.kind === t.itemType.kind && typeof r.N == "number" : r.kind === t.kind } const Za = .96422, Ic = .82521, Cc = 4 / 29, ms = 6 / 29, Ec = 3 * ms * ms, sh = ms * ms * ms, oh = Math.PI / 180, ah = 180 / Math.PI; function Ua(r) { return (r %= 360) < 0 && (r += 360), r } function _s([r, t, n, s]) { let l, d; const p = Ga((.2225045 * (r = $a(r)) + .7168786 * (t = $a(t)) + .0606169 * (n = $a(n))) / 1); r === t && t === n ? l = d = p : (l = Ga((.4360747 * r + .3850649 * t + .1430804 * n) / Za), d = Ga((.0139322 * r + .0971045 * t + .7141733 * n) / Ic)); const _ = 116 * p - 16; return [_ < 0 ? 0 : _, 500 * (l - p), 200 * (p - d), s] } function $a(r) { return r <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4) } function Ga(r) { return r > sh ? Math.pow(r, 1 / 3) : r / Ec + Cc } function gs([r, t, n, s]) { let l = (r + 16) / 116, d = isNaN(t) ? l : l + t / 500, p = isNaN(n) ? l : l - n / 200; return l = 1 * Ha(l), d = Za * Ha(d), p = Ic * Ha(p), [qa(3.1338561 * d - 1.6168667 * l - .4906146 * p), qa(-.9787684 * d + 1.9161415 * l + .033454 * p), qa(.0719453 * d - .2289914 * l + 1.4052427 * p), s] } function qa(r) { return (r = r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055) < 0 ? 0 : r > 1 ? 1 : r } function Ha(r) { return r > ms ? r * r * r : Ec * (r - Cc) } function Io(r) { return parseInt(r.padEnd(2, r), 16) / 255 } function Wa(r, t) { return Un(t ? r / 100 : r, 0, 1) } function Un(r, t, n) { return Math.min(Math.max(t, r), n) } function Wr(r) { return !r.some(Number.isNaN) } const Rt = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }; function vr(r, t, n) { return r + n * (t - r) } function Lr(r, t, n) { return r.map((s, l) => vr(s, t[l], n)) } class Lt { constructor(t, n, s, l = 1, d = !0) { this.r = t, this.g = n, this.b = s, this.a = l, d || (this.r *= l, this.g *= l, this.b *= l, l || this.overwriteGetter("rgb", [t, n, s, l])) } static parse(t) { if (t instanceof Lt) return t; if (typeof t != "string") return; const n = function (s) { if ((s = s.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0]; const l = Rt[s]; if (l) { const [p, _, y] = l; return [p / 255, _ / 255, y / 255, 1] } if (s.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(s)) { const p = s.length < 6 ? 1 : 2; let _ = 1; return [Io(s.slice(_, _ += p)), Io(s.slice(_, _ += p)), Io(s.slice(_, _ += p)), Io(s.slice(_, _ + p) || "ff")] } if (s.startsWith("rgb")) { const p = s.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/); if (p) { const [_, y, b, T, M, k, R, L, O, U, W, se] = p, J = [T || " ", R || " ", U].join(""); if (J === "  " || J === "  /" || J === ",," || J === ",,,") { const D = [b, k, O].join(""), N = D === "%%%" ? 100 : D === "" ? 255 : 0; if (N) { const Y = [Un(+y / N, 0, 1), Un(+M / N, 0, 1), Un(+L / N, 0, 1), W ? Wa(+W, se) : 1]; if (Wr(Y)) return Y } } return } } const d = s.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/); if (d) { const [p, _, y, b, T, M, k, R, L] = d, O = [y || " ", T || " ", k].join(""); if (O === "  " || O === "  /" || O === ",," || O === ",,,") { const U = [+_, Un(+b, 0, 100), Un(+M, 0, 100), R ? Wa(+R, L) : 1]; if (Wr(U)) return function ([W, se, J, D]) { function N(Y) { const _e = (Y + W / 30) % 12, ke = se * Math.min(J, 1 - J); return J - ke * Math.max(-1, Math.min(_e - 3, 9 - _e, 1)) } return W = Ua(W), se /= 100, J /= 100, [N(0), N(8), N(4), D] }(U) } } }(t); return n ? new Lt(...n, !1) : void 0 } get rgb() { const { r: t, g: n, b: s, a: l } = this, d = l || 1 / 0; return this.overwriteGetter("rgb", [t / d, n / d, s / d, l]) } get hcl() { return this.overwriteGetter("hcl", function (t) { const [n, s, l, d] = _s(t), p = Math.sqrt(s * s + l * l); return [Math.round(1e4 * p) ? Ua(Math.atan2(l, s) * ah) : NaN, p, n, d] }(this.rgb)) } get lab() { return this.overwriteGetter("lab", _s(this.rgb)) } overwriteGetter(t, n) { return Object.defineProperty(this, t, { value: n }), n } toString() { const [t, n, s, l] = this.rgb; return `rgba(${[t, n, s].map(d => Math.round(255 * d)).join(",")},${l})` } static interpolate(t, n, s, l = "rgb") { switch (l) { case "rgb": { const [d, p, _, y] = Lr(t.rgb, n.rgb, s); return new Lt(d, p, _, y, !1) } case "hcl": { const [d, p, _, y] = t.hcl, [b, T, M, k] = n.hcl; let R, L; if (isNaN(d) || isNaN(b)) isNaN(d) ? isNaN(b) ? R = NaN : (R = b, _ !== 1 && _ !== 0 || (L = T)) : (R = d, M !== 1 && M !== 0 || (L = p)); else { let J = b - d; b > d && J > 180 ? J -= 360 : b < d && d - b > 180 && (J += 360), R = d + s * J } const [O, U, W, se] = function ([J, D, N, Y]) { return J = isNaN(J) ? 0 : J * oh, gs([N, Math.cos(J) * D, Math.sin(J) * D, Y]) }([R, L ?? vr(p, T, s), vr(_, M, s), vr(y, k, s)]); return new Lt(O, U, W, se, !1) } case "lab": { const [d, p, _, y] = gs(Lr(t.lab, n.lab, s)); return new Lt(d, p, _, y, !1) } } } } Lt.black = new Lt(0, 0, 0, 1), Lt.white = new Lt(1, 1, 1, 1), Lt.transparent = new Lt(0, 0, 0, 0), Lt.red = new Lt(1, 0, 0, 1); class Co { constructor(t, n, s) { this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = s, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" }) } compare(t, n) { return this.collator.compare(t, n) } resolvedLocale() { return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale } } const Xa = ["bottom", "center", "top"]; class Fr { constructor(t, n, s, l, d, p) { this.text = t, this.image = n, this.scale = s, this.fontStack = l, this.textColor = d, this.verticalAlign = p } } class Gi { constructor(t) { this.sections = t } static fromString(t) { return new Gi([new Fr(t, null, null, null, null, null)]) } isEmpty() { return this.sections.length === 0 || !this.sections.some(t => t.text.length !== 0 || t.image && t.image.name.length !== 0) } static factory(t) { return t instanceof Gi ? t : Gi.fromString(t) } toString() { return this.sections.length === 0 ? "" : this.sections.map(t => t.text).join("") } } class Di { constructor(t) { this.values = t.slice() } static parse(t) { if (t instanceof Di) return t; if (typeof t == "number") return new Di([t, t, t, t]); if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) { for (const n of t) if (typeof n != "number") return; switch (t.length) { case 1: t = [t[0], t[0], t[0], t[0]]; break; case 2: t = [t[0], t[1], t[0], t[1]]; break; case 3: t = [t[0], t[1], t[2], t[1]] }return new Di(t) } } toString() { return JSON.stringify(this.values) } static interpolate(t, n, s) { return new Di(Lr(t.values, n.values, s)) } } class hi { constructor(t) { this.name = "ExpressionEvaluationError", this.message = t } toJSON() { return this.message } } const Ka = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]); class Ri { constructor(t) { this.values = t.slice() } static parse(t) { if (t instanceof Ri) return t; if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) { for (let n = 0; n < t.length; n += 2) { const s = t[n], l = t[n + 1]; if (typeof s != "string" || !Ka.has(s) || !Array.isArray(l) || l.length !== 2 || typeof l[0] != "number" || typeof l[1] != "number") return } return new Ri(t) } } toString() { return JSON.stringify(this.values) } static interpolate(t, n, s) { const l = t.values, d = n.values; if (l.length !== d.length) throw new hi(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${n.toString()}`); const p = []; for (let _ = 0; _ < l.length; _ += 2) { if (l[_] !== d[_]) throw new hi(`Cannot interpolate values containing mismatched anchors. from[${_}]: ${l[_]}, to[${_}]: ${d[_]}`); p.push(l[_]); const [y, b] = l[_ + 1], [T, M] = d[_ + 1]; p.push([vr(y, T, s), vr(b, M, s)]) } return new Ri(p) } } class nr { constructor(t) { this.name = t.name, this.available = t.available } toString() { return this.name } static fromString(t) { return t ? new nr({ name: t, available: !1 }) : null } } class dr { constructor(t, n, s) { this.from = t, this.to = n, this.transition = s } static interpolate(t, n, s) { return new dr(t, n, s) } static parse(t) { return t instanceof dr ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new dr(t[0], t[1], t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new dr(t.from, t.to, t.transition) : typeof t == "string" ? new dr(t, t, 1) : void 0 } } function Eo(r, t, n, s) { return typeof r == "number" && r >= 0 && r <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? s === void 0 || typeof s == "number" && s >= 0 && s <= 1 ? null : `Invalid rgba value [${[r, t, n, s].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof s == "number" ? [r, t, n, s] : [r, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.` } function Xr(r) { if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof dr || r instanceof Lt || r instanceof Co || r instanceof Gi || r instanceof Di || r instanceof Ri || r instanceof nr) return !0; if (Array.isArray(r)) { for (const t of r) if (!Xr(t)) return !1; return !0 } if (typeof r == "object") { for (const t in r) if (!Xr(r[t])) return !1; return !0 } return !1 } function Ti(r) { if (r === null) return pt; if (typeof r == "string") return et; if (typeof r == "boolean") return Qe; if (typeof r == "number") return Ee; if (r instanceof Lt) return xt; if (r instanceof dr) return ft; if (r instanceof Co) return Zn; if (r instanceof Gi) return wi; if (r instanceof Di) return Mi; if (r instanceof Ri) return Mo; if (r instanceof nr) return Qt; if (Array.isArray(r)) { const t = r.length; let n; for (const s of r) { const l = Ti(s); if (n) { if (n === l) continue; n = at; break } n = l } return hr(n || at, t) } return bt } function Mn(r) { const t = typeof r; return r === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(r) : r instanceof Lt || r instanceof dr || r instanceof Gi || r instanceof Di || r instanceof Ri || r instanceof nr ? r.toString() : JSON.stringify(r) } class Br { constructor(t, n) { this.type = t, this.value = n } static parse(t, n) { if (t.length !== 2) return n.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`); if (!Xr(t[1])) return n.error("invalid value"); const s = t[1]; let l = Ti(s); const d = n.expectedType; return l.kind !== "array" || l.N !== 0 || !d || d.kind !== "array" || typeof d.N == "number" && d.N !== 0 || (l = d), new Br(l, s) } evaluate() { return this.value } eachChild() { } outputDefined() { return !0 } } const Hs = { string: et, number: Ee, boolean: Qe, object: bt }; class Or { constructor(t, n) { this.type = t, this.args = n } static parse(t, n) { if (t.length < 2) return n.error("Expected at least one argument."); let s, l = 1; const d = t[0]; if (d === "array") { let _, y; if (t.length > 2) { const b = t[1]; if (typeof b != "string" || !(b in Hs) || b === "object") return n.error('The item type argument of "array" must be one of string, number, boolean', 1); _ = Hs[b], l++ } else _ = at; if (t.length > 3) { if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2]))) return n.error('The length argument to "array" must be a positive integer literal', 2); y = t[2], l++ } s = hr(_, y) } else { if (!Hs[d]) throw new Error(`Types doesn't contain name = ${d}`); s = Hs[d] } const p = []; for (; l < t.length; l++) { const _ = n.parse(t[l], l, at); if (!_) return null; p.push(_) } return new Or(s, p) } evaluate(t) { for (let n = 0; n < this.args.length; n++) { const s = this.args[n].evaluate(t); if (!qs(this.type, Ti(s))) return s; if (n === this.args.length - 1) throw new hi(`Expected value to be of type ${Wt(this.type)}, but found ${Wt(Ti(s))} instead.`) } throw new Error } eachChild(t) { this.args.forEach(t) } outputDefined() { return this.args.every(t => t.outputDefined()) } } const Ja = { "to-boolean": Qe, "to-color": xt, "to-number": Ee, "to-string": et }; class Kr { constructor(t, n) { this.type = t, this.args = n } static parse(t, n) { if (t.length < 2) return n.error("Expected at least one argument."); const s = t[0]; if (!Ja[s]) throw new Error(`Can't parse ${s} as it is not part of the known types`); if ((s === "to-boolean" || s === "to-string") && t.length !== 2) return n.error("Expected one argument."); const l = Ja[s], d = []; for (let p = 1; p < t.length; p++) { const _ = n.parse(t[p], p, at); if (!_) return null; d.push(_) } return new Kr(l, d) } evaluate(t) { switch (this.type.kind) { case "boolean": return !!this.args[0].evaluate(t); case "color": { let n, s; for (const l of this.args) { if (n = l.evaluate(t), s = null, n instanceof Lt) return n; if (typeof n == "string") { const d = t.parseColor(n); if (d) return d } else if (Array.isArray(n) && (s = n.length < 3 || n.length > 4 ? `Invalid rgba value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : Eo(n[0], n[1], n[2], n[3]), !s)) return new Lt(n[0] / 255, n[1] / 255, n[2] / 255, n[3]) } throw new hi(s || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`) } case "padding": { let n; for (const s of this.args) { n = s.evaluate(t); const l = Di.parse(n); if (l) return l } throw new hi(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`) } case "variableAnchorOffsetCollection": { let n; for (const s of this.args) { n = s.evaluate(t); const l = Ri.parse(n); if (l) return l } throw new hi(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`) } case "number": { let n = null; for (const s of this.args) { if (n = s.evaluate(t), n === null) return 0; const l = Number(n); if (!isNaN(l)) return l } throw new hi(`Could not convert ${JSON.stringify(n)} to number.`) } case "formatted": return Gi.fromString(Mn(this.args[0].evaluate(t))); case "resolvedImage": return nr.fromString(Mn(this.args[0].evaluate(t))); case "projectionDefinition": return this.args[0].evaluate(t); default: return Mn(this.args[0].evaluate(t)) } } eachChild(t) { this.args.forEach(t) } outputDefined() { return this.args.every(t => t.outputDefined()) } } const ni = ["Unknown", "Point", "LineString", "Polygon"]; class Ao { constructor() { this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null } id() { return this.feature && "id" in this.feature ? this.feature.id : null } geometryType() { return this.feature ? typeof this.feature.type == "number" ? ni[this.feature.type] : this.feature.type : null } geometry() { return this.feature && "geometry" in this.feature ? this.feature.geometry : null } canonicalID() { return this.canonical } properties() { return this.feature && this.feature.properties || {} } parseColor(t) { let n = this._parseColorCache[t]; return n || (n = this._parseColorCache[t] = Lt.parse(t)), n } } class Ct { constructor(t, n, s = [], l, d = new _t, p = []) { this.registry = t, this.path = s, this.key = s.map(_ => `[${_}]`).join(""), this.scope = d, this.errors = p, this.expectedType = l, this._isConstant = n } parse(t, n, s, l, d = {}) { return n ? this.concat(n, s, l)._parse(t, d) : this._parse(t, d) } _parse(t, n) { function s(l, d, p) { return p === "assert" ? new Or(d, [l]) : p === "coerce" ? new Kr(d, [l]) : l } if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]), Array.isArray(t)) { if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'); const l = t[0]; if (typeof l != "string") return this.error(`Expression name must be a string, but found ${typeof l} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null; const d = this.registry[l]; if (d) { let p = d.parse(t, this); if (!p) return null; if (this.expectedType) { const _ = this.expectedType, y = p.type; if (_.kind !== "string" && _.kind !== "number" && _.kind !== "boolean" && _.kind !== "object" && _.kind !== "array" || y.kind !== "value") if (_.kind !== "projectionDefinition" || y.kind !== "string" && y.kind !== "array") if (_.kind !== "color" && _.kind !== "formatted" && _.kind !== "resolvedImage" || y.kind !== "value" && y.kind !== "string") if (_.kind !== "padding" || y.kind !== "value" && y.kind !== "number" && y.kind !== "array") if (_.kind !== "variableAnchorOffsetCollection" || y.kind !== "value" && y.kind !== "array") { if (this.checkSubtype(_, y)) return null } else p = s(p, _, n.typeAnnotation || "coerce"); else p = s(p, _, n.typeAnnotation || "coerce"); else p = s(p, _, n.typeAnnotation || "coerce"); else p = s(p, _, n.typeAnnotation || "coerce"); else p = s(p, _, n.typeAnnotation || "assert") } if (!(p instanceof Br) && p.type.kind !== "resolvedImage" && this._isConstant(p)) { const _ = new Ao; try { p = new Br(p.type, p.evaluate(_)) } catch (y) { return this.error(y.message), null } } return p } return this.error(`Unknown expression "${l}". If you wanted a literal array, use ["literal", [...]].`, 0) } return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`) } concat(t, n, s) { const l = typeof t == "number" ? this.path.concat(t) : this.path, d = s ? this.scope.concat(s) : this.scope; return new Ct(this.registry, this._isConstant, l, n || null, d, this.errors) } error(t, ...n) { const s = `${this.key}${n.map(l => `[${l}]`).join("")}`; this.errors.push(new rt(s, t)) } checkSubtype(t, n) { const s = qs(t, n); return s && this.error(s), s } } class yt { constructor(t, n) { this.type = n.type, this.bindings = [].concat(t), this.result = n } evaluate(t) { return this.result.evaluate(t) } eachChild(t) { for (const n of this.bindings) t(n[1]); t(this.result) } static parse(t, n) { if (t.length < 4) return n.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`); const s = []; for (let d = 1; d < t.length - 1; d += 2) { const p = t[d]; if (typeof p != "string") return n.error(`Expected string, but found ${typeof p} instead.`, d); if (/[^a-zA-Z0-9_]/.test(p)) return n.error("Variable names must contain only alphanumeric characters or '_'.", d); const _ = n.parse(t[d + 1], d + 1); if (!_) return null; s.push([p, _]) } const l = n.parse(t[t.length - 1], t.length - 1, n.expectedType, s); return l ? new yt(s, l) : null } outputDefined() { return this.result.outputDefined() } } class ys { constructor(t, n) { this.type = n.type, this.name = t, this.boundExpression = n } static parse(t, n) { if (t.length !== 2 || typeof t[1] != "string") return n.error("'var' expression requires exactly one string literal argument."); const s = t[1]; return n.scope.has(s) ? new ys(s, n.scope.get(s)) : n.error(`Unknown variable "${s}". Make sure "${s}" has been bound in an enclosing "let" expression before using it.`, 1) } evaluate(t) { return this.boundExpression.evaluate(t) } eachChild() { } outputDefined() { return !1 } } class zt { constructor(t, n, s) { this.type = t, this.index = n, this.input = s } static parse(t, n) { if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`); const s = n.parse(t[1], 1, Ee), l = n.parse(t[2], 2, hr(n.expectedType || at)); return s && l ? new zt(l.type.itemType, s, l) : null } evaluate(t) { const n = this.index.evaluate(t), s = this.input.evaluate(t); if (n < 0) throw new hi(`Array index out of bounds: ${n} < 0.`); if (n >= s.length) throw new hi(`Array index out of bounds: ${n} > ${s.length - 1}.`); if (n !== Math.floor(n)) throw new hi(`Array index must be an integer, but found ${n} instead.`); return s[n] } eachChild(t) { t(this.index), t(this.input) } outputDefined() { return !1 } } class Ws { constructor(t, n) { this.type = Qe, this.needle = t, this.haystack = n } static parse(t, n) { if (t.length !== 3) return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`); const s = n.parse(t[1], 1, at), l = n.parse(t[2], 2, at); return s && l ? Na(s.type, [Qe, et, Ee, pt, at]) ? new Ws(s, l) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Wt(s.type)} instead`) : null } evaluate(t) { const n = this.needle.evaluate(t), s = this.haystack.evaluate(t); if (!s) return !1; if (!Sn(n, ["boolean", "string", "number", "null"])) throw new hi(`Expected first argument to be of type boolean, string, number or null, but found ${Wt(Ti(n))} instead.`); if (!Sn(s, ["string", "array"])) throw new hi(`Expected second argument to be of type array or string, but found ${Wt(Ti(s))} instead.`); return s.indexOf(n) >= 0 } eachChild(t) { t(this.needle), t(this.haystack) } outputDefined() { return !0 } } class jr { constructor(t, n, s) { this.type = Ee, this.needle = t, this.haystack = n, this.fromIndex = s } static parse(t, n) { if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`); const s = n.parse(t[1], 1, at), l = n.parse(t[2], 2, at); if (!s || !l) return null; if (!Na(s.type, [Qe, et, Ee, pt, at])) return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${Wt(s.type)} instead`); if (t.length === 4) { const d = n.parse(t[3], 3, Ee); return d ? new jr(s, l, d) : null } return new jr(s, l) } evaluate(t) { const n = this.needle.evaluate(t), s = this.haystack.evaluate(t); if (!Sn(n, ["boolean", "string", "number", "null"])) throw new hi(`Expected first argument to be of type boolean, string, number or null, but found ${Wt(Ti(n))} instead.`); let l; if (this.fromIndex && (l = this.fromIndex.evaluate(t)), Sn(s, ["string"])) { const d = s.indexOf(n, l); return d === -1 ? -1 : [...s.slice(0, d)].length } if (Sn(s, ["array"])) return s.indexOf(n, l); throw new hi(`Expected second argument to be of type array or string, but found ${Wt(Ti(s))} instead.`) } eachChild(t) { t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex) } outputDefined() { return !1 } } class Xs { constructor(t, n, s, l, d, p) { this.inputType = t, this.type = n, this.input = s, this.cases = l, this.outputs = d, this.otherwise = p } static parse(t, n) { if (t.length < 5) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`); if (t.length % 2 != 1) return n.error("Expected an even number of arguments."); let s, l; n.expectedType && n.expectedType.kind !== "value" && (l = n.expectedType); const d = {}, p = []; for (let b = 2; b < t.length - 1; b += 2) { let T = t[b]; const M = t[b + 1]; Array.isArray(T) || (T = [T]); const k = n.concat(b); if (T.length === 0) return k.error("Expected at least one branch label."); for (const L of T) { if (typeof L != "number" && typeof L != "string") return k.error("Branch labels must be numbers or strings."); if (typeof L == "number" && Math.abs(L) > Number.MAX_SAFE_INTEGER) return k.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`); if (typeof L == "number" && Math.floor(L) !== L) return k.error("Numeric branch labels must be integer values."); if (s) { if (k.checkSubtype(s, Ti(L))) return null } else s = Ti(L); if (d[String(L)] !== void 0) return k.error("Branch labels must be unique."); d[String(L)] = p.length } const R = n.parse(M, b, l); if (!R) return null; l = l || R.type, p.push(R) } const _ = n.parse(t[1], 1, at); if (!_) return null; const y = n.parse(t[t.length - 1], t.length - 1, l); return y ? _.type.kind !== "value" && n.concat(1).checkSubtype(s, _.type) ? null : new Xs(s, l, _, d, p, y) : null } evaluate(t) { const n = this.input.evaluate(t); return (Ti(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t) } eachChild(t) { t(this.input), this.outputs.forEach(t), t(this.otherwise) } outputDefined() { return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined() } } class zo { constructor(t, n, s) { this.type = t, this.branches = n, this.otherwise = s } static parse(t, n) { if (t.length < 4) return n.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`); if (t.length % 2 != 0) return n.error("Expected an odd number of arguments."); let s; n.expectedType && n.expectedType.kind !== "value" && (s = n.expectedType); const l = []; for (let p = 1; p < t.length - 1; p += 2) { const _ = n.parse(t[p], p, Qe); if (!_) return null; const y = n.parse(t[p + 1], p + 1, s); if (!y) return null; l.push([_, y]), s = s || y.type } const d = n.parse(t[t.length - 1], t.length - 1, s); if (!d) return null; if (!s) throw new Error("Can't infer output type"); return new zo(s, l, d) } evaluate(t) { for (const [n, s] of this.branches) if (n.evaluate(t)) return s.evaluate(t); return this.otherwise.evaluate(t) } eachChild(t) { for (const [n, s] of this.branches) t(n), t(s); t(this.otherwise) } outputDefined() { return this.branches.every(([t, n]) => n.outputDefined()) && this.otherwise.outputDefined() } } class Ks { constructor(t, n, s, l) { this.type = t, this.input = n, this.beginIndex = s, this.endIndex = l } static parse(t, n) { if (t.length <= 2 || t.length >= 5) return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`); const s = n.parse(t[1], 1, at), l = n.parse(t[2], 2, Ee); if (!s || !l) return null; if (!Na(s.type, [hr(at), et, at])) return n.error(`Expected first argument to be of type array or string, but found ${Wt(s.type)} instead`); if (t.length === 4) { const d = n.parse(t[3], 3, Ee); return d ? new Ks(s.type, s, l, d) : null } return new Ks(s.type, s, l) } evaluate(t) { const n = this.input.evaluate(t), s = this.beginIndex.evaluate(t); let l; if (this.endIndex && (l = this.endIndex.evaluate(t)), Sn(n, ["string"])) return [...n].slice(s, l).join(""); if (Sn(n, ["array"])) return n.slice(s, l); throw new hi(`Expected first argument to be of type array or string, but found ${Wt(Ti(n))} instead.`) } eachChild(t) { t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex) } outputDefined() { return !1 } } function xs(r, t) { const n = r.length - 1; let s, l, d = 0, p = n, _ = 0; for (; d <= p;)if (_ = Math.floor((d + p) / 2), s = r[_], l = r[_ + 1], s <= t) { if (_ === n || t < l) return _; d = _ + 1 } else { if (!(s > t)) throw new hi("Input is not a number."); p = _ - 1 } return 0 } class vs { constructor(t, n, s) { this.type = t, this.input = n, this.labels = [], this.outputs = []; for (const [l, d] of s) this.labels.push(l), this.outputs.push(d) } static parse(t, n) { if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`); if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments."); const s = n.parse(t[1], 1, Ee); if (!s) return null; const l = []; let d = null; n.expectedType && n.expectedType.kind !== "value" && (d = n.expectedType); for (let p = 1; p < t.length; p += 2) { const _ = p === 1 ? -1 / 0 : t[p], y = t[p + 1], b = p, T = p + 1; if (typeof _ != "number") return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', b); if (l.length && l[l.length - 1][0] >= _) return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', b); const M = n.parse(y, T, d); if (!M) return null; d = d || M.type, l.push([_, M]) } return new vs(d, s, l) } evaluate(t) { const n = this.labels, s = this.outputs; if (n.length === 1) return s[0].evaluate(t); const l = this.input.evaluate(t); if (l <= n[0]) return s[0].evaluate(t); const d = n.length; return l >= n[d - 1] ? s[d - 1].evaluate(t) : s[xs(n, l)].evaluate(t) } eachChild(t) { t(this.input); for (const n of this.outputs) t(n) } outputDefined() { return this.outputs.every(t => t.outputDefined()) } } function lh(r) { return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r } var ko, Ya, Js = function () { if (Ya) return ko; function r(t, n, s, l) { this.cx = 3 * t, this.bx = 3 * (s - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (l - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = s, this.p2y = l } return Ya = 1, ko = r, r.prototype = { sampleCurveX: function (t) { return ((this.ax * t + this.bx) * t + this.cx) * t }, sampleCurveY: function (t) { return ((this.ay * t + this.by) * t + this.cy) * t }, sampleCurveDerivativeX: function (t) { return (3 * this.ax * t + 2 * this.bx) * t + this.cx }, solveCurveX: function (t, n) { if (n === void 0 && (n = 1e-6), t < 0) return 0; if (t > 1) return 1; for (var s = t, l = 0; l < 8; l++) { var d = this.sampleCurveX(s) - t; if (Math.abs(d) < n) return s; var p = this.sampleCurveDerivativeX(s); if (Math.abs(p) < 1e-6) break; s -= d / p } var _ = 0, y = 1; for (s = t, l = 0; l < 20 && (d = this.sampleCurveX(s), !(Math.abs(d - t) < n)); l++)t > d ? _ = s : y = s, s = .5 * (y - _) + _; return s }, solve: function (t, n) { return this.sampleCurveY(this.solveCurveX(t, n)) } }, ko }(), Yi = lh(Js); class Qi { constructor(t, n, s, l, d) { this.type = t, this.operator = n, this.interpolation = s, this.input = l, this.labels = [], this.outputs = []; for (const [p, _] of d) this.labels.push(p), this.outputs.push(_) } static interpolationFactor(t, n, s, l) { let d = 0; if (t.name === "exponential") d = Do(n, t.base, s, l); else if (t.name === "linear") d = Do(n, 1, s, l); else if (t.name === "cubic-bezier") { const p = t.controlPoints; d = new Yi(p[0], p[1], p[2], p[3]).solve(Do(n, 1, s, l)) } return d } static parse(t, n) { let [s, l, d, ...p] = t; if (!Array.isArray(l) || l.length === 0) return n.error("Expected an interpolation type expression.", 1); if (l[0] === "linear") l = { name: "linear" }; else if (l[0] === "exponential") { const b = l[1]; if (typeof b != "number") return n.error("Exponential interpolation requires a numeric base.", 1, 1); l = { name: "exponential", base: b } } else { if (l[0] !== "cubic-bezier") return n.error(`Unknown interpolation type ${String(l[0])}`, 1, 0); { const b = l.slice(1); if (b.length !== 4 || b.some(T => typeof T != "number" || T < 0 || T > 1)) return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1); l = { name: "cubic-bezier", controlPoints: b } } } if (t.length - 1 < 4) return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`); if ((t.length - 1) % 2 != 0) return n.error("Expected an even number of arguments."); if (d = n.parse(d, 2, Ee), !d) return null; const _ = []; let y = null; s === "interpolate-hcl" || s === "interpolate-lab" ? y = xt : n.expectedType && n.expectedType.kind !== "value" && (y = n.expectedType); for (let b = 0; b < p.length; b += 2) { const T = p[b], M = p[b + 1], k = b + 3, R = b + 4; if (typeof T != "number") return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', k); if (_.length && _[_.length - 1][0] >= T) return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', k); const L = n.parse(M, R, y); if (!L) return null; y = y || L.type, _.push([T, L]) } return fs(y, Ee) || fs(y, ft) || fs(y, xt) || fs(y, Mi) || fs(y, Mo) || fs(y, hr(Ee)) ? new Qi(y, s, l, d, _) : n.error(`Type ${Wt(y)} is not interpolatable.`) } evaluate(t) { const n = this.labels, s = this.outputs; if (n.length === 1) return s[0].evaluate(t); const l = this.input.evaluate(t); if (l <= n[0]) return s[0].evaluate(t); const d = n.length; if (l >= n[d - 1]) return s[d - 1].evaluate(t); const p = xs(n, l), _ = Qi.interpolationFactor(this.interpolation, l, n[p], n[p + 1]), y = s[p].evaluate(t), b = s[p + 1].evaluate(t); switch (this.operator) { case "interpolate": switch (this.type.kind) { case "number": return vr(y, b, _); case "color": return Lt.interpolate(y, b, _); case "padding": return Di.interpolate(y, b, _); case "variableAnchorOffsetCollection": return Ri.interpolate(y, b, _); case "array": return Lr(y, b, _); case "projectionDefinition": return dr.interpolate(y, b, _) }case "interpolate-hcl": return Lt.interpolate(y, b, _, "hcl"); case "interpolate-lab": return Lt.interpolate(y, b, _, "lab") } } eachChild(t) { t(this.input); for (const n of this.outputs) t(n) } outputDefined() { return this.outputs.every(t => t.outputDefined()) } } function Do(r, t, n, s) { const l = s - n, d = r - n; return l === 0 ? 0 : t === 1 ? d / l : (Math.pow(t, d) - 1) / (Math.pow(t, l) - 1) } const br = { color: Lt.interpolate, number: vr, padding: Di.interpolate, variableAnchorOffsetCollection: Ri.interpolate, array: Lr }; class yi { constructor(t, n) { this.type = t, this.args = n } static parse(t, n) { if (t.length < 2) return n.error("Expected at least one argument."); let s = null; const l = n.expectedType; l && l.kind !== "value" && (s = l); const d = []; for (const _ of t.slice(1)) { const y = n.parse(_, 1 + d.length, s, void 0, { typeAnnotation: "omit" }); if (!y) return null; s = s || y.type, d.push(y) } if (!s) throw new Error("No output type"); const p = l && d.some(_ => qs(l, _.type)); return new yi(p ? at : s, d) } evaluate(t) { let n, s = null, l = 0; for (const d of this.args) if (l++, s = d.evaluate(t), s && s instanceof nr && !s.available && (n || (n = s.name), s = null, l === this.args.length && (s = n)), s !== null) break; return s } eachChild(t) { this.args.forEach(t) } outputDefined() { return this.args.every(t => t.outputDefined()) } } function Qa(r, t) { return r === "==" || r === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value" } function Ro(r, t, n, s) { return s.compare(t, n) === 0 } function $n(r, t, n) { const s = r !== "==" && r !== "!="; return class g_ { constructor(d, p, _) { this.type = Qe, this.lhs = d, this.rhs = p, this.collator = _, this.hasUntypedArgument = d.type.kind === "value" || p.type.kind === "value" } static parse(d, p) { if (d.length !== 3 && d.length !== 4) return p.error("Expected two or three arguments."); const _ = d[0]; let y = p.parse(d[1], 1, at); if (!y) return null; if (!Qa(_, y.type)) return p.concat(1).error(`"${_}" comparisons are not supported for type '${Wt(y.type)}'.`); let b = p.parse(d[2], 2, at); if (!b) return null; if (!Qa(_, b.type)) return p.concat(2).error(`"${_}" comparisons are not supported for type '${Wt(b.type)}'.`); if (y.type.kind !== b.type.kind && y.type.kind !== "value" && b.type.kind !== "value") return p.error(`Cannot compare types '${Wt(y.type)}' and '${Wt(b.type)}'.`); s && (y.type.kind === "value" && b.type.kind !== "value" ? y = new Or(b.type, [y]) : y.type.kind !== "value" && b.type.kind === "value" && (b = new Or(y.type, [b]))); let T = null; if (d.length === 4) { if (y.type.kind !== "string" && b.type.kind !== "string" && y.type.kind !== "value" && b.type.kind !== "value") return p.error("Cannot use collator to compare non-string types."); if (T = p.parse(d[3], 3, Zn), !T) return null } return new g_(y, b, T) } evaluate(d) { const p = this.lhs.evaluate(d), _ = this.rhs.evaluate(d); if (s && this.hasUntypedArgument) { const y = Ti(p), b = Ti(_); if (y.kind !== b.kind || y.kind !== "string" && y.kind !== "number") throw new hi(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${y.kind}, ${b.kind}) instead.`) } if (this.collator && !s && this.hasUntypedArgument) { const y = Ti(p), b = Ti(_); if (y.kind !== "string" || b.kind !== "string") return t(d, p, _) } return this.collator ? n(d, p, _, this.collator.evaluate(d)) : t(d, p, _) } eachChild(d) { d(this.lhs), d(this.rhs), this.collator && d(this.collator) } outputDefined() { return !0 } } } const ch = $n("==", function (r, t, n) { return t === n }, Ro), Lo = $n("!=", function (r, t, n) { return t !== n }, function (r, t, n, s) { return !Ro(0, t, n, s) }), el = $n("<", function (r, t, n) { return t < n }, function (r, t, n, s) { return s.compare(t, n) < 0 }), uh = $n(">", function (r, t, n) { return t > n }, function (r, t, n, s) { return s.compare(t, n) > 0 }), Fo = $n("<=", function (r, t, n) { return t <= n }, function (r, t, n, s) { return s.compare(t, n) <= 0 }), Bo = $n(">=", function (r, t, n) { return t >= n }, function (r, t, n, s) { return s.compare(t, n) >= 0 }); class pr { constructor(t, n, s) { this.type = Zn, this.locale = s, this.caseSensitive = t, this.diacriticSensitive = n } static parse(t, n) { if (t.length !== 2) return n.error("Expected one argument."); const s = t[1]; if (typeof s != "object" || Array.isArray(s)) return n.error("Collator options argument must be an object."); const l = n.parse(s["case-sensitive"] !== void 0 && s["case-sensitive"], 1, Qe); if (!l) return null; const d = n.parse(s["diacritic-sensitive"] !== void 0 && s["diacritic-sensitive"], 1, Qe); if (!d) return null; let p = null; return s.locale && (p = n.parse(s.locale, 1, et), !p) ? null : new pr(l, d, p) } evaluate(t) { return new Co(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null) } eachChild(t) { t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale) } outputDefined() { return !1 } } class Oo { constructor(t, n, s, l, d) { this.type = et, this.number = t, this.locale = n, this.currency = s, this.minFractionDigits = l, this.maxFractionDigits = d } static parse(t, n) { if (t.length !== 3) return n.error("Expected two arguments."); const s = n.parse(t[1], 1, Ee); if (!s) return null; const l = t[2]; if (typeof l != "object" || Array.isArray(l)) return n.error("NumberFormat options argument must be an object."); let d = null; if (l.locale && (d = n.parse(l.locale, 1, et), !d)) return null; let p = null; if (l.currency && (p = n.parse(l.currency, 1, et), !p)) return null; let _ = null; if (l["min-fraction-digits"] && (_ = n.parse(l["min-fraction-digits"], 1, Ee), !_)) return null; let y = null; return l["max-fraction-digits"] && (y = n.parse(l["max-fraction-digits"], 1, Ee), !y) ? null : new Oo(s, d, p, _, y) } evaluate(t) { return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t)) } eachChild(t) { t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits) } outputDefined() { return !1 } } class Gn { constructor(t) { this.type = wi, this.sections = t } static parse(t, n) { if (t.length < 2) return n.error("Expected at least one argument."); const s = t[1]; if (!Array.isArray(s) && typeof s == "object") return n.error("First argument must be an image or text section."); const l = []; let d = !1; for (let p = 1; p <= t.length - 1; ++p) { const _ = t[p]; if (d && typeof _ == "object" && !Array.isArray(_)) { d = !1; let y = null; if (_["font-scale"] && (y = n.parse(_["font-scale"], 1, Ee), !y)) return null; let b = null; if (_["text-font"] && (b = n.parse(_["text-font"], 1, hr(et)), !b)) return null; let T = null; if (_["text-color"] && (T = n.parse(_["text-color"], 1, xt), !T)) return null; let M = null; if (_["vertical-align"]) { if (typeof _["vertical-align"] == "string" && !Xa.includes(_["vertical-align"])) return n.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${_["vertical-align"]}' instead.`); if (M = n.parse(_["vertical-align"], 1, et), !M) return null } const k = l[l.length - 1]; k.scale = y, k.font = b, k.textColor = T, k.verticalAlign = M } else { const y = n.parse(t[p], 1, at); if (!y) return null; const b = y.type.kind; if (b !== "string" && b !== "value" && b !== "null" && b !== "resolvedImage") return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'."); d = !0, l.push({ content: y, scale: null, font: null, textColor: null, verticalAlign: null }) } } return new Gn(l) } evaluate(t) { return new Gi(this.sections.map(n => { const s = n.content.evaluate(t); return Ti(s) === Qt ? new Fr("", s, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null) : new Fr(Mn(s), null, n.scale ? n.scale.evaluate(t) : null, n.font ? n.font.evaluate(t).join(",") : null, n.textColor ? n.textColor.evaluate(t) : null, n.verticalAlign ? n.verticalAlign.evaluate(t) : null) })) } eachChild(t) { for (const n of this.sections) t(n.content), n.scale && t(n.scale), n.font && t(n.font), n.textColor && t(n.textColor), n.verticalAlign && t(n.verticalAlign) } outputDefined() { return !1 } } class tl { constructor(t) { this.type = Qt, this.input = t } static parse(t, n) { if (t.length !== 2) return n.error("Expected two arguments."); const s = n.parse(t[1], 1, et); return s ? new tl(s) : n.error("No image name provided.") } evaluate(t) { const n = this.input.evaluate(t), s = nr.fromString(n); return s && t.availableImages && (s.available = t.availableImages.indexOf(n) > -1), s } eachChild(t) { t(this.input) } outputDefined() { return !1 } } class Ys { constructor(t) { this.type = Ee, this.input = t } static parse(t, n) { if (t.length !== 2) return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`); const s = n.parse(t[1], 1); return s ? s.type.kind !== "array" && s.type.kind !== "string" && s.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${Wt(s.type)} instead.`) : new Ys(s) : null } evaluate(t) { const n = this.input.evaluate(t); if (typeof n == "string") return [...n].length; if (Array.isArray(n)) return n.length; throw new hi(`Expected value to be of type string or array, but found ${Wt(Ti(n))} instead.`) } eachChild(t) { t(this.input) } outputDefined() { return !1 } } const cn = 8192; function hh(r, t) { const n = (180 + r[0]) / 360, s = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r[1] * Math.PI / 360))) / 360, l = Math.pow(2, t.z); return [Math.round(n * l * cn), Math.round(s * l * cn)] } function il(r, t) { const n = Math.pow(2, t.z); return [(l = (r[0] / cn + t.x) / n, 360 * l - 180), (s = (r[1] / cn + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * s) * Math.PI / 180)) - 90)]; var s, l } function Qs(r, t) { r[0] = Math.min(r[0], t[0]), r[1] = Math.min(r[1], t[1]), r[2] = Math.max(r[2], t[0]), r[3] = Math.max(r[3], t[1]) } function In(r, t) { return !(r[0] <= t[0] || r[2] >= t[2] || r[1] <= t[1] || r[3] >= t[3]) } function dh(r, t, n) { const s = r[0] - t[0], l = r[1] - t[1], d = r[0] - n[0], p = r[1] - n[1]; return s * p - d * l == 0 && s * d <= 0 && l * p <= 0 } function eo(r, t, n, s) { return (l = [s[0] - n[0], s[1] - n[1]])[0] * (d = [t[0] - r[0], t[1] - r[1]])[1] - l[1] * d[0] != 0 && !(!Dc(r, t, n, s) || !Dc(n, s, r, t)); var l, d } function Ac(r, t, n) { for (const s of n) for (let l = 0; l < s.length - 1; ++l)if (eo(r, t, s[l], s[l + 1])) return !0; return !1 } function bs(r, t, n = !1) { let s = !1; for (const _ of t) for (let y = 0; y < _.length - 1; y++) { if (dh(r, _[y], _[y + 1])) return n; (d = _[y])[1] > (l = r)[1] != (p = _[y + 1])[1] > l[1] && l[0] < (p[0] - d[0]) * (l[1] - d[1]) / (p[1] - d[1]) + d[0] && (s = !s) } var l, d, p; return s } function zc(r, t) { for (const n of t) if (bs(r, n)) return !0; return !1 } function kc(r, t) { for (const n of r) if (!bs(n, t)) return !1; for (let n = 0; n < r.length - 1; ++n)if (Ac(r[n], r[n + 1], t)) return !1; return !0 } function ph(r, t) { for (const n of t) if (kc(r, n)) return !0; return !1 } function Dc(r, t, n, s) { const l = s[0] - n[0], d = s[1] - n[1], p = (r[0] - n[0]) * d - l * (r[1] - n[1]), _ = (t[0] - n[0]) * d - l * (t[1] - n[1]); return p > 0 && _ < 0 || p < 0 && _ > 0 } function rl(r, t, n) { const s = []; for (let l = 0; l < r.length; l++) { const d = []; for (let p = 0; p < r[l].length; p++) { const _ = hh(r[l][p], n); Qs(t, _), d.push(_) } s.push(d) } return s } function Rc(r, t, n) { const s = []; for (let l = 0; l < r.length; l++) { const d = rl(r[l], t, n); s.push(d) } return s } function nl(r, t, n, s) { if (r[0] < n[0] || r[0] > n[2]) { const l = .5 * s; let d = r[0] - n[0] > l ? -s : n[0] - r[0] > l ? s : 0; d === 0 && (d = r[0] - n[2] > l ? -s : n[2] - r[0] > l ? s : 0), r[0] += d } Qs(t, r) } function sl(r, t, n, s) { const l = Math.pow(2, s.z) * cn, d = [s.x * cn, s.y * cn], p = []; for (const _ of r) for (const y of _) { const b = [y.x + d[0], y.y + d[1]]; nl(b, t, n, l), p.push(b) } return p } function ol(r, t, n, s) { const l = Math.pow(2, s.z) * cn, d = [s.x * cn, s.y * cn], p = []; for (const y of r) { const b = []; for (const T of y) { const M = [T.x + d[0], T.y + d[1]]; Qs(t, M), b.push(M) } p.push(b) } if (t[2] - t[0] <= l / 2) { (_ = t)[0] = _[1] = 1 / 0, _[2] = _[3] = -1 / 0; for (const y of p) for (const b of y) nl(b, t, n, l) } var _; return p } class qn { constructor(t, n) { this.type = Qe, this.geojson = t, this.geometries = n } static parse(t, n) { if (t.length !== 2) return n.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`); if (Xr(t[1])) { const s = t[1]; if (s.type === "FeatureCollection") { const l = []; for (const d of s.features) { const { type: p, coordinates: _ } = d.geometry; p === "Polygon" && l.push(_), p === "MultiPolygon" && l.push(..._) } if (l.length) return new qn(s, { type: "MultiPolygon", coordinates: l }) } else if (s.type === "Feature") { const l = s.geometry.type; if (l === "Polygon" || l === "MultiPolygon") return new qn(s, s.geometry) } else if (s.type === "Polygon" || s.type === "MultiPolygon") return new qn(s, s) } return n.error("'within' expression requires valid geojson object that contains polygon geometry type.") } evaluate(t) { if (t.geometry() != null && t.canonicalID() != null) { if (t.geometryType() === "Point") return function (n, s) { const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = n.canonicalID(); if (s.type === "Polygon") { const _ = rl(s.coordinates, d, p), y = sl(n.geometry(), l, d, p); if (!In(l, d)) return !1; for (const b of y) if (!bs(b, _)) return !1 } if (s.type === "MultiPolygon") { const _ = Rc(s.coordinates, d, p), y = sl(n.geometry(), l, d, p); if (!In(l, d)) return !1; for (const b of y) if (!zc(b, _)) return !1 } return !0 }(t, this.geometries); if (t.geometryType() === "LineString") return function (n, s) { const l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = [1 / 0, 1 / 0, -1 / 0, -1 / 0], p = n.canonicalID(); if (s.type === "Polygon") { const _ = rl(s.coordinates, d, p), y = ol(n.geometry(), l, d, p); if (!In(l, d)) return !1; for (const b of y) if (!kc(b, _)) return !1 } if (s.type === "MultiPolygon") { const _ = Rc(s.coordinates, d, p), y = ol(n.geometry(), l, d, p); if (!In(l, d)) return !1; for (const b of y) if (!ph(b, _)) return !1 } return !0 }(t, this.geometries) } return !1 } eachChild() { } outputDefined() { return !0 } } let Lc = class { constructor(r = [], t = (n, s) => n < s ? -1 : n > s ? 1 : 0) { if (this.data = r, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--)this._down(n) } push(r) { this.data.push(r), this._up(this.length++) } pop() { if (this.length === 0) return; const r = this.data[0], t = this.data.pop(); return --this.length > 0 && (this.data[0] = t, this._down(0)), r } peek() { return this.data[0] } _up(r) { const { data: t, compare: n } = this, s = t[r]; for (; r > 0;) { const l = r - 1 >> 1, d = t[l]; if (n(s, d) >= 0) break; t[r] = d, r = l } t[r] = s } _down(r) { const { data: t, compare: n } = this, s = this.length >> 1, l = t[r]; for (; r < s;) { let d = 1 + (r << 1); const p = d + 1; if (p < this.length && n(t[p], t[d]) < 0 && (d = p), n(t[d], l) >= 0) break; t[r] = t[d], r = d } t[r] = l } }; function Fc(r, t, n = 0, s = r.length - 1, l = fh) { for (; s > n;) { if (s - n > 600) { const y = s - n + 1, b = t - n + 1, T = Math.log(y), M = .5 * Math.exp(2 * T / 3), k = .5 * Math.sqrt(T * M * (y - M) / y) * (b - y / 2 < 0 ? -1 : 1); Fc(r, t, Math.max(n, Math.floor(t - b * M / y + k)), Math.min(s, Math.floor(t + (y - b) * M / y + k)), l) } const d = r[t]; let p = n, _ = s; for (Hn(r, n, t), l(r[s], d) > 0 && Hn(r, n, s); p < _;) { for (Hn(r, p, _), p++, _--; l(r[p], d) < 0;)p++; for (; l(r[_], d) > 0;)_-- } l(r[n], d) === 0 ? Hn(r, n, _) : (_++, Hn(r, _, s)), _ <= t && (n = _ + 1), t <= _ && (s = _ - 1) } } function Hn(r, t, n) { const s = r[t]; r[t] = r[n], r[n] = s } function fh(r, t) { return r < t ? -1 : r > t ? 1 : 0 } function jo(r, t) { if (r.length <= 1) return [r]; const n = []; let s, l; for (const d of r) { const p = Bc(d); p !== 0 && (d.area = Math.abs(p), l === void 0 && (l = p < 0), l === p < 0 ? (s && n.push(s), s = [d]) : s.push(d)) } if (s && n.push(s), t > 1) for (let d = 0; d < n.length; d++)n[d].length <= t || (Fc(n[d], t, 1, n[d].length - 1, mh), n[d] = n[d].slice(0, t)); return n } function mh(r, t) { return t.area - r.area } function Bc(r) { let t = 0; for (let n, s, l = 0, d = r.length, p = d - 1; l < d; p = l++)n = r[l], s = r[p], t += (s.x - n.x) * (n.y + s.y); return t } const al = 1 / 298.257223563, Oc = al * (2 - al), jc = Math.PI / 180; class Vo { constructor(t) { const n = 6378.137 * jc * 1e3, s = Math.cos(t * jc), l = 1 / (1 - Oc * (1 - s * s)), d = Math.sqrt(l); this.kx = n * d * s, this.ky = n * d * l * (1 - Oc) } distance(t, n) { const s = this.wrap(t[0] - n[0]) * this.kx, l = (t[1] - n[1]) * this.ky; return Math.sqrt(s * s + l * l) } pointOnLine(t, n) { let s, l, d, p, _ = 1 / 0; for (let y = 0; y < t.length - 1; y++) { let b = t[y][0], T = t[y][1], M = this.wrap(t[y + 1][0] - b) * this.kx, k = (t[y + 1][1] - T) * this.ky, R = 0; M === 0 && k === 0 || (R = (this.wrap(n[0] - b) * this.kx * M + (n[1] - T) * this.ky * k) / (M * M + k * k), R > 1 ? (b = t[y + 1][0], T = t[y + 1][1]) : R > 0 && (b += M / this.kx * R, T += k / this.ky * R)), M = this.wrap(n[0] - b) * this.kx, k = (n[1] - T) * this.ky; const L = M * M + k * k; L < _ && (_ = L, s = b, l = T, d = y, p = R) } return { point: [s, l], index: d, t: Math.max(0, Math.min(1, p)) } } wrap(t) { for (; t < -180;)t += 360; for (; t > 180;)t -= 360; return t } } function ll(r, t) { return t[0] - r[0] } function No(r) { return r[1] - r[0] + 1 } function _n(r, t) { return r[1] >= r[0] && r[1] < t } function cl(r, t) { if (r[0] > r[1]) return [null, null]; const n = No(r); if (t) { if (n === 2) return [r, null]; const l = Math.floor(n / 2); return [[r[0], r[0] + l], [r[0] + l, r[1]]] } if (n === 1) return [r, null]; const s = Math.floor(n / 2) - 1; return [[r[0], r[0] + s], [r[0] + s + 1, r[1]]] } function Zo(r, t) { if (!_n(t, r.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0]; const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (let s = t[0]; s <= t[1]; ++s)Qs(n, r[s]); return n } function ul(r) { const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (const n of r) for (const s of n) Qs(t, s); return t } function Vc(r) { return r[0] !== -1 / 0 && r[1] !== -1 / 0 && r[2] !== 1 / 0 && r[3] !== 1 / 0 } function hl(r, t, n) { if (!Vc(r) || !Vc(t)) return NaN; let s = 0, l = 0; return r[2] < t[0] && (s = t[0] - r[2]), r[0] > t[2] && (s = r[0] - t[2]), r[1] > t[3] && (l = r[1] - t[3]), r[3] < t[1] && (l = t[1] - r[3]), n.distance([0, 0], [s, l]) } function Wn(r, t, n) { const s = n.pointOnLine(t, r); return n.distance(r, s.point) } function Bt(r, t, n, s, l) { const d = Math.min(Wn(r, [n, s], l), Wn(t, [n, s], l)), p = Math.min(Wn(n, [r, t], l), Wn(s, [r, t], l)); return Math.min(d, p) } function _h(r, t, n, s, l) { if (!_n(t, r.length) || !_n(s, n.length)) return 1 / 0; let d = 1 / 0; for (let p = t[0]; p < t[1]; ++p) { const _ = r[p], y = r[p + 1]; for (let b = s[0]; b < s[1]; ++b) { const T = n[b], M = n[b + 1]; if (eo(_, y, T, M)) return 0; d = Math.min(d, Bt(_, y, T, M, l)) } } return d } function gh(r, t, n, s, l) { if (!_n(t, r.length) || !_n(s, n.length)) return NaN; let d = 1 / 0; for (let p = t[0]; p <= t[1]; ++p)for (let _ = s[0]; _ <= s[1]; ++_)if (d = Math.min(d, l.distance(r[p], n[_])), d === 0) return d; return d } function yh(r, t, n) { if (bs(r, t, !0)) return 0; let s = 1 / 0; for (const l of t) { const d = l[0], p = l[l.length - 1]; if (d !== p && (s = Math.min(s, Wn(r, [p, d], n)), s === 0)) return s; const _ = n.pointOnLine(l, r); if (s = Math.min(s, n.distance(r, _.point)), s === 0) return s } return s } function xh(r, t, n, s) { if (!_n(t, r.length)) return NaN; for (let d = t[0]; d <= t[1]; ++d)if (bs(r[d], n, !0)) return 0; let l = 1 / 0; for (let d = t[0]; d < t[1]; ++d) { const p = r[d], _ = r[d + 1]; for (const y of n) for (let b = 0, T = y.length, M = T - 1; b < T; M = b++) { const k = y[M], R = y[b]; if (eo(p, _, k, R)) return 0; l = Math.min(l, Bt(p, _, k, R, s)) } } return l } function Nc(r, t) { for (const n of r) for (const s of n) if (bs(s, t, !0)) return !0; return !1 } function vh(r, t, n, s = 1 / 0) { const l = ul(r), d = ul(t); if (s !== 1 / 0 && hl(l, d, n) >= s) return s; if (In(l, d)) { if (Nc(r, t)) return 0 } else if (Nc(t, r)) return 0; let p = 1 / 0; for (const _ of r) for (let y = 0, b = _.length, T = b - 1; y < b; T = y++) { const M = _[T], k = _[y]; for (const R of t) for (let L = 0, O = R.length, U = O - 1; L < O; U = L++) { const W = R[U], se = R[L]; if (eo(M, k, W, se)) return 0; p = Math.min(p, Bt(M, k, W, se, n)) } } return p } function Zc(r, t, n, s, l, d) { if (!d) return; const p = hl(Zo(s, d), l, n); p < t && r.push([p, d, [0, 0]]) } function Uo(r, t, n, s, l, d, p) { if (!d || !p) return; const _ = hl(Zo(s, d), Zo(l, p), n); _ < t && r.push([_, d, p]) } function $o(r, t, n, s, l = 1 / 0) { let d = Math.min(s.distance(r[0], n[0][0]), l); if (d === 0) return d; const p = new Lc([[0, [0, r.length - 1], [0, 0]]], ll), _ = ul(n); for (; p.length > 0;) { const y = p.pop(); if (y[0] >= d) continue; const b = y[1], T = t ? 50 : 100; if (No(b) <= T) { if (!_n(b, r.length)) return NaN; if (t) { const M = xh(r, b, n, s); if (isNaN(M) || M === 0) return M; d = Math.min(d, M) } else for (let M = b[0]; M <= b[1]; ++M) { const k = yh(r[M], n, s); if (d = Math.min(d, k), d === 0) return 0 } } else { const M = cl(b, t); Zc(p, d, s, r, _, M[0]), Zc(p, d, s, r, _, M[1]) } } return d } function Go(r, t, n, s, l, d = 1 / 0) { let p = Math.min(d, l.distance(r[0], n[0])); if (p === 0) return p; const _ = new Lc([[0, [0, r.length - 1], [0, n.length - 1]]], ll); for (; _.length > 0;) { const y = _.pop(); if (y[0] >= p) continue; const b = y[1], T = y[2], M = t ? 50 : 100, k = s ? 50 : 100; if (No(b) <= M && No(T) <= k) { if (!_n(b, r.length) && _n(T, n.length)) return NaN; let R; if (t && s) R = _h(r, b, n, T, l), p = Math.min(p, R); else if (t && !s) { const L = r.slice(b[0], b[1] + 1); for (let O = T[0]; O <= T[1]; ++O)if (R = Wn(n[O], L, l), p = Math.min(p, R), p === 0) return p } else if (!t && s) { const L = n.slice(T[0], T[1] + 1); for (let O = b[0]; O <= b[1]; ++O)if (R = Wn(r[O], L, l), p = Math.min(p, R), p === 0) return p } else R = gh(r, b, n, T, l), p = Math.min(p, R) } else { const R = cl(b, t), L = cl(T, s); Uo(_, p, l, r, n, R[0], L[0]), Uo(_, p, l, r, n, R[0], L[1]), Uo(_, p, l, r, n, R[1], L[0]), Uo(_, p, l, r, n, R[1], L[1]) } } return p } function dl(r) { return r.type === "MultiPolygon" ? r.coordinates.map(t => ({ type: "Polygon", coordinates: t })) : r.type === "MultiLineString" ? r.coordinates.map(t => ({ type: "LineString", coordinates: t })) : r.type === "MultiPoint" ? r.coordinates.map(t => ({ type: "Point", coordinates: t })) : [r] } class Xn { constructor(t, n) { this.type = Ee, this.geojson = t, this.geometries = n } static parse(t, n) { if (t.length !== 2) return n.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`); if (Xr(t[1])) { const s = t[1]; if (s.type === "FeatureCollection") return new Xn(s, s.features.map(l => dl(l.geometry)).flat()); if (s.type === "Feature") return new Xn(s, dl(s.geometry)); if ("type" in s && "coordinates" in s) return new Xn(s, dl(s)) } return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.") } evaluate(t) { if (t.geometry() != null && t.canonicalID() != null) { if (t.geometryType() === "Point") return function (n, s) { const l = n.geometry(), d = l.flat().map(y => il([y.x, y.y], n.canonical)); if (l.length === 0) return NaN; const p = new Vo(d[0][1]); let _ = 1 / 0; for (const y of s) { switch (y.type) { case "Point": _ = Math.min(_, Go(d, !1, [y.coordinates], !1, p, _)); break; case "LineString": _ = Math.min(_, Go(d, !1, y.coordinates, !0, p, _)); break; case "Polygon": _ = Math.min(_, $o(d, !1, y.coordinates, p, _)) }if (_ === 0) return _ } return _ }(t, this.geometries); if (t.geometryType() === "LineString") return function (n, s) { const l = n.geometry(), d = l.flat().map(y => il([y.x, y.y], n.canonical)); if (l.length === 0) return NaN; const p = new Vo(d[0][1]); let _ = 1 / 0; for (const y of s) { switch (y.type) { case "Point": _ = Math.min(_, Go(d, !0, [y.coordinates], !1, p, _)); break; case "LineString": _ = Math.min(_, Go(d, !0, y.coordinates, !0, p, _)); break; case "Polygon": _ = Math.min(_, $o(d, !0, y.coordinates, p, _)) }if (_ === 0) return _ } return _ }(t, this.geometries); if (t.geometryType() === "Polygon") return function (n, s) { const l = n.geometry(); if (l.length === 0 || l[0].length === 0) return NaN; const d = jo(l, 0).map(y => y.map(b => b.map(T => il([T.x, T.y], n.canonical)))), p = new Vo(d[0][0][0][1]); let _ = 1 / 0; for (const y of s) for (const b of d) { switch (y.type) { case "Point": _ = Math.min(_, $o([y.coordinates], !1, b, p, _)); break; case "LineString": _ = Math.min(_, $o(y.coordinates, !0, b, p, _)); break; case "Polygon": _ = Math.min(_, vh(b, y.coordinates, p, _)) }if (_ === 0) return _ } return _ }(t, this.geometries) } return NaN } eachChild() { } outputDefined() { return !0 } } const ws = { "==": ch, "!=": Lo, ">": uh, "<": el, ">=": Bo, "<=": Fo, array: Or, at: zt, boolean: Or, case: zo, coalesce: yi, collator: pr, format: Gn, image: tl, in: Ws, "index-of": jr, interpolate: Qi, "interpolate-hcl": Qi, "interpolate-lab": Qi, length: Ys, let: yt, literal: Br, match: Xs, number: Or, "number-format": Oo, object: Or, slice: Ks, step: vs, string: Or, "to-boolean": Kr, "to-color": Kr, "to-number": Kr, "to-string": Kr, var: ys, within: qn, distance: Xn }; class Vr { constructor(t, n, s, l) { this.name = t, this.type = n, this._evaluate = s, this.args = l } evaluate(t) { return this._evaluate(t, this.args) } eachChild(t) { this.args.forEach(t) } outputDefined() { return !1 } static parse(t, n) { const s = t[0], l = Vr.definitions[s]; if (!l) return n.error(`Unknown expression "${s}". If you wanted a literal array, use ["literal", [...]].`, 0); const d = Array.isArray(l) ? l[0] : l.type, p = Array.isArray(l) ? [[l[1], l[2]]] : l.overloads, _ = p.filter(([b]) => !Array.isArray(b) || b.length === t.length - 1); let y = null; for (const [b, T] of _) { y = new Ct(n.registry, qo, n.path, null, n.scope); const M = []; let k = !1; for (let R = 1; R < t.length; R++) { const L = t[R], O = Array.isArray(b) ? b[R - 1] : b.type, U = y.parse(L, 1 + M.length, O); if (!U) { k = !0; break } M.push(U) } if (!k) if (Array.isArray(b) && b.length !== M.length) y.error(`Expected ${b.length} arguments, but found ${M.length} instead.`); else { for (let R = 0; R < M.length; R++) { const L = Array.isArray(b) ? b[R] : b.type, O = M[R]; y.concat(R + 1).checkSubtype(L, O.type) } if (y.errors.length === 0) return new Vr(s, d, T, M) } } if (_.length === 1) n.errors.push(...y.errors); else { const b = (_.length ? _ : p).map(([M]) => { return k = M, Array.isArray(k) ? `(${k.map(Wt).join(", ")})` : `(${Wt(k.type)}...)`; var k }).join(" | "), T = []; for (let M = 1; M < t.length; M++) { const k = n.parse(t[M], 1 + T.length); if (!k) return null; T.push(Wt(k.type)) } n.error(`Expected arguments of type ${b}, but found (${T.join(", ")}) instead.`) } return null } static register(t, n) { Vr.definitions = n; for (const s in n) t[s] = Vr } } function Uc(r, [t, n, s, l]) { t = t.evaluate(r), n = n.evaluate(r), s = s.evaluate(r); const d = l ? l.evaluate(r) : 1, p = Eo(t, n, s, d); if (p) throw new hi(p); return new Lt(t / 255, n / 255, s / 255, d, !1) } function $c(r, t) { return r in t } function pl(r, t) { const n = t[r]; return n === void 0 ? null : n } function Kn(r) { return { type: r } } function qo(r) { if (r instanceof ys) return qo(r.boundExpression); if (r instanceof Vr && r.name === "error" || r instanceof pr || r instanceof qn || r instanceof Xn) return !1; const t = r instanceof Kr || r instanceof Or; let n = !0; return r.eachChild(s => { n = t ? n && qo(s) : n && s instanceof Br }), !!n && Ho(r) && Wo(r, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]) } function Ho(r) { if (r instanceof Vr && (r.name === "get" && r.args.length === 1 || r.name === "feature-state" || r.name === "has" && r.args.length === 1 || r.name === "properties" || r.name === "geometry-type" || r.name === "id" || /^filter-/.test(r.name)) || r instanceof qn || r instanceof Xn) return !1; let t = !0; return r.eachChild(n => { t && !Ho(n) && (t = !1) }), t } function to(r) { if (r instanceof Vr && r.name === "feature-state") return !1; let t = !0; return r.eachChild(n => { t && !to(n) && (t = !1) }), t } function Wo(r, t) { if (r instanceof Vr && t.indexOf(r.name) >= 0) return !1; let n = !0; return r.eachChild(s => { n && !Wo(s, t) && (n = !1) }), n } function Gc(r) { return { result: "success", value: r } } function Ts(r) { return { result: "error", value: r } } function Ps(r) { return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven" } function qc(r) { return !!r.expression && r.expression.parameters.indexOf("zoom") > -1 } function fl(r) { return !!r.expression && r.expression.interpolated } function Ft(r) { return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r } function Xo(r) { return typeof r == "object" && r !== null && !Array.isArray(r) } function bh(r) { return r } function Hc(r, t) { const n = t.type === "color", s = r.stops && typeof r.stops[0][0] == "object", l = s || !(s || r.property !== void 0), d = r.type || (fl(t) ? "exponential" : "interval"); if (n || t.type === "padding") { const T = n ? Lt.parse : Di.parse; (r = He({}, r)).stops && (r.stops = r.stops.map(M => [M[0], T(M[1])])), r.default = T(r.default ? r.default : t.default) } if (r.colorSpace && (p = r.colorSpace) !== "rgb" && p !== "hcl" && p !== "lab") throw new Error(`Unknown color space: "${r.colorSpace}"`); var p; let _, y, b; if (d === "exponential") _ = Wc; else if (d === "interval") _ = Th; else if (d === "categorical") { _ = wh, y = Object.create(null); for (const T of r.stops) y[T[0]] = T[1]; b = typeof r.stops[0][0] } else { if (d !== "identity") throw new Error(`Unknown function type "${d}"`); _ = Xc } if (s) { const T = {}, M = []; for (let L = 0; L < r.stops.length; L++) { const O = r.stops[L], U = O[0].zoom; T[U] === void 0 && (T[U] = { zoom: U, type: r.type, property: r.property, default: r.default, stops: [] }, M.push(U)), T[U].stops.push([O[0].value, O[1]]) } const k = []; for (const L of M) k.push([T[L].zoom, Hc(T[L], t)]); const R = { name: "linear" }; return { kind: "composite", interpolationType: R, interpolationFactor: Qi.interpolationFactor.bind(void 0, R), zoomStops: k.map(L => L[0]), evaluate: ({ zoom: L }, O) => Wc({ stops: k, base: r.base }, t, L).evaluate(L, O) } } if (l) { const T = d === "exponential" ? { name: "exponential", base: r.base !== void 0 ? r.base : 1 } : null; return { kind: "camera", interpolationType: T, interpolationFactor: Qi.interpolationFactor.bind(void 0, T), zoomStops: r.stops.map(M => M[0]), evaluate: ({ zoom: M }) => _(r, t, M, y, b) } } return { kind: "source", evaluate(T, M) { const k = M && M.properties ? M.properties[r.property] : void 0; return k === void 0 ? Jn(r.default, t.default) : _(r, t, k, y, b) } } } function Jn(r, t, n) { return r !== void 0 ? r : t !== void 0 ? t : n !== void 0 ? n : void 0 } function wh(r, t, n, s, l) { return Jn(typeof n === l ? s[n] : void 0, r.default, t.default) } function Th(r, t, n) { if (Ft(n) !== "number") return Jn(r.default, t.default); const s = r.stops.length; if (s === 1 || n <= r.stops[0][0]) return r.stops[0][1]; if (n >= r.stops[s - 1][0]) return r.stops[s - 1][1]; const l = xs(r.stops.map(d => d[0]), n); return r.stops[l][1] } function Wc(r, t, n) { const s = r.base !== void 0 ? r.base : 1; if (Ft(n) !== "number") return Jn(r.default, t.default); const l = r.stops.length; if (l === 1 || n <= r.stops[0][0]) return r.stops[0][1]; if (n >= r.stops[l - 1][0]) return r.stops[l - 1][1]; const d = xs(r.stops.map(T => T[0]), n), p = function (T, M, k, R) { const L = R - k, O = T - k; return L === 0 ? 0 : M === 1 ? O / L : (Math.pow(M, O) - 1) / (Math.pow(M, L) - 1) }(n, s, r.stops[d][0], r.stops[d + 1][0]), _ = r.stops[d][1], y = r.stops[d + 1][1], b = br[t.type] || bh; return typeof _.evaluate == "function" ? { evaluate(...T) { const M = _.evaluate.apply(void 0, T), k = y.evaluate.apply(void 0, T); if (M !== void 0 && k !== void 0) return b(M, k, p, r.colorSpace) } } : b(_, y, p, r.colorSpace) } function Xc(r, t, n) { switch (t.type) { case "color": n = Lt.parse(n); break; case "formatted": n = Gi.fromString(n.toString()); break; case "resolvedImage": n = nr.fromString(n.toString()); break; case "padding": n = Di.parse(n); break; default: Ft(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0) }return Jn(n, r.default, t.default) } Vr.register(ws, { error: [{ kind: "error" }, [et], (r, [t]) => { throw new hi(t.evaluate(r)) }], typeof: [et, [at], (r, [t]) => Wt(Ti(t.evaluate(r)))], "to-rgba": [hr(Ee, 4), [xt], (r, [t]) => { const [n, s, l, d] = t.evaluate(r).rgb; return [255 * n, 255 * s, 255 * l, d] }], rgb: [xt, [Ee, Ee, Ee], Uc], rgba: [xt, [Ee, Ee, Ee, Ee], Uc], has: { type: Qe, overloads: [[[et], (r, [t]) => $c(t.evaluate(r), r.properties())], [[et, bt], (r, [t, n]) => $c(t.evaluate(r), n.evaluate(r))]] }, get: { type: at, overloads: [[[et], (r, [t]) => pl(t.evaluate(r), r.properties())], [[et, bt], (r, [t, n]) => pl(t.evaluate(r), n.evaluate(r))]] }, "feature-state": [at, [et], (r, [t]) => pl(t.evaluate(r), r.featureState || {})], properties: [bt, [], r => r.properties()], "geometry-type": [et, [], r => r.geometryType()], id: [at, [], r => r.id()], zoom: [Ee, [], r => r.globals.zoom], "heatmap-density": [Ee, [], r => r.globals.heatmapDensity || 0], "line-progress": [Ee, [], r => r.globals.lineProgress || 0], accumulated: [at, [], r => r.globals.accumulated === void 0 ? null : r.globals.accumulated], "+": [Ee, Kn(Ee), (r, t) => { let n = 0; for (const s of t) n += s.evaluate(r); return n }], "*": [Ee, Kn(Ee), (r, t) => { let n = 1; for (const s of t) n *= s.evaluate(r); return n }], "-": { type: Ee, overloads: [[[Ee, Ee], (r, [t, n]) => t.evaluate(r) - n.evaluate(r)], [[Ee], (r, [t]) => -t.evaluate(r)]] }, "/": [Ee, [Ee, Ee], (r, [t, n]) => t.evaluate(r) / n.evaluate(r)], "%": [Ee, [Ee, Ee], (r, [t, n]) => t.evaluate(r) % n.evaluate(r)], ln2: [Ee, [], () => Math.LN2], pi: [Ee, [], () => Math.PI], e: [Ee, [], () => Math.E], "^": [Ee, [Ee, Ee], (r, [t, n]) => Math.pow(t.evaluate(r), n.evaluate(r))], sqrt: [Ee, [Ee], (r, [t]) => Math.sqrt(t.evaluate(r))], log10: [Ee, [Ee], (r, [t]) => Math.log(t.evaluate(r)) / Math.LN10], ln: [Ee, [Ee], (r, [t]) => Math.log(t.evaluate(r))], log2: [Ee, [Ee], (r, [t]) => Math.log(t.evaluate(r)) / Math.LN2], sin: [Ee, [Ee], (r, [t]) => Math.sin(t.evaluate(r))], cos: [Ee, [Ee], (r, [t]) => Math.cos(t.evaluate(r))], tan: [Ee, [Ee], (r, [t]) => Math.tan(t.evaluate(r))], asin: [Ee, [Ee], (r, [t]) => Math.asin(t.evaluate(r))], acos: [Ee, [Ee], (r, [t]) => Math.acos(t.evaluate(r))], atan: [Ee, [Ee], (r, [t]) => Math.atan(t.evaluate(r))], min: [Ee, Kn(Ee), (r, t) => Math.min(...t.map(n => n.evaluate(r)))], max: [Ee, Kn(Ee), (r, t) => Math.max(...t.map(n => n.evaluate(r)))], abs: [Ee, [Ee], (r, [t]) => Math.abs(t.evaluate(r))], round: [Ee, [Ee], (r, [t]) => { const n = t.evaluate(r); return n < 0 ? -Math.round(-n) : Math.round(n) }], floor: [Ee, [Ee], (r, [t]) => Math.floor(t.evaluate(r))], ceil: [Ee, [Ee], (r, [t]) => Math.ceil(t.evaluate(r))], "filter-==": [Qe, [et, at], (r, [t, n]) => r.properties()[t.value] === n.value], "filter-id-==": [Qe, [at], (r, [t]) => r.id() === t.value], "filter-type-==": [Qe, [et], (r, [t]) => r.geometryType() === t.value], "filter-<": [Qe, [et, at], (r, [t, n]) => { const s = r.properties()[t.value], l = n.value; return typeof s == typeof l && s < l }], "filter-id-<": [Qe, [at], (r, [t]) => { const n = r.id(), s = t.value; return typeof n == typeof s && n < s }], "filter->": [Qe, [et, at], (r, [t, n]) => { const s = r.properties()[t.value], l = n.value; return typeof s == typeof l && s > l }], "filter-id->": [Qe, [at], (r, [t]) => { const n = r.id(), s = t.value; return typeof n == typeof s && n > s }], "filter-<=": [Qe, [et, at], (r, [t, n]) => { const s = r.properties()[t.value], l = n.value; return typeof s == typeof l && s <= l }], "filter-id-<=": [Qe, [at], (r, [t]) => { const n = r.id(), s = t.value; return typeof n == typeof s && n <= s }], "filter->=": [Qe, [et, at], (r, [t, n]) => { const s = r.properties()[t.value], l = n.value; return typeof s == typeof l && s >= l }], "filter-id->=": [Qe, [at], (r, [t]) => { const n = r.id(), s = t.value; return typeof n == typeof s && n >= s }], "filter-has": [Qe, [at], (r, [t]) => t.value in r.properties()], "filter-has-id": [Qe, [], r => r.id() !== null && r.id() !== void 0], "filter-type-in": [Qe, [hr(et)], (r, [t]) => t.value.indexOf(r.geometryType()) >= 0], "filter-id-in": [Qe, [hr(at)], (r, [t]) => t.value.indexOf(r.id()) >= 0], "filter-in-small": [Qe, [et, hr(at)], (r, [t, n]) => n.value.indexOf(r.properties()[t.value]) >= 0], "filter-in-large": [Qe, [et, hr(at)], (r, [t, n]) => function (s, l, d, p) { for (; d <= p;) { const _ = d + p >> 1; if (l[_] === s) return !0; l[_] > s ? p = _ - 1 : d = _ + 1 } return !1 }(r.properties()[t.value], n.value, 0, n.value.length - 1)], all: { type: Qe, overloads: [[[Qe, Qe], (r, [t, n]) => t.evaluate(r) && n.evaluate(r)], [Kn(Qe), (r, t) => { for (const n of t) if (!n.evaluate(r)) return !1; return !0 }]] }, any: { type: Qe, overloads: [[[Qe, Qe], (r, [t, n]) => t.evaluate(r) || n.evaluate(r)], [Kn(Qe), (r, t) => { for (const n of t) if (n.evaluate(r)) return !0; return !1 }]] }, "!": [Qe, [Qe], (r, [t]) => !t.evaluate(r)], "is-supported-script": [Qe, [et], (r, [t]) => { const n = r.globals && r.globals.isSupportedScript; return !n || n(t.evaluate(r)) }], upcase: [et, [et], (r, [t]) => t.evaluate(r).toUpperCase()], downcase: [et, [et], (r, [t]) => t.evaluate(r).toLowerCase()], concat: [et, Kn(at), (r, t) => t.map(n => Mn(n.evaluate(r))).join("")], "resolved-locale": [et, [Zn], (r, [t]) => t.evaluate(r).resolvedLocale()] }); class ml { constructor(t, n) { var s; this.expression = t, this._warningHistory = {}, this._evaluator = new Ao, this._defaultValue = n ? (s = n).type === "color" && Xo(s.default) ? new Lt(0, 0, 0, 0) : s.type === "color" ? Lt.parse(s.default) || null : s.type === "padding" ? Di.parse(s.default) || null : s.type === "variableAnchorOffsetCollection" ? Ri.parse(s.default) || null : s.type === "projectionDefinition" ? dr.parse(s.default) || null : s.default === void 0 ? null : s.default : null, this._enumValues = n && n.type === "enum" ? n.values : null } evaluateWithoutErrorHandling(t, n, s, l, d, p) { return this._evaluator.globals = t, this._evaluator.feature = n, this._evaluator.featureState = s, this._evaluator.canonical = l, this._evaluator.availableImages = d || null, this._evaluator.formattedSection = p, this.expression.evaluate(this._evaluator) } evaluate(t, n, s, l, d, p) { this._evaluator.globals = t, this._evaluator.feature = n || null, this._evaluator.featureState = s || null, this._evaluator.canonical = l, this._evaluator.availableImages = d || null, this._evaluator.formattedSection = p || null; try { const _ = this.expression.evaluate(this._evaluator); if (_ == null || typeof _ == "number" && _ != _) return this._defaultValue; if (this._enumValues && !(_ in this._enumValues)) throw new hi(`Expected value to be one of ${Object.keys(this._enumValues).map(y => JSON.stringify(y)).join(", ")}, but found ${JSON.stringify(_)} instead.`); return _ } catch (_) { return this._warningHistory[_.message] || (this._warningHistory[_.message] = !0, typeof console < "u" && console.warn(_.message)), this._defaultValue } } } function Ko(r) { return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in ws } function Yn(r, t) { const n = new Ct(ws, qo, [], t ? function (l) { const d = { color: xt, string: et, number: Ee, enum: et, boolean: Qe, formatted: wi, padding: Mi, projectionDefinition: ft, resolvedImage: Qt, variableAnchorOffsetCollection: Mo }; return l.type === "array" ? hr(d[l.value] || at, l.length) : d[l.type] }(t) : void 0), s = n.parse(r, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0); return s ? Gc(new ml(s, t)) : Ts(n.errors) } class Jo { constructor(t, n) { this.kind = t, this._styleExpression = n, this.isStateDependent = t !== "constant" && !to(n.expression) } evaluateWithoutErrorHandling(t, n, s, l, d, p) { return this._styleExpression.evaluateWithoutErrorHandling(t, n, s, l, d, p) } evaluate(t, n, s, l, d, p) { return this._styleExpression.evaluate(t, n, s, l, d, p) } } class _l { constructor(t, n, s, l) { this.kind = t, this.zoomStops = s, this._styleExpression = n, this.isStateDependent = t !== "camera" && !to(n.expression), this.interpolationType = l } evaluateWithoutErrorHandling(t, n, s, l, d, p) { return this._styleExpression.evaluateWithoutErrorHandling(t, n, s, l, d, p) } evaluate(t, n, s, l, d, p) { return this._styleExpression.evaluate(t, n, s, l, d, p) } interpolationFactor(t, n, s) { return this.interpolationType ? Qi.interpolationFactor(this.interpolationType, t, n, s) : 0 } } function Kc(r, t) { const n = Yn(r, t); if (n.result === "error") return n; const s = n.value.expression, l = Ho(s); if (!l && !Ps(t)) return Ts([new rt("", "data expressions not supported")]); const d = Wo(s, ["zoom"]); if (!d && !qc(t)) return Ts([new rt("", "zoom expressions not supported")]); const p = Qo(s); return p || d ? p instanceof rt ? Ts([p]) : p instanceof Qi && !fl(t) ? Ts([new rt("", '"interpolate" expressions cannot be used with this property')]) : Gc(p ? new _l(l ? "camera" : "composite", n.value, p.labels, p instanceof Qi ? p.interpolation : void 0) : new Jo(l ? "constant" : "source", n.value)) : Ts([new rt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]) } class Yo { constructor(t, n) { this._parameters = t, this._specification = n, He(this, Hc(this._parameters, this._specification)) } static deserialize(t) { return new Yo(t._parameters, t._specification) } static serialize(t) { return { _parameters: t._parameters, _specification: t._specification } } } function Qo(r) { let t = null; if (r instanceof yt) t = Qo(r.result); else if (r instanceof yi) { for (const n of r.args) if (t = Qo(n), t) break } else (r instanceof vs || r instanceof Qi) && r.input instanceof Vr && r.input.name === "zoom" && (t = r); return t instanceof rt || r.eachChild(n => { const s = Qo(n); s instanceof rt ? t = s : !t && s ? t = new rt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && s && t !== s && (t = new rt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.')) }), t } function gl(r) { if (r === !0 || r === !1) return !0; if (!Array.isArray(r) || r.length === 0) return !1; switch (r[0]) { case "has": return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type"; case "in": return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2])); case "!in": case "!has": case "none": return !1; case "==": case "!=": case ">": case ">=": case "<": case "<=": return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]); case "any": case "all": for (const t of r.slice(1)) if (!gl(t) && typeof t != "boolean") return !1; return !0; default: return !0 } } const Jc = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }; function ea(r) { if (r == null) return { filter: () => !0, needGeometry: !1 }; gl(r) || (r = io(r)); const t = Yn(r, Jc); if (t.result === "error") throw new Error(t.value.map(n => `${n.key}: ${n.message}`).join(", ")); return { filter: (n, s, l) => t.value.evaluate(n, s, {}, l), needGeometry: Yc(r) } } function Ph(r, t) { return r < t ? -1 : r > t ? 1 : 0 } function Yc(r) { if (!Array.isArray(r)) return !1; if (r[0] === "within" || r[0] === "distance") return !0; for (let t = 1; t < r.length; t++)if (Yc(r[t])) return !0; return !1 } function io(r) { if (!r) return !0; const t = r[0]; return r.length <= 1 ? t !== "any" : t === "==" ? ta(r[1], r[2], "==") : t === "!=" ? Ss(ta(r[1], r[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? ta(r[1], r[2], t) : t === "any" ? (n = r.slice(1), ["any"].concat(n.map(io))) : t === "all" ? ["all"].concat(r.slice(1).map(io)) : t === "none" ? ["all"].concat(r.slice(1).map(io).map(Ss)) : t === "in" ? yl(r[1], r.slice(2)) : t === "!in" ? Ss(yl(r[1], r.slice(2))) : t === "has" ? xl(r[1]) : t !== "!has" || Ss(xl(r[1])); var n } function ta(r, t, n) { switch (r) { case "$type": return [`filter-type-${n}`, t]; case "$id": return [`filter-id-${n}`, t]; default: return [`filter-${n}`, r, t] } } function yl(r, t) { if (t.length === 0) return !1; switch (r) { case "$type": return ["filter-type-in", ["literal", t]]; case "$id": return ["filter-id-in", ["literal", t]]; default: return t.length > 200 && !t.some(n => typeof n != typeof t[0]) ? ["filter-in-large", r, ["literal", t.sort(Ph)]] : ["filter-in-small", r, ["literal", t]] } } function xl(r) { switch (r) { case "$type": return !0; case "$id": return ["filter-has-id"]; default: return ["filter-has", r] } } function Ss(r) { return ["!", r] } function ro(r) { const t = typeof r; if (t === "number" || t === "boolean" || t === "string" || r == null) return JSON.stringify(r); if (Array.isArray(r)) { let l = "["; for (const d of r) l += `${ro(d)},`; return `${l}]` } const n = Object.keys(r).sort(); let s = "{"; for (let l = 0; l < n.length; l++)s += `${JSON.stringify(n[l])}:${ro(r[n[l]])},`; return `${s}}` } function vl(r) { let t = ""; for (const n of V) t += `/${ro(r[n])}`; return t } function no(r) { const t = r.value; return t ? [new fe(r.key, t, "constants have been deprecated as of v8")] : [] } function _i(r) { return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r } function Qn(r) { if (Array.isArray(r)) return r.map(Qn); if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) { const t = {}; for (const n in r) t[n] = Qn(r[n]); return t } return _i(r) } function Nr(r) { const t = r.key, n = r.value, s = r.valueSpec || {}, l = r.objectElementValidators || {}, d = r.style, p = r.styleSpec, _ = r.validateSpec; let y = []; const b = Ft(n); if (b !== "object") return [new fe(t, n, `object expected, ${b} found`)]; for (const T in n) { const M = T.split(".")[0], k = s[M] || s["*"]; let R; if (l[M]) R = l[M]; else if (s[M]) R = _; else if (l["*"]) R = l["*"]; else { if (!s["*"]) { y.push(new fe(t, n[T], `unknown property "${T}"`)); continue } R = _ } y = y.concat(R({ key: (t && `${t}.`) + T, value: n[T], valueSpec: k, style: d, styleSpec: p, object: n, objectKey: T, validateSpec: _ }, n)) } for (const T in s) l[T] || s[T].required && s[T].default === void 0 && n[T] === void 0 && y.push(new fe(t, n, `missing required property "${T}"`)); return y } function bl(r) { const t = r.value, n = r.valueSpec, s = r.style, l = r.styleSpec, d = r.key, p = r.arrayElementValidator || r.validateSpec; if (Ft(t) !== "array") return [new fe(d, t, `array expected, ${Ft(t)} found`)]; if (n.length && t.length !== n.length) return [new fe(d, t, `array length ${n.length} expected, length ${t.length} found`)]; if (n["min-length"] && t.length < n["min-length"]) return [new fe(d, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)]; let _ = { type: n.value, values: n.values }; l.$version < 7 && (_.function = n.function), Ft(n.value) === "object" && (_ = n.value); let y = []; for (let b = 0; b < t.length; b++)y = y.concat(p({ array: t, arrayIndex: b, value: t[b], valueSpec: _, validateSpec: r.validateSpec, style: s, styleSpec: l, key: `${d}[${b}]` })); return y } function wl(r) { const t = r.key, n = r.value, s = r.valueSpec; let l = Ft(n); return l === "number" && n != n && (l = "NaN"), l !== "number" ? [new fe(t, n, `number expected, ${l} found`)] : "minimum" in s && n < s.minimum ? [new fe(t, n, `${n} is less than the minimum value ${s.minimum}`)] : "maximum" in s && n > s.maximum ? [new fe(t, n, `${n} is greater than the maximum value ${s.maximum}`)] : [] } function Qc(r) { const t = r.valueSpec, n = _i(r.value.type); let s, l, d, p = {}; const _ = n !== "categorical" && r.value.property === void 0, y = !_, b = Ft(r.value.stops) === "array" && Ft(r.value.stops[0]) === "array" && Ft(r.value.stops[0][0]) === "object", T = Nr({ key: r.key, value: r.value, valueSpec: r.styleSpec.function, validateSpec: r.validateSpec, style: r.style, styleSpec: r.styleSpec, objectElementValidators: { stops: function (R) { if (n === "identity") return [new fe(R.key, R.value, 'identity function may not have a "stops" property')]; let L = []; const O = R.value; return L = L.concat(bl({ key: R.key, value: O, valueSpec: R.valueSpec, validateSpec: R.validateSpec, style: R.style, styleSpec: R.styleSpec, arrayElementValidator: M })), Ft(O) === "array" && O.length === 0 && L.push(new fe(R.key, O, "array must have at least one stop")), L }, default: function (R) { return R.validateSpec({ key: R.key, value: R.value, valueSpec: t, validateSpec: R.validateSpec, style: R.style, styleSpec: R.styleSpec }) } } }); return n === "identity" && _ && T.push(new fe(r.key, r.value, 'missing required property "property"')), n === "identity" || r.value.stops || T.push(new fe(r.key, r.value, 'missing required property "stops"')), n === "exponential" && r.valueSpec.expression && !fl(r.valueSpec) && T.push(new fe(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (y && !Ps(r.valueSpec) ? T.push(new fe(r.key, r.value, "property functions not supported")) : _ && !qc(r.valueSpec) && T.push(new fe(r.key, r.value, "zoom functions not supported"))), n !== "categorical" && !b || r.value.property !== void 0 || T.push(new fe(r.key, r.value, '"property" property is required')), T; function M(R) { let L = []; const O = R.value, U = R.key; if (Ft(O) !== "array") return [new fe(U, O, `array expected, ${Ft(O)} found`)]; if (O.length !== 2) return [new fe(U, O, `array length 2 expected, length ${O.length} found`)]; if (b) { if (Ft(O[0]) !== "object") return [new fe(U, O, `object expected, ${Ft(O[0])} found`)]; if (O[0].zoom === void 0) return [new fe(U, O, "object stop key must have zoom")]; if (O[0].value === void 0) return [new fe(U, O, "object stop key must have value")]; if (d && d > _i(O[0].zoom)) return [new fe(U, O[0].zoom, "stop zoom values must appear in ascending order")]; _i(O[0].zoom) !== d && (d = _i(O[0].zoom), l = void 0, p = {}), L = L.concat(Nr({ key: `${U}[0]`, value: O[0], valueSpec: { zoom: {} }, validateSpec: R.validateSpec, style: R.style, styleSpec: R.styleSpec, objectElementValidators: { zoom: wl, value: k } })) } else L = L.concat(k({ key: `${U}[0]`, value: O[0], validateSpec: R.validateSpec, style: R.style, styleSpec: R.styleSpec }, O)); return Ko(Qn(O[1])) ? L.concat([new fe(`${U}[1]`, O[1], "expressions are not allowed in function stops.")]) : L.concat(R.validateSpec({ key: `${U}[1]`, value: O[1], valueSpec: t, validateSpec: R.validateSpec, style: R.style, styleSpec: R.styleSpec })) } function k(R, L) { const O = Ft(R.value), U = _i(R.value), W = R.value !== null ? R.value : L; if (s) { if (O !== s) return [new fe(R.key, W, `${O} stop domain type must match previous stop domain type ${s}`)] } else s = O; if (O !== "number" && O !== "string" && O !== "boolean") return [new fe(R.key, W, "stop domain value must be a number, string, or boolean")]; if (O !== "number" && n !== "categorical") { let se = `number expected, ${O} found`; return Ps(t) && n === void 0 && (se += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new fe(R.key, W, se)] } return n !== "categorical" || O !== "number" || isFinite(U) && Math.floor(U) === U ? n !== "categorical" && O === "number" && l !== void 0 && U < l ? [new fe(R.key, W, "stop domain values must appear in ascending order")] : (l = U, n === "categorical" && U in p ? [new fe(R.key, W, "stop domain values must be unique")] : (p[U] = !0, [])) : [new fe(R.key, W, `integer expected, found ${U}`)] } } function es(r) { const t = (r.expressionContext === "property" ? Kc : Yn)(Qn(r.value), r.valueSpec); if (t.result === "error") return t.value.map(s => new fe(`${r.key}${s.key}`, r.value, s.message)); const n = t.value.expression || t.value._styleExpression.expression; if (r.expressionContext === "property" && r.propertyKey === "text-font" && !n.outputDefined()) return [new fe(r.key, r.value, `Invalid data expression for "${r.propertyKey}". Output values must be contained as literals within the expression.`)]; if (r.expressionContext === "property" && r.propertyType === "layout" && !to(n)) return [new fe(r.key, r.value, '"feature-state" data expressions are not supported with layout properties.')]; if (r.expressionContext === "filter" && !to(n)) return [new fe(r.key, r.value, '"feature-state" data expressions are not supported with filters.')]; if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) { if (!Wo(n, ["zoom", "feature-state"])) return [new fe(r.key, r.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')]; if (r.expressionContext === "cluster-initial" && !Ho(n)) return [new fe(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")] } return [] } function Ms(r) { const t = r.key, n = r.value, s = r.valueSpec, l = []; return Array.isArray(s.values) ? s.values.indexOf(_i(n)) === -1 && l.push(new fe(t, n, `expected one of [${s.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(s.values).indexOf(_i(n)) === -1 && l.push(new fe(t, n, `expected one of [${Object.keys(s.values).join(", ")}], ${JSON.stringify(n)} found`)), l } function Is(r) { return gl(Qn(r.value)) ? es(He({}, r, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : eu(r) } function eu(r) { const t = r.value, n = r.key; if (Ft(t) !== "array") return [new fe(n, t, `array expected, ${Ft(t)} found`)]; const s = r.styleSpec; let l, d = []; if (t.length < 1) return [new fe(n, t, "filter array must have at least 1 element")]; switch (d = d.concat(Ms({ key: `${n}[0]`, value: t[0], valueSpec: s.filter_operator, style: r.style, styleSpec: r.styleSpec })), _i(t[0])) { case "<": case "<=": case ">": case ">=": t.length >= 2 && _i(t[1]) === "$type" && d.push(new fe(n, t, `"$type" cannot be use with operator "${t[0]}"`)); case "==": case "!=": t.length !== 3 && d.push(new fe(n, t, `filter array for operator "${t[0]}" must have 3 elements`)); case "in": case "!in": t.length >= 2 && (l = Ft(t[1]), l !== "string" && d.push(new fe(`${n}[1]`, t[1], `string expected, ${l} found`))); for (let p = 2; p < t.length; p++)l = Ft(t[p]), _i(t[1]) === "$type" ? d = d.concat(Ms({ key: `${n}[${p}]`, value: t[p], valueSpec: s.geometry_type, style: r.style, styleSpec: r.styleSpec })) : l !== "string" && l !== "number" && l !== "boolean" && d.push(new fe(`${n}[${p}]`, t[p], `string, number, or boolean expected, ${l} found`)); break; case "any": case "all": case "none": for (let p = 1; p < t.length; p++)d = d.concat(eu({ key: `${n}[${p}]`, value: t[p], style: r.style, styleSpec: r.styleSpec })); break; case "has": case "!has": l = Ft(t[1]), t.length !== 2 ? d.push(new fe(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : l !== "string" && d.push(new fe(`${n}[1]`, t[1], `string expected, ${l} found`)) }return d } function Tl(r, t) {
          const n = r.key, s = r.validateSpec, l = r.style, d = r.styleSpec, p = r.value, _ = r.objectKey, y = d[`${t}_${r.layerType}`]; if (!y) return []; const b = _.match(/^(.*)-transition$/); if (t === "paint" && b && y[b[1]] && y[b[1]].transition) return s({ key: n, value: p, valueSpec: d.transition, style: l, styleSpec: d }); const T = r.valueSpec || y[_]; if (!T) return [new fe(n, p, `unknown property "${_}"`)]; let M; if (Ft(p) === "string" && Ps(T) && !T.tokens && (M = /^{([^}]+)}$/.exec(p))) return [new fe(n, p, `"${_}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(M[1])} }\`.`)]; const k = []; return r.layerType === "symbol" && (_ === "text-field" && l && !l.glyphs && k.push(new fe(n, p, 'use of "text-field" requires a style "glyphs" property')), _ === "text-font" && Xo(Qn(p)) && _i(p.type) === "identity" && k.push(new fe(n, p, '"text-font" does not support identity functions'))), k.concat(s({ key: r.key, value: p, valueSpec: T, style: l, styleSpec: d, expressionContext: "property", propertyType: t, propertyKey: _ }))
        } function Pl(r) { return Tl(r, "paint") } function tu(r) { return Tl(r, "layout") } function Sl(r) { let t = []; const n = r.value, s = r.key, l = r.style, d = r.styleSpec; n.type || n.ref || t.push(new fe(s, n, 'either "type" or "ref" is required')); let p = _i(n.type); const _ = _i(n.ref); if (n.id) { const y = _i(n.id); for (let b = 0; b < r.arrayIndex; b++) { const T = l.layers[b]; _i(T.id) === y && t.push(new fe(s, n.id, `duplicate layer id "${n.id}", previously used at line ${T.id.__line__}`)) } } if ("ref" in n) { let y;["type", "source", "source-layer", "filter", "layout"].forEach(b => { b in n && t.push(new fe(s, n[b], `"${b}" is prohibited for ref layers`)) }), l.layers.forEach(b => { _i(b.id) === _ && (y = b) }), y ? y.ref ? t.push(new fe(s, n.ref, "ref cannot reference another ref layer")) : p = _i(y.type) : t.push(new fe(s, n.ref, `ref layer "${_}" not found`)) } else if (p !== "background") if (n.source) { const y = l.sources && l.sources[n.source], b = y && _i(y.type); y ? b === "vector" && p === "raster" ? t.push(new fe(s, n.source, `layer "${n.id}" requires a raster source`)) : b !== "raster-dem" && p === "hillshade" ? t.push(new fe(s, n.source, `layer "${n.id}" requires a raster-dem source`)) : b === "raster" && p !== "raster" ? t.push(new fe(s, n.source, `layer "${n.id}" requires a vector source`)) : b !== "vector" || n["source-layer"] ? b === "raster-dem" && p !== "hillshade" ? t.push(new fe(s, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : p !== "line" || !n.paint || !n.paint["line-gradient"] || b === "geojson" && y.lineMetrics || t.push(new fe(s, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new fe(s, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new fe(s, n.source, `source "${n.source}" not found`)) } else t.push(new fe(s, n, 'missing required property "source"')); return t = t.concat(Nr({ key: s, value: n, valueSpec: d.layer, style: r.style, styleSpec: r.styleSpec, validateSpec: r.validateSpec, objectElementValidators: { "*": () => [], type: () => r.validateSpec({ key: `${s}.type`, value: n.type, valueSpec: d.layer.type, style: r.style, styleSpec: r.styleSpec, validateSpec: r.validateSpec, object: n, objectKey: "type" }), filter: Is, layout: y => Nr({ layer: n, key: y.key, value: y.value, style: y.style, styleSpec: y.styleSpec, validateSpec: y.validateSpec, objectElementValidators: { "*": b => tu(He({ layerType: p }, b)) } }), paint: y => Nr({ layer: n, key: y.key, value: y.value, style: y.style, styleSpec: y.styleSpec, validateSpec: y.validateSpec, objectElementValidators: { "*": b => Pl(He({ layerType: p }, b)) } }) } })), t } function Cn(r) { const t = r.value, n = r.key, s = Ft(t); return s !== "string" ? [new fe(n, t, `string expected, ${s} found`)] : [] } const Cs = { promoteId: function ({ key: r, value: t }) { if (Ft(t) === "string") return Cn({ key: r, value: t }); { const n = []; for (const s in t) n.push(...Cn({ key: `${r}.${s}`, value: t[s] })); return n } } }; function iu(r) { const t = r.value, n = r.key, s = r.styleSpec, l = r.style, d = r.validateSpec; if (!t.type) return [new fe(n, t, '"type" is required')]; const p = _i(t.type); let _; switch (p) { case "vector": case "raster": return _ = Nr({ key: n, value: t, valueSpec: s[`source_${p.replace("-", "_")}`], style: r.style, styleSpec: s, objectElementValidators: Cs, validateSpec: d }), _; case "raster-dem": return _ = function (y) { var b; const T = (b = y.sourceName) !== null && b !== void 0 ? b : "", M = y.value, k = y.styleSpec, R = k.source_raster_dem, L = y.style; let O = []; const U = Ft(M); if (M === void 0) return O; if (U !== "object") return O.push(new fe("source_raster_dem", M, `object expected, ${U} found`)), O; const W = _i(M.encoding) === "custom", se = ["redFactor", "greenFactor", "blueFactor", "baseShift"], J = y.value.encoding ? `"${y.value.encoding}"` : "Default"; for (const D in M) !W && se.includes(D) ? O.push(new fe(D, M[D], `In "${T}": "${D}" is only valid when "encoding" is set to "custom". ${J} encoding found`)) : R[D] ? O = O.concat(y.validateSpec({ key: D, value: M[D], valueSpec: R[D], validateSpec: y.validateSpec, style: L, styleSpec: k })) : O.push(new fe(D, M[D], `unknown property "${D}"`)); return O }({ sourceName: n, value: t, style: r.style, styleSpec: s, validateSpec: d }), _; case "geojson": if (_ = Nr({ key: n, value: t, valueSpec: s.source_geojson, style: l, styleSpec: s, validateSpec: d, objectElementValidators: Cs }), t.cluster) for (const y in t.clusterProperties) { const [b, T] = t.clusterProperties[y], M = typeof b == "string" ? [b, ["accumulated"], ["get", y]] : b; _.push(...es({ key: `${n}.${y}.map`, value: T, expressionContext: "cluster-map" })), _.push(...es({ key: `${n}.${y}.reduce`, value: M, expressionContext: "cluster-reduce" })) } return _; case "video": return Nr({ key: n, value: t, valueSpec: s.source_video, style: l, validateSpec: d, styleSpec: s }); case "image": return Nr({ key: n, value: t, valueSpec: s.source_image, style: l, validateSpec: d, styleSpec: s }); case "canvas": return [new fe(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")]; default: return Ms({ key: `${n}.type`, value: t.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } }) } } function ru(r) { const t = r.value, n = r.styleSpec, s = n.light, l = r.style; let d = []; const p = Ft(t); if (t === void 0) return d; if (p !== "object") return d = d.concat([new fe("light", t, `object expected, ${p} found`)]), d; for (const _ in t) { const y = _.match(/^(.*)-transition$/); d = d.concat(y && s[y[1]] && s[y[1]].transition ? r.validateSpec({ key: _, value: t[_], valueSpec: n.transition, validateSpec: r.validateSpec, style: l, styleSpec: n }) : s[_] ? r.validateSpec({ key: _, value: t[_], valueSpec: s[_], validateSpec: r.validateSpec, style: l, styleSpec: n }) : [new fe(_, t[_], `unknown property "${_}"`)]) } return d } function nu(r) { const t = r.value, n = r.styleSpec, s = n.sky, l = r.style, d = Ft(t); if (t === void 0) return []; if (d !== "object") return [new fe("sky", t, `object expected, ${d} found`)]; let p = []; for (const _ in t) p = p.concat(s[_] ? r.validateSpec({ key: _, value: t[_], valueSpec: s[_], style: l, styleSpec: n }) : [new fe(_, t[_], `unknown property "${_}"`)]); return p } function su(r) { const t = r.value, n = r.styleSpec, s = n.terrain, l = r.style; let d = []; const p = Ft(t); if (t === void 0) return d; if (p !== "object") return d = d.concat([new fe("terrain", t, `object expected, ${p} found`)]), d; for (const _ in t) d = d.concat(s[_] ? r.validateSpec({ key: _, value: t[_], valueSpec: s[_], validateSpec: r.validateSpec, style: l, styleSpec: n }) : [new fe(_, t[_], `unknown property "${_}"`)]); return d } function ou(r) { let t = []; const n = r.value, s = r.key; if (Array.isArray(n)) { const l = [], d = []; for (const p in n) n[p].id && l.includes(n[p].id) && t.push(new fe(s, n, `all the sprites' ids must be unique, but ${n[p].id} is duplicated`)), l.push(n[p].id), n[p].url && d.includes(n[p].url) && t.push(new fe(s, n, `all the sprites' URLs must be unique, but ${n[p].url} is duplicated`)), d.push(n[p].url), t = t.concat(Nr({ key: `${s}[${p}]`, value: n[p], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: r.validateSpec })); return t } return Cn({ key: s, value: n }) } const au = { "*": () => [], array: bl, boolean: function (r) { const t = r.value, n = r.key, s = Ft(t); return s !== "boolean" ? [new fe(n, t, `boolean expected, ${s} found`)] : [] }, number: wl, color: function (r) { const t = r.key, n = r.value, s = Ft(n); return s !== "string" ? [new fe(t, n, `color expected, ${s} found`)] : Lt.parse(String(n)) ? [] : [new fe(t, n, `color expected, "${n}" found`)] }, constants: no, enum: Ms, filter: Is, function: Qc, layer: Sl, object: Nr, source: iu, light: ru, sky: nu, terrain: su, projection: function (r) { const t = r.value, n = r.styleSpec, s = n.projection, l = r.style, d = Ft(t); if (t === void 0) return []; if (d !== "object") return [new fe("projection", t, `object expected, ${d} found`)]; let p = []; for (const _ in t) p = p.concat(s[_] ? r.validateSpec({ key: _, value: t[_], valueSpec: s[_], style: l, styleSpec: n }) : [new fe(_, t[_], `unknown property "${_}"`)]); return p }, projectionDefinition: function (r) { const t = r.key; let n = r.value; n = n instanceof String ? n.valueOf() : n; const s = Ft(n); return s !== "array" || function (l) { return Array.isArray(l) && l.length === 3 && typeof l[0] == "string" && typeof l[1] == "string" && typeof l[2] == "number" }(n) || function (l) { return !!["interpolate", "step", "literal"].includes(l[0]) }(n) ? ["array", "string"].includes(s) ? [] : [new fe(t, n, `projection expected, invalid type "${s}" found`)] : [new fe(t, n, `projection expected, invalid array ${JSON.stringify(n)} found`)] }, string: Cn, formatted: function (r) { return Cn(r).length === 0 ? [] : es(r) }, resolvedImage: function (r) { return Cn(r).length === 0 ? [] : es(r) }, padding: function (r) { const t = r.key, n = r.value; if (Ft(n) === "array") { if (n.length < 1 || n.length > 4) return [new fe(t, n, `padding requires 1 to 4 values; ${n.length} values found`)]; const s = { type: "number" }; let l = []; for (let d = 0; d < n.length; d++)l = l.concat(r.validateSpec({ key: `${t}[${d}]`, value: n[d], validateSpec: r.validateSpec, valueSpec: s })); return l } return wl({ key: t, value: n, valueSpec: {} }) }, variableAnchorOffsetCollection: function (r) { const t = r.key, n = r.value, s = Ft(n), l = r.styleSpec; if (s !== "array" || n.length < 1 || n.length % 2 != 0) return [new fe(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")]; let d = []; for (let p = 0; p < n.length; p += 2)d = d.concat(Ms({ key: `${t}[${p}]`, value: n[p], valueSpec: l.layout_symbol["text-anchor"] })), d = d.concat(bl({ key: `${t}[${p + 1}]`, value: n[p + 1], valueSpec: { length: 2, value: "number" }, validateSpec: r.validateSpec, style: r.style, styleSpec: l })); return d }, sprite: ou }; function En(r) { const t = r.value, n = r.valueSpec, s = r.styleSpec; return r.validateSpec = En, n.expression && Xo(_i(t)) ? Qc(r) : n.expression && Ko(Qn(t)) ? es(r) : n.type && au[n.type] ? au[n.type](r) : Nr(He({}, r, { valueSpec: n.type ? s[n.type] : n })) } function Es(r) { const t = r.value, n = r.key, s = Cn(r); return s.length || (t.indexOf("{fontstack}") === -1 && s.push(new fe(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && s.push(new fe(n, t, '"glyphs" url must include a "{range}" token'))), s } function di(r, t = C) { let n = []; return n = n.concat(En({ key: "", value: r, valueSpec: t.$root, styleSpec: t, style: r, validateSpec: En, objectElementValidators: { glyphs: Es, "*": () => [] } })), r.constants && (n = n.concat(no({ key: "constants", value: r.constants }))), Ml(n) } function fr(r) { return function (t) { return r({ ...t, validateSpec: En }) } } function Ml(r) { return [].concat(r).sort((t, n) => t.line - n.line) } function un(r) { return function (...t) { return Ml(r.apply(this, t)) } } di.source = un(fr(iu)), di.sprite = un(fr(ou)), di.glyphs = un(fr(Es)), di.light = un(fr(ru)), di.sky = un(fr(nu)), di.terrain = un(fr(su)), di.layer = un(fr(Sl)), di.filter = un(fr(Is)), di.paintProperty = un(fr(Pl)), di.layoutProperty = un(fr(tu)); const As = di, so = As.light, lu = As.sky, Il = As.paintProperty, Sh = As.layoutProperty; function ia(r, t) { let n = !1; if (t && t.length) for (const s of t) r.fire(new Rr(new Error(s.message))), n = !0; return n } class oo { constructor(t, n, s) { const l = this.cells = []; if (t instanceof ArrayBuffer) { this.arrayBuffer = t; const p = new Int32Array(this.arrayBuffer); t = p[0], this.d = (n = p[1]) + 2 * (s = p[2]); for (let y = 0; y < this.d * this.d; y++) { const b = p[3 + y], T = p[3 + y + 1]; l.push(b === T ? null : p.subarray(b, T)) } const _ = p[3 + l.length + 1]; this.keys = p.subarray(p[3 + l.length], _), this.bboxes = p.subarray(_), this.insert = this._insertReadonly } else { this.d = n + 2 * s; for (let p = 0; p < this.d * this.d; p++)l.push([]); this.keys = [], this.bboxes = [] } this.n = n, this.extent = t, this.padding = s, this.scale = n / t, this.uid = 0; const d = s / n * t; this.min = -d, this.max = t + d } insert(t, n, s, l, d) { this._forEachCell(n, s, l, d, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(n), this.bboxes.push(s), this.bboxes.push(l), this.bboxes.push(d) } _insertReadonly() { throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.") } _insertCell(t, n, s, l, d, p) { this.cells[d].push(p) } query(t, n, s, l, d) { const p = this.min, _ = this.max; if (t <= p && n <= p && _ <= s && _ <= l && !d) return Array.prototype.slice.call(this.keys); { const y = []; return this._forEachCell(t, n, s, l, this._queryCell, y, {}, d), y } } _queryCell(t, n, s, l, d, p, _, y) { const b = this.cells[d]; if (b !== null) { const T = this.keys, M = this.bboxes; for (let k = 0; k < b.length; k++) { const R = b[k]; if (_[R] === void 0) { const L = 4 * R; (y ? y(M[L + 0], M[L + 1], M[L + 2], M[L + 3]) : t <= M[L + 2] && n <= M[L + 3] && s >= M[L + 0] && l >= M[L + 1]) ? (_[R] = !0, p.push(T[R])) : _[R] = !1 } } } } _forEachCell(t, n, s, l, d, p, _, y) { const b = this._convertToCellCoord(t), T = this._convertToCellCoord(n), M = this._convertToCellCoord(s), k = this._convertToCellCoord(l); for (let R = b; R <= M; R++)for (let L = T; L <= k; L++) { const O = this.d * L + R; if ((!y || y(this._convertFromCellCoord(R), this._convertFromCellCoord(L), this._convertFromCellCoord(R + 1), this._convertFromCellCoord(L + 1))) && d.call(this, t, n, s, l, O, p, _, y)) return } } _convertFromCellCoord(t) { return (t - this.padding) / this.scale } _convertToCellCoord(t) { return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding)) } toArrayBuffer() { if (this.arrayBuffer) return this.arrayBuffer; const t = this.cells, n = 3 + this.cells.length + 1 + 1; let s = 0; for (let p = 0; p < this.cells.length; p++)s += this.cells[p].length; const l = new Int32Array(n + s + this.keys.length + this.bboxes.length); l[0] = this.extent, l[1] = this.n, l[2] = this.padding; let d = n; for (let p = 0; p < t.length; p++) { const _ = t[p]; l[3 + p] = d, l.set(_, d), d += _.length } return l[3 + t.length] = d, l.set(this.keys, d), d += this.keys.length, l[3 + t.length + 1] = d, l.set(this.bboxes, d), d += this.bboxes.length, l.buffer } static serialize(t, n) { const s = t.toArrayBuffer(); return n && n.push(s), { buffer: s } } static deserialize(t) { return new oo(t.buffer) } } const wr = {}; function Je(r, t, n = {}) { if (wr[r]) throw new Error(`${r} is already registered.`); Object.defineProperty(t, "_classRegistryKey", { value: r, writeable: !1 }), wr[r] = { klass: t, omit: n.omit || [], shallow: n.shallow || [] } } Je("Object", Object), Je("TransferableGridIndex", oo), Je("Color", Lt), Je("Error", Error), Je("AJAXError", At), Je("ResolvedImage", nr), Je("StylePropertyFunction", Yo), Je("StyleExpression", ml, { omit: ["_evaluator"] }), Je("ZoomDependentExpression", _l), Je("ZoomConstantExpression", Jo), Je("CompoundExpression", Vr, { omit: ["_evaluate"] }); for (const r in ws) ws[r]._classRegistryKey || Je(`Expression_${r}`, ws[r]); function zs(r) { return r && typeof ArrayBuffer < "u" && (r instanceof ArrayBuffer || r.constructor && r.constructor.name === "ArrayBuffer") } function Cl(r) { return r.$name || r.constructor._classRegistryKey } function cu(r) { return !function (t) { if (t === null || typeof t != "object") return !1; const n = Cl(t); return !(!n || n === "Object") }(r) && (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp || r instanceof Blob || r instanceof Error || zs(r) || Ze(r) || ArrayBuffer.isView(r) || r instanceof ImageData) } function An(r, t) { if (cu(r)) return (zs(r) || Ze(r)) && t && t.push(r), ArrayBuffer.isView(r) && t && t.push(r.buffer), r instanceof ImageData && t && t.push(r.data.buffer), r; if (Array.isArray(r)) { const d = []; for (const p of r) d.push(An(p, t)); return d } if (typeof r != "object") throw new Error("can't serialize object of type " + typeof r); const n = Cl(r); if (!n) throw new Error(`can't serialize object of unregistered class ${r.constructor.name}`); if (!wr[n]) throw new Error(`${n} is not registered.`); const { klass: s } = wr[n], l = s.serialize ? s.serialize(r, t) : {}; if (s.serialize) { if (t && l === t[t.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property") } else { for (const d in r) { if (!r.hasOwnProperty(d) || wr[n].omit.indexOf(d) >= 0) continue; const p = r[d]; l[d] = wr[n].shallow.indexOf(d) >= 0 ? p : An(p, t) } r instanceof Error && (l.message = r.message) } if (l.$name) throw new Error("$name property is reserved for worker serialization logic."); return n !== "Object" && (l.$name = n), l } function ao(r) { if (cu(r)) return r; if (Array.isArray(r)) return r.map(ao); if (typeof r != "object") throw new Error("can't deserialize object of type " + typeof r); const t = Cl(r) || "Object"; if (!wr[t]) throw new Error(`can't deserialize unregistered class ${t}`); const { klass: n } = wr[t]; if (!n) throw new Error(`can't deserialize unregistered class ${t}`); if (n.deserialize) return n.deserialize(r); const s = Object.create(n.prototype); for (const l of Object.keys(r)) { if (l === "$name") continue; const d = r[l]; s[l] = wr[t].shallow.indexOf(l) >= 0 ? d : ao(d) } return s } class ra { constructor() { this.first = !0 } update(t, n) { const s = Math.floor(t); return this.first ? (this.first = !1, this.lastIntegerZoom = s, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = s, !0) : (this.lastFloorZoom > s ? (this.lastIntegerZoom = s + 1, this.lastIntegerZoomTime = n) : this.lastFloorZoom < s && (this.lastIntegerZoom = s, this.lastIntegerZoomTime = n), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = s, !0)) } } const wt = { "Latin-1 Supplement": r => r >= 128 && r <= 255, "Hangul Jamo": r => r >= 4352 && r <= 4607, Khmer: r => r >= 6016 && r <= 6143, "General Punctuation": r => r >= 8192 && r <= 8303, "Letterlike Symbols": r => r >= 8448 && r <= 8527, "Number Forms": r => r >= 8528 && r <= 8591, "Miscellaneous Technical": r => r >= 8960 && r <= 9215, "Control Pictures": r => r >= 9216 && r <= 9279, "Optical Character Recognition": r => r >= 9280 && r <= 9311, "Enclosed Alphanumerics": r => r >= 9312 && r <= 9471, "Geometric Shapes": r => r >= 9632 && r <= 9727, "Miscellaneous Symbols": r => r >= 9728 && r <= 9983, "Miscellaneous Symbols and Arrows": r => r >= 11008 && r <= 11263, "Ideographic Description Characters": r => r >= 12272 && r <= 12287, "CJK Symbols and Punctuation": r => r >= 12288 && r <= 12351, Hiragana: r => r >= 12352 && r <= 12447, Katakana: r => r >= 12448 && r <= 12543, Kanbun: r => r >= 12688 && r <= 12703, "CJK Strokes": r => r >= 12736 && r <= 12783, "Enclosed CJK Letters and Months": r => r >= 12800 && r <= 13055, "CJK Compatibility": r => r >= 13056 && r <= 13311, "Yijing Hexagram Symbols": r => r >= 19904 && r <= 19967, "CJK Unified Ideographs": r => r >= 19968 && r <= 40959, "Hangul Syllables": r => r >= 44032 && r <= 55215, "Private Use Area": r => r >= 57344 && r <= 63743, "Vertical Forms": r => r >= 65040 && r <= 65055, "CJK Compatibility Forms": r => r >= 65072 && r <= 65103, "Small Form Variants": r => r >= 65104 && r <= 65135, "Halfwidth and Fullwidth Forms": r => r >= 65280 && r <= 65519 }; function na(r) { for (const t of r) if (zl(t.charCodeAt(0))) return !0; return !1 } function uu(r) { for (const t of r) if (!El(t.charCodeAt(0))) return !1; return !0 } function sa(r) { const t = r.map(n => { try { return new RegExp(`\\p{sc=${n}}`, "u").source } catch { return null } }).filter(n => n); return new RegExp(t.join("|"), "u") } const hu = sa(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]); function El(r) { return !hu.test(String.fromCodePoint(r)) } const Al = sa(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]); function zl(r) { return !(r !== 746 && r !== 747 && (r < 4352 || !(wt["CJK Compatibility Forms"](r) && !(r >= 65097 && r <= 65103) || wt["CJK Compatibility"](r) || wt["CJK Strokes"](r) || !(!wt["CJK Symbols and Punctuation"](r) || r >= 12296 && r <= 12305 || r >= 12308 && r <= 12319 || r === 12336) || wt["Enclosed CJK Letters and Months"](r) || wt["Ideographic Description Characters"](r) || wt.Kanbun(r) || wt.Katakana(r) && r !== 12540 || !(!wt["Halfwidth and Fullwidth Forms"](r) || r === 65288 || r === 65289 || r === 65293 || r >= 65306 && r <= 65310 || r === 65339 || r === 65341 || r === 65343 || r >= 65371 && r <= 65503 || r === 65507 || r >= 65512 && r <= 65519) || !(!wt["Small Form Variants"](r) || r >= 65112 && r <= 65118 || r >= 65123 && r <= 65126) || wt["Vertical Forms"](r) || wt["Yijing Hexagram Symbols"](r) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(r)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(r)) || Al.test(String.fromCodePoint(r))))) } function kl(r) { return !(zl(r) || function (t) { return !!(wt["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || wt["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || wt["Letterlike Symbols"](t) || wt["Number Forms"](t) || wt["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || wt["Control Pictures"](t) && t !== 9251 || wt["Optical Character Recognition"](t) || wt["Enclosed Alphanumerics"](t) || wt["Geometric Shapes"](t) || wt["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || wt["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || wt["CJK Symbols and Punctuation"](t) || wt.Katakana(t) || wt["Private Use Area"](t) || wt["CJK Compatibility Forms"](t) || wt["Small Form Variants"](t) || wt["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533) }(r)) } const Mh = sa(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]); function Dl(r) { return Mh.test(String.fromCodePoint(r)) } function du(r, t) { return !(!t && Dl(r) || r >= 2304 && r <= 3583 || r >= 3840 && r <= 4255 || wt.Khmer(r)) } function pu(r) { for (const t of r) if (Dl(t.charCodeAt(0))) return !0; return !1 } const zn = new class { constructor() { this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => { } } setState(r) { this.pluginStatus = r.pluginStatus, this.pluginURL = r.pluginURL } getState() { return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL } } setMethods(r) { if (zn.isParsed()) throw new Error("RTL text plugin already registered."); this.applyArabicShaping = r.applyArabicShaping, this.processBidirectionalText = r.processBidirectionalText, this.processStyledBidirectionalText = r.processStyledBidirectionalText, this.loadScriptResolve() } isParsed() { return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null } getRTLTextPluginStatus() { return this.pluginStatus } syncState(r, t) { return c(this, void 0, void 0, function* () { if (this.isParsed()) return this.getState(); if (r.pluginStatus !== "loading") return this.setState(r), r; const n = r.pluginURL, s = new Promise(d => { this.loadScriptResolve = d }); t(n); const l = new Promise(d => setTimeout(() => d(), this.TIMEOUT)); if (yield Promise.race([s, l]), this.isParsed()) { const d = { pluginStatus: "loaded", pluginURL: n }; return this.setState(d), d } throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${n}`) }) } }; class si { constructor(t, n) { this.zoom = t, n ? (this.now = n.now, this.fadeDuration = n.fadeDuration, this.zoomHistory = n.zoomHistory, this.transition = n.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new ra, this.transition = {}) } isSupportedScript(t) { return function (n, s) { for (const l of n) if (!du(l.charCodeAt(0), s)) return !1; return !0 }(t, zn.getRTLTextPluginStatus() === "loaded") } crossFadingFactor() { return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1) } getCrossfadeParameters() { const t = this.zoom, n = t - Math.floor(t), s = this.crossFadingFactor(); return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: n + (1 - n) * s } : { fromScale: .5, toScale: 1, t: 1 - (1 - s) * n } } } class lo { constructor(t, n) { this.property = t, this.value = n, this.expression = function (s, l) { if (Xo(s)) return new Yo(s, l); if (Ko(s)) { const d = Kc(s, l); if (d.result === "error") throw new Error(d.value.map(p => `${p.key}: ${p.message}`).join(", ")); return d.value } { let d = s; return l.type === "color" && typeof s == "string" ? d = Lt.parse(s) : l.type !== "padding" || typeof s != "number" && !Array.isArray(s) ? l.type === "variableAnchorOffsetCollection" && Array.isArray(s) ? d = Ri.parse(s) : l.type === "projectionDefinition" && typeof s == "string" && (d = dr.parse(s)) : d = Di.parse(s), { kind: "constant", evaluate: () => d } } }(n === void 0 ? t.specification.default : n, t.specification) } isDataDriven() { return this.expression.kind === "source" || this.expression.kind === "composite" } possiblyEvaluate(t, n, s) { return this.property.possiblyEvaluate(this, t, n, s) } } class oa { constructor(t) { this.property = t, this.value = new lo(t, void 0) } transitioned(t, n) { return new Ll(this.property, this.value, n, Si({}, t.transition, this.transition), t.now) } untransitioned() { return new Ll(this.property, this.value, null, {}, 0) } } class Rl { constructor(t) { this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues) } getValue(t) { return Ki(this._values[t].value.value) } setValue(t, n) { Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new oa(this._values[t].property)), this._values[t].value = new lo(this._values[t].property, n === null ? void 0 : Ki(n)) } getTransition(t) { return Ki(this._values[t].transition) } setTransition(t, n) { Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new oa(this._values[t].property)), this._values[t].transition = Ki(n) || void 0 } serialize() { const t = {}; for (const n of Object.keys(this._values)) { const s = this.getValue(n); s !== void 0 && (t[n] = s); const l = this.getTransition(n); l !== void 0 && (t[`${n}-transition`] = l) } return t } transitioned(t, n) { const s = new co(this._properties); for (const l of Object.keys(this._values)) s._values[l] = this._values[l].transitioned(t, n._values[l]); return s } untransitioned() { const t = new co(this._properties); for (const n of Object.keys(this._values)) t._values[n] = this._values[n].untransitioned(); return t } } class Ll { constructor(t, n, s, l, d) { this.property = t, this.value = n, this.begin = d + l.delay || 0, this.end = this.begin + l.duration || 0, t.specification.transition && (l.delay || l.duration) && (this.prior = s) } possiblyEvaluate(t, n, s) { const l = t.now || 0, d = this.value.possiblyEvaluate(t, n, s), p = this.prior; if (p) { if (l > this.end) return this.prior = null, d; if (this.value.isDataDriven()) return this.prior = null, d; if (l < this.begin) return p.possiblyEvaluate(t, n, s); { const _ = (l - this.begin) / (this.end - this.begin); return this.property.interpolate(p.possiblyEvaluate(t, n, s), d, kr(_)) } } return d } } class co { constructor(t) { this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues) } possiblyEvaluate(t, n, s) { const l = new aa(this._properties); for (const d of Object.keys(this._values)) l._values[d] = this._values[d].possiblyEvaluate(t, n, s); return l } hasTransition() { for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0; return !1 } } class Ih { constructor(t) { this._properties = t, this._values = Object.create(t.defaultPropertyValues) } hasValue(t) { return this._values[t].value !== void 0 } getValue(t) { return Ki(this._values[t].value) } setValue(t, n) { this._values[t] = new lo(this._values[t].property, n === null ? void 0 : Ki(n)) } serialize() { const t = {}; for (const n of Object.keys(this._values)) { const s = this.getValue(n); s !== void 0 && (t[n] = s) } return t } possiblyEvaluate(t, n, s) { const l = new aa(this._properties); for (const d of Object.keys(this._values)) l._values[d] = this._values[d].possiblyEvaluate(t, n, s); return l } } class Zr { constructor(t, n, s) { this.property = t, this.value = n, this.parameters = s } isConstant() { return this.value.kind === "constant" } constantOr(t) { return this.value.kind === "constant" ? this.value.value : t } evaluate(t, n, s, l) { return this.property.evaluate(this.value, this.parameters, t, n, s, l) } } class aa { constructor(t) { this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues) } get(t) { return this._values[t] } } class nt { constructor(t) { this.specification = t } possiblyEvaluate(t, n) { if (t.isDataDriven()) throw new Error("Value should not be data driven"); return t.expression.evaluate(n) } interpolate(t, n, s) { const l = br[this.specification.type]; return l ? l(t, n, s) : t } } class ht { constructor(t, n) { this.specification = t, this.overrides = n } possiblyEvaluate(t, n, s, l) { return new Zr(this, t.expression.kind === "constant" || t.expression.kind === "camera" ? { kind: "constant", value: t.expression.evaluate(n, null, {}, s, l) } : t.expression, n) } interpolate(t, n, s) { if (t.value.kind !== "constant" || n.value.kind !== "constant") return t; if (t.value.value === void 0 || n.value.value === void 0) return new Zr(this, { kind: "constant", value: void 0 }, t.parameters); const l = br[this.specification.type]; if (l) { const d = l(t.value.value, n.value.value, s); return new Zr(this, { kind: "constant", value: d }, t.parameters) } return t } evaluate(t, n, s, l, d, p) { return t.kind === "constant" ? t.value : t.evaluate(n, s, l, d, p) } } class uo extends ht { possiblyEvaluate(t, n, s, l) { if (t.value === void 0) return new Zr(this, { kind: "constant", value: void 0 }, n); if (t.expression.kind === "constant") { const d = t.expression.evaluate(n, null, {}, s, l), p = t.property.specification.type === "resolvedImage" && typeof d != "string" ? d.name : d, _ = this._calculate(p, p, p, n); return new Zr(this, { kind: "constant", value: _ }, n) } if (t.expression.kind === "camera") { const d = this._calculate(t.expression.evaluate({ zoom: n.zoom - 1 }), t.expression.evaluate({ zoom: n.zoom }), t.expression.evaluate({ zoom: n.zoom + 1 }), n); return new Zr(this, { kind: "constant", value: d }, n) } return new Zr(this, t.expression, n) } evaluate(t, n, s, l, d, p) { if (t.kind === "source") { const _ = t.evaluate(n, s, l, d, p); return this._calculate(_, _, _, n) } return t.kind === "composite" ? this._calculate(t.evaluate({ zoom: Math.floor(n.zoom) - 1 }, s, l), t.evaluate({ zoom: Math.floor(n.zoom) }, s, l), t.evaluate({ zoom: Math.floor(n.zoom) + 1 }, s, l), n) : t.value } _calculate(t, n, s, l) { return l.zoom > l.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: s, to: n } } interpolate(t) { return t } } class la { constructor(t) { this.specification = t } possiblyEvaluate(t, n, s, l) { if (t.value !== void 0) { if (t.expression.kind === "constant") { const d = t.expression.evaluate(n, null, {}, s, l); return this._calculate(d, d, d, n) } return this._calculate(t.expression.evaluate(new si(Math.floor(n.zoom - 1), n)), t.expression.evaluate(new si(Math.floor(n.zoom), n)), t.expression.evaluate(new si(Math.floor(n.zoom + 1), n)), n) } } _calculate(t, n, s, l) { return l.zoom > l.zoomHistory.lastIntegerZoom ? { from: t, to: n } : { from: s, to: n } } interpolate(t) { return t } } class Fl { constructor(t) { this.specification = t } possiblyEvaluate(t, n, s, l) { return !!t.expression.evaluate(n, null, {}, s, l) } interpolate() { return !1 } } class mr { constructor(t) { this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = []; for (const n in t) { const s = t[n]; s.specification.overridable && this.overridableProperties.push(n); const l = this.defaultPropertyValues[n] = new lo(s, void 0), d = this.defaultTransitionablePropertyValues[n] = new oa(s); this.defaultTransitioningPropertyValues[n] = d.untransitioned(), this.defaultPossiblyEvaluatedValues[n] = l.possiblyEvaluate({}) } } } Je("DataDrivenProperty", ht), Je("DataConstantProperty", nt), Je("CrossFadedDataDrivenProperty", uo), Je("CrossFadedProperty", la), Je("ColorRampProperty", Fl); const fu = "-transition"; class hn extends ue { constructor(t, n) { if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, t.type !== "custom" && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type !== "background" && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), n.layout && (this._unevaluatedLayout = new Ih(n.layout)), n.paint)) { this._transitionablePaint = new Rl(n.paint); for (const s in t.paint) this.setPaintProperty(s, t.paint[s], { validate: !1 }); for (const s in t.layout) this.setLayoutProperty(s, t.layout[s], { validate: !1 }); this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new aa(n.paint) } } getCrossfadeParameters() { return this._crossfadeParameters } getLayoutProperty(t) { return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t) } setLayoutProperty(t, n, s = {}) { n != null && this._validate(Sh, `layers.${this.id}.layout.${t}`, t, n, s) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n) } getPaintProperty(t) { return t.endsWith(fu) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t) } setPaintProperty(t, n, s = {}) { if (n != null && this._validate(Il, `layers.${this.id}.paint.${t}`, t, n, s)) return !1; if (t.endsWith(fu)) return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0), !1; { const l = this._transitionablePaint._values[t], d = l.property.specification["property-type"] === "cross-faded-data-driven", p = l.value.isDataDriven(), _ = l.value; this._transitionablePaint.setValue(t, n), this._handleSpecialPaintPropertyUpdate(t); const y = this._transitionablePaint._values[t].value; return y.isDataDriven() || p || d || this._handleOverridablePaintPropertyUpdate(t, _, y) } } _handleSpecialPaintPropertyUpdate(t) { } _handleOverridablePaintPropertyUpdate(t, n, s) { return !1 } isHidden(t) { return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none" } updateTransitions(t) { this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint) } hasTransition() { return this._transitioningPaint.hasTransition() } recalculate(t, n) { t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n) } serialize() { const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }; return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), Gr(t, (n, s) => !(n === void 0 || s === "layout" && !Object.keys(n).length || s === "paint" && !Object.keys(n).length)) } _validate(t, n, s, l, d = {}) { return (!d || d.validate !== !1) && ia(this, t.call(As, { key: n, layerType: this.type, objectKey: s, value: l, styleSpec: C, style: { glyphs: !0, sprite: !0 } })) } is3D() { return !1 } isTileClipped() { return !1 } hasOffscreenPass() { return !1 } resize() { } isStateDependent() { for (const t in this.paint._values) { const n = this.paint.get(t); if (n instanceof Zr && Ps(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent) return !0 } return !1 } } const Ch = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }; class dn { constructor(t, n) { this._structArray = t, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8 } } class pi { constructor() { this.isTransferred = !1, this.capacity = -1, this.resize(0) } static serialize(t, n) { return t._trim(), n && (t.isTransferred = !0, n.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer } } static deserialize(t) { const n = Object.create(this.prototype); return n.arrayBuffer = t.arrayBuffer, n.length = t.length, n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n } _trim() { this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews()) } clear() { this.length = 0 } resize(t) { this.reserve(t), this.length = t } reserve(t) { if (t > this.capacity) { this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement); const n = this.uint8; this._refreshViews(), n && this.uint8.set(n) } } _refreshViews() { throw new Error("_refreshViews() must be implemented by each concrete StructArray layout") } } function xi(r, t = 1) { let n = 0, s = 0; return { members: r.map(l => { const d = Ch[l.type].BYTES_PER_ELEMENT, p = n = mu(n, Math.max(t, d)), _ = l.components || 1; return s = Math.max(s, d), n += d * _, { name: l.name, type: l.type, components: _, offset: p } }), size: mu(n, Math.max(s, t)), alignment: t } } function mu(r, t) { return Math.ceil(r / t) * t } class ks extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(t, n) { const s = this.length; return this.resize(s + 1), this.emplace(s, t, n) } emplace(t, n, s) { const l = 2 * t; return this.int16[l + 0] = n, this.int16[l + 1] = s, t } } ks.prototype.bytesPerElement = 4, Je("StructArrayLayout2i4", ks); class ca extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(t, n, s) { const l = this.length; return this.resize(l + 1), this.emplace(l, t, n, s) } emplace(t, n, s, l) { const d = 3 * t; return this.int16[d + 0] = n, this.int16[d + 1] = s, this.int16[d + 2] = l, t } } ca.prototype.bytesPerElement = 6, Je("StructArrayLayout3i6", ca); class Bl extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(t, n, s, l) { const d = this.length; return this.resize(d + 1), this.emplace(d, t, n, s, l) } emplace(t, n, s, l, d) { const p = 4 * t; return this.int16[p + 0] = n, this.int16[p + 1] = s, this.int16[p + 2] = l, this.int16[p + 3] = d, t } } Bl.prototype.bytesPerElement = 8, Je("StructArrayLayout4i8", Bl); class gn extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(t, n, s, l, d, p) { const _ = this.length; return this.resize(_ + 1), this.emplace(_, t, n, s, l, d, p) } emplace(t, n, s, l, d, p, _) { const y = 6 * t; return this.int16[y + 0] = n, this.int16[y + 1] = s, this.int16[y + 2] = l, this.int16[y + 3] = d, this.int16[y + 4] = p, this.int16[y + 5] = _, t } } gn.prototype.bytesPerElement = 12, Je("StructArrayLayout2i4i12", gn); class ua extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(t, n, s, l, d, p) { const _ = this.length; return this.resize(_ + 1), this.emplace(_, t, n, s, l, d, p) } emplace(t, n, s, l, d, p, _) { const y = 4 * t, b = 8 * t; return this.int16[y + 0] = n, this.int16[y + 1] = s, this.uint8[b + 4] = l, this.uint8[b + 5] = d, this.uint8[b + 6] = p, this.uint8[b + 7] = _, t } } ua.prototype.bytesPerElement = 8, Je("StructArrayLayout2i4ub8", ua); class ts extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(t, n) { const s = this.length; return this.resize(s + 1), this.emplace(s, t, n) } emplace(t, n, s) { const l = 2 * t; return this.float32[l + 0] = n, this.float32[l + 1] = s, t } } ts.prototype.bytesPerElement = 8, Je("StructArrayLayout2f8", ts); class ha extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(t, n, s, l, d, p, _, y, b, T) { const M = this.length; return this.resize(M + 1), this.emplace(M, t, n, s, l, d, p, _, y, b, T) } emplace(t, n, s, l, d, p, _, y, b, T, M) { const k = 10 * t; return this.uint16[k + 0] = n, this.uint16[k + 1] = s, this.uint16[k + 2] = l, this.uint16[k + 3] = d, this.uint16[k + 4] = p, this.uint16[k + 5] = _, this.uint16[k + 6] = y, this.uint16[k + 7] = b, this.uint16[k + 8] = T, this.uint16[k + 9] = M, t } } ha.prototype.bytesPerElement = 20, Je("StructArrayLayout10ui20", ha); class ho extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(t, n, s, l, d, p, _, y, b, T, M, k) { const R = this.length; return this.resize(R + 1), this.emplace(R, t, n, s, l, d, p, _, y, b, T, M, k) } emplace(t, n, s, l, d, p, _, y, b, T, M, k, R) { const L = 12 * t; return this.int16[L + 0] = n, this.int16[L + 1] = s, this.int16[L + 2] = l, this.int16[L + 3] = d, this.uint16[L + 4] = p, this.uint16[L + 5] = _, this.uint16[L + 6] = y, this.uint16[L + 7] = b, this.int16[L + 8] = T, this.int16[L + 9] = M, this.int16[L + 10] = k, this.int16[L + 11] = R, t } } ho.prototype.bytesPerElement = 24, Je("StructArrayLayout4i4ui4i24", ho); class Ol extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(t, n, s) { const l = this.length; return this.resize(l + 1), this.emplace(l, t, n, s) } emplace(t, n, s, l) { const d = 3 * t; return this.float32[d + 0] = n, this.float32[d + 1] = s, this.float32[d + 2] = l, t } } Ol.prototype.bytesPerElement = 12, Je("StructArrayLayout3f12", Ol); class Ds extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer) } emplaceBack(t) { const n = this.length; return this.resize(n + 1), this.emplace(n, t) } emplace(t, n) { return this.uint32[1 * t + 0] = n, t } } Ds.prototype.bytesPerElement = 4, Je("StructArrayLayout1ul4", Ds); class is extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(t, n, s, l, d, p, _, y, b) { const T = this.length; return this.resize(T + 1), this.emplace(T, t, n, s, l, d, p, _, y, b) } emplace(t, n, s, l, d, p, _, y, b, T) { const M = 10 * t, k = 5 * t; return this.int16[M + 0] = n, this.int16[M + 1] = s, this.int16[M + 2] = l, this.int16[M + 3] = d, this.int16[M + 4] = p, this.int16[M + 5] = _, this.uint32[k + 3] = y, this.uint16[M + 8] = b, this.uint16[M + 9] = T, t } } is.prototype.bytesPerElement = 20, Je("StructArrayLayout6i1ul2ui20", is); class jl extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(t, n, s, l, d, p) { const _ = this.length; return this.resize(_ + 1), this.emplace(_, t, n, s, l, d, p) } emplace(t, n, s, l, d, p, _) { const y = 6 * t; return this.int16[y + 0] = n, this.int16[y + 1] = s, this.int16[y + 2] = l, this.int16[y + 3] = d, this.int16[y + 4] = p, this.int16[y + 5] = _, t } } jl.prototype.bytesPerElement = 12, Je("StructArrayLayout2i2i2i12", jl); class da extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(t, n, s, l, d) { const p = this.length; return this.resize(p + 1), this.emplace(p, t, n, s, l, d) } emplace(t, n, s, l, d, p) { const _ = 4 * t, y = 8 * t; return this.float32[_ + 0] = n, this.float32[_ + 1] = s, this.float32[_ + 2] = l, this.int16[y + 6] = d, this.int16[y + 7] = p, t } } da.prototype.bytesPerElement = 16, Je("StructArrayLayout2f1f2i16", da); class rs extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer) } emplaceBack(t, n, s, l, d, p) { const _ = this.length; return this.resize(_ + 1), this.emplace(_, t, n, s, l, d, p) } emplace(t, n, s, l, d, p, _) { const y = 16 * t, b = 4 * t, T = 8 * t; return this.uint8[y + 0] = n, this.uint8[y + 1] = s, this.float32[b + 1] = l, this.float32[b + 2] = d, this.int16[T + 6] = p, this.int16[T + 7] = _, t } } rs.prototype.bytesPerElement = 16, Je("StructArrayLayout2ub2f2i16", rs); class pa extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(t, n, s) { const l = this.length; return this.resize(l + 1), this.emplace(l, t, n, s) } emplace(t, n, s, l) { const d = 3 * t; return this.uint16[d + 0] = n, this.uint16[d + 1] = s, this.uint16[d + 2] = l, t } } pa.prototype.bytesPerElement = 6, Je("StructArrayLayout3ui6", pa); class Vl extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(t, n, s, l, d, p, _, y, b, T, M, k, R, L, O, U, W) { const se = this.length; return this.resize(se + 1), this.emplace(se, t, n, s, l, d, p, _, y, b, T, M, k, R, L, O, U, W) } emplace(t, n, s, l, d, p, _, y, b, T, M, k, R, L, O, U, W, se) { const J = 24 * t, D = 12 * t, N = 48 * t; return this.int16[J + 0] = n, this.int16[J + 1] = s, this.uint16[J + 2] = l, this.uint16[J + 3] = d, this.uint32[D + 2] = p, this.uint32[D + 3] = _, this.uint32[D + 4] = y, this.uint16[J + 10] = b, this.uint16[J + 11] = T, this.uint16[J + 12] = M, this.float32[D + 7] = k, this.float32[D + 8] = R, this.uint8[N + 36] = L, this.uint8[N + 37] = O, this.uint8[N + 38] = U, this.uint32[D + 10] = W, this.int16[J + 22] = se, t } } Vl.prototype.bytesPerElement = 48, Je("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Vl); class fa extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(t, n, s, l, d, p, _, y, b, T, M, k, R, L, O, U, W, se, J, D, N, Y, _e, ke, ve, Te, je, Re) { const Ne = this.length; return this.resize(Ne + 1), this.emplace(Ne, t, n, s, l, d, p, _, y, b, T, M, k, R, L, O, U, W, se, J, D, N, Y, _e, ke, ve, Te, je, Re) } emplace(t, n, s, l, d, p, _, y, b, T, M, k, R, L, O, U, W, se, J, D, N, Y, _e, ke, ve, Te, je, Re, Ne) { const Ce = 32 * t, Ye = 16 * t; return this.int16[Ce + 0] = n, this.int16[Ce + 1] = s, this.int16[Ce + 2] = l, this.int16[Ce + 3] = d, this.int16[Ce + 4] = p, this.int16[Ce + 5] = _, this.int16[Ce + 6] = y, this.int16[Ce + 7] = b, this.uint16[Ce + 8] = T, this.uint16[Ce + 9] = M, this.uint16[Ce + 10] = k, this.uint16[Ce + 11] = R, this.uint16[Ce + 12] = L, this.uint16[Ce + 13] = O, this.uint16[Ce + 14] = U, this.uint16[Ce + 15] = W, this.uint16[Ce + 16] = se, this.uint16[Ce + 17] = J, this.uint16[Ce + 18] = D, this.uint16[Ce + 19] = N, this.uint16[Ce + 20] = Y, this.uint16[Ce + 21] = _e, this.uint16[Ce + 22] = ke, this.uint32[Ye + 12] = ve, this.float32[Ye + 13] = Te, this.float32[Ye + 14] = je, this.uint16[Ce + 30] = Re, this.uint16[Ce + 31] = Ne, t } } fa.prototype.bytesPerElement = 64, Je("StructArrayLayout8i15ui1ul2f2ui64", fa); class ma extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(t) { const n = this.length; return this.resize(n + 1), this.emplace(n, t) } emplace(t, n) { return this.float32[1 * t + 0] = n, t } } ma.prototype.bytesPerElement = 4, Je("StructArrayLayout1f4", ma); class u extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(t, n, s) { const l = this.length; return this.resize(l + 1), this.emplace(l, t, n, s) } emplace(t, n, s, l) { const d = 3 * t; return this.uint16[6 * t + 0] = n, this.float32[d + 1] = s, this.float32[d + 2] = l, t } } u.prototype.bytesPerElement = 12, Je("StructArrayLayout1ui2f12", u); class e extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(t, n, s) { const l = this.length; return this.resize(l + 1), this.emplace(l, t, n, s) } emplace(t, n, s, l) { const d = 4 * t; return this.uint32[2 * t + 0] = n, this.uint16[d + 2] = s, this.uint16[d + 3] = l, t } } e.prototype.bytesPerElement = 8, Je("StructArrayLayout1ul2ui8", e); class i extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(t, n) { const s = this.length; return this.resize(s + 1), this.emplace(s, t, n) } emplace(t, n, s) { const l = 2 * t; return this.uint16[l + 0] = n, this.uint16[l + 1] = s, t } } i.prototype.bytesPerElement = 4, Je("StructArrayLayout2ui4", i); class o extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer) } emplaceBack(t) { const n = this.length; return this.resize(n + 1), this.emplace(n, t) } emplace(t, n) { return this.uint16[1 * t + 0] = n, t } } o.prototype.bytesPerElement = 2, Je("StructArrayLayout1ui2", o); class a extends pi { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer) } emplaceBack(t, n, s, l) { const d = this.length; return this.resize(d + 1), this.emplace(d, t, n, s, l) } emplace(t, n, s, l, d) { const p = 4 * t; return this.float32[p + 0] = n, this.float32[p + 1] = s, this.float32[p + 2] = l, this.float32[p + 3] = d, t } } a.prototype.bytesPerElement = 16, Je("StructArrayLayout4f16", a); class h extends dn { get anchorPointX() { return this._structArray.int16[this._pos2 + 0] } get anchorPointY() { return this._structArray.int16[this._pos2 + 1] } get x1() { return this._structArray.int16[this._pos2 + 2] } get y1() { return this._structArray.int16[this._pos2 + 3] } get x2() { return this._structArray.int16[this._pos2 + 4] } get y2() { return this._structArray.int16[this._pos2 + 5] } get featureIndex() { return this._structArray.uint32[this._pos4 + 3] } get sourceLayerIndex() { return this._structArray.uint16[this._pos2 + 8] } get bucketIndex() { return this._structArray.uint16[this._pos2 + 9] } get anchorPoint() { return new Ge(this.anchorPointX, this.anchorPointY) } } h.prototype.size = 20; class f extends is { get(t) { return new h(this, t) } } Je("CollisionBoxArray", f); class g extends dn { get anchorX() { return this._structArray.int16[this._pos2 + 0] } get anchorY() { return this._structArray.int16[this._pos2 + 1] } get glyphStartIndex() { return this._structArray.uint16[this._pos2 + 2] } get numGlyphs() { return this._structArray.uint16[this._pos2 + 3] } get vertexStartIndex() { return this._structArray.uint32[this._pos4 + 2] } get lineStartIndex() { return this._structArray.uint32[this._pos4 + 3] } get lineLength() { return this._structArray.uint32[this._pos4 + 4] } get segment() { return this._structArray.uint16[this._pos2 + 10] } get lowerSize() { return this._structArray.uint16[this._pos2 + 11] } get upperSize() { return this._structArray.uint16[this._pos2 + 12] } get lineOffsetX() { return this._structArray.float32[this._pos4 + 7] } get lineOffsetY() { return this._structArray.float32[this._pos4 + 8] } get writingMode() { return this._structArray.uint8[this._pos1 + 36] } get placedOrientation() { return this._structArray.uint8[this._pos1 + 37] } set placedOrientation(t) { this._structArray.uint8[this._pos1 + 37] = t } get hidden() { return this._structArray.uint8[this._pos1 + 38] } set hidden(t) { this._structArray.uint8[this._pos1 + 38] = t } get crossTileID() { return this._structArray.uint32[this._pos4 + 10] } set crossTileID(t) { this._structArray.uint32[this._pos4 + 10] = t } get associatedIconIndex() { return this._structArray.int16[this._pos2 + 22] } } g.prototype.size = 48; class v extends Vl { get(t) { return new g(this, t) } } Je("PlacedSymbolArray", v); class w extends dn { get anchorX() { return this._structArray.int16[this._pos2 + 0] } get anchorY() { return this._structArray.int16[this._pos2 + 1] } get rightJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 2] } get centerJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 3] } get leftJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 4] } get verticalPlacedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 5] } get placedIconSymbolIndex() { return this._structArray.int16[this._pos2 + 6] } get verticalPlacedIconSymbolIndex() { return this._structArray.int16[this._pos2 + 7] } get key() { return this._structArray.uint16[this._pos2 + 8] } get textBoxStartIndex() { return this._structArray.uint16[this._pos2 + 9] } get textBoxEndIndex() { return this._structArray.uint16[this._pos2 + 10] } get verticalTextBoxStartIndex() { return this._structArray.uint16[this._pos2 + 11] } get verticalTextBoxEndIndex() { return this._structArray.uint16[this._pos2 + 12] } get iconBoxStartIndex() { return this._structArray.uint16[this._pos2 + 13] } get iconBoxEndIndex() { return this._structArray.uint16[this._pos2 + 14] } get verticalIconBoxStartIndex() { return this._structArray.uint16[this._pos2 + 15] } get verticalIconBoxEndIndex() { return this._structArray.uint16[this._pos2 + 16] } get featureIndex() { return this._structArray.uint16[this._pos2 + 17] } get numHorizontalGlyphVertices() { return this._structArray.uint16[this._pos2 + 18] } get numVerticalGlyphVertices() { return this._structArray.uint16[this._pos2 + 19] } get numIconVertices() { return this._structArray.uint16[this._pos2 + 20] } get numVerticalIconVertices() { return this._structArray.uint16[this._pos2 + 21] } get useRuntimeCollisionCircles() { return this._structArray.uint16[this._pos2 + 22] } get crossTileID() { return this._structArray.uint32[this._pos4 + 12] } set crossTileID(t) { this._structArray.uint32[this._pos4 + 12] = t } get textBoxScale() { return this._structArray.float32[this._pos4 + 13] } get collisionCircleDiameter() { return this._structArray.float32[this._pos4 + 14] } get textAnchorOffsetStartIndex() { return this._structArray.uint16[this._pos2 + 30] } get textAnchorOffsetEndIndex() { return this._structArray.uint16[this._pos2 + 31] } } w.prototype.size = 64; class I extends fa { get(t) { return new w(this, t) } } Je("SymbolInstanceArray", I); class E extends ma { getoffsetX(t) { return this.float32[1 * t + 0] } } Je("GlyphOffsetArray", E); class A extends ca { getx(t) { return this.int16[3 * t + 0] } gety(t) { return this.int16[3 * t + 1] } gettileUnitDistanceFromAnchor(t) { return this.int16[3 * t + 2] } } Je("SymbolLineVertexArray", A); class B extends dn { get textAnchor() { return this._structArray.uint16[this._pos2 + 0] } get textOffset0() { return this._structArray.float32[this._pos4 + 1] } get textOffset1() { return this._structArray.float32[this._pos4 + 2] } } B.prototype.size = 12; class j extends u { get(t) { return new B(this, t) } } Je("TextAnchorOffsetArray", j); class q extends dn { get featureIndex() { return this._structArray.uint32[this._pos4 + 0] } get sourceLayerIndex() { return this._structArray.uint16[this._pos2 + 2] } get bucketIndex() { return this._structArray.uint16[this._pos2 + 3] } } q.prototype.size = 8; class G extends e { get(t) { return new q(this, t) } } Je("FeatureIndexArray", G); class H extends ks { } class K extends ks { } class Q extends ks { } class ee extends gn { } class re extends ua { } class oe extends ts { } class ne extends ha { } class me extends ho { } class ge extends Ol { } class Se extends Ds { } class Ie extends jl { } class Pe extends rs { } class $e extends pa { } class Ue extends i { } const De = xi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: tt } = De; class st { constructor(t = []) { this._forceNewSegmentOnNextPrepare = !1, this.segments = t } prepareSegment(t, n, s, l) { const d = this.segments[this.segments.length - 1]; return t > st.MAX_VERTEX_ARRAY_LENGTH && Ui(`Max vertices per segment is ${st.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${st.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !d || d.vertexLength + t > st.MAX_VERTEX_ARRAY_LENGTH || d.sortKey !== l ? this.createNewSegment(n, s, l) : d } createNewSegment(t, n, s) { const l = { vertexOffset: t.length, primitiveOffset: n.length, vertexLength: 0, primitiveLength: 0, vaos: {} }; return s !== void 0 && (l.sortKey = s), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(l), l } getOrCreateLatestSegment(t, n, s) { return this.prepareSegment(0, t, n, s) } forceNewSegmentOnNextPrepare() { this._forceNewSegmentOnNextPrepare = !0 } get() { return this.segments } destroy() { for (const t of this.segments) for (const n in t.vaos) t.vaos[n].destroy() } static simpleSegment(t, n, s, l) { return new st([{ vertexOffset: t, primitiveOffset: n, vertexLength: s, primitiveLength: l, vaos: {}, sortKey: 0 }]) } } function Ot(r, t) { return 256 * (r = cr(Math.floor(r), 0, 255)) + cr(Math.floor(t), 0, 255) } st.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Je("SegmentVector", st); const Jt = xi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]); var $t, oi, ei, jt = { exports: {} }, Gt = { exports: {} }, Li = { exports: {} }, Fi = function () { if (ei) return jt.exports; ei = 1; var r = ($t || ($t = 1, Gt.exports = function (n, s) { var l, d, p, _, y, b, T, M; for (d = n.length - (l = 3 & n.length), p = s, y = 3432918353, b = 461845907, M = 0; M < d;)T = 255 & n.charCodeAt(M) | (255 & n.charCodeAt(++M)) << 8 | (255 & n.charCodeAt(++M)) << 16 | (255 & n.charCodeAt(++M)) << 24, ++M, p = 27492 + (65535 & (_ = 5 * (65535 & (p = (p ^= T = (65535 & (T = (T = (65535 & T) * y + (((T >>> 16) * y & 65535) << 16) & 4294967295) << 15 | T >>> 17)) * b + (((T >>> 16) * b & 65535) << 16) & 4294967295) << 13 | p >>> 19)) + ((5 * (p >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (_ >>> 16) & 65535) << 16); switch (T = 0, l) { case 3: T ^= (255 & n.charCodeAt(M + 2)) << 16; case 2: T ^= (255 & n.charCodeAt(M + 1)) << 8; case 1: p ^= T = (65535 & (T = (T = (65535 & (T ^= 255 & n.charCodeAt(M))) * y + (((T >>> 16) * y & 65535) << 16) & 4294967295) << 15 | T >>> 17)) * b + (((T >>> 16) * b & 65535) << 16) & 4294967295 }return p ^= n.length, p = 2246822507 * (65535 & (p ^= p >>> 16)) + ((2246822507 * (p >>> 16) & 65535) << 16) & 4294967295, p = 3266489909 * (65535 & (p ^= p >>> 13)) + ((3266489909 * (p >>> 16) & 65535) << 16) & 4294967295, (p ^= p >>> 16) >>> 0 }), Gt.exports), t = (oi || (oi = 1, Li.exports = function (n, s) { for (var l, d = n.length, p = s ^ d, _ = 0; d >= 4;)l = 1540483477 * (65535 & (l = 255 & n.charCodeAt(_) | (255 & n.charCodeAt(++_)) << 8 | (255 & n.charCodeAt(++_)) << 16 | (255 & n.charCodeAt(++_)) << 24)) + ((1540483477 * (l >>> 16) & 65535) << 16), p = 1540483477 * (65535 & p) + ((1540483477 * (p >>> 16) & 65535) << 16) ^ (l = 1540483477 * (65535 & (l ^= l >>> 24)) + ((1540483477 * (l >>> 16) & 65535) << 16)), d -= 4, ++_; switch (d) { case 3: p ^= (255 & n.charCodeAt(_ + 2)) << 16; case 2: p ^= (255 & n.charCodeAt(_ + 1)) << 8; case 1: p = 1540483477 * (65535 & (p ^= 255 & n.charCodeAt(_))) + ((1540483477 * (p >>> 16) & 65535) << 16) }return p = 1540483477 * (65535 & (p ^= p >>> 13)) + ((1540483477 * (p >>> 16) & 65535) << 16), (p ^= p >>> 15) >>> 0 }), Li.exports); return jt.exports = r, jt.exports.murmur3 = r, jt.exports.murmur2 = t, jt.exports }(), Ii = de(Fi); class qi { constructor() { this.ids = [], this.positions = [], this.indexed = !1 } add(t, n, s, l) { this.ids.push(kn(t)), this.positions.push(n, s, l) } getPositions(t) { if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed"); const n = kn(t); let s = 0, l = this.ids.length - 1; for (; s < l;) { const p = s + l >> 1; this.ids[p] >= n ? l = p : s = p + 1 } const d = []; for (; this.ids[s] === n;)d.push({ index: this.positions[3 * s], start: this.positions[3 * s + 1], end: this.positions[3 * s + 2] }), s++; return d } static serialize(t, n) { const s = new Float64Array(t.ids), l = new Uint32Array(t.positions); return yn(s, l, 0, s.length - 1), n && n.push(s.buffer, l.buffer), { ids: s, positions: l } } static deserialize(t) { const n = new qi; return n.ids = t.ids, n.positions = t.positions, n.indexed = !0, n } } function kn(r) { const t = +r; return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : Ii(String(r)) } function yn(r, t, n, s) { for (; n < s;) { const l = r[n + s >> 1]; let d = n - 1, p = s + 1; for (; ;) { do d++; while (r[d] < l); do p--; while (r[p] > l); if (d >= p) break; pn(r, d, p), pn(t, 3 * d, 3 * p), pn(t, 3 * d + 1, 3 * p + 1), pn(t, 3 * d + 2, 3 * p + 2) } p - n < s - p ? (yn(r, t, n, p), n = p + 1) : (yn(r, t, p + 1, s), s = p) } } function pn(r, t, n) { const s = r[t]; r[t] = r[n], r[n] = s } Je("FeaturePositionMap", qi); class Ur { constructor(t, n) { this.gl = t.gl, this.location = n } } class ns extends Ur { constructor(t, n) { super(t, n), this.current = 0 } set(t) { this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t)) } } class po extends Ur { constructor(t, n) { super(t, n), this.current = [0, 0, 0, 0] } set(t) { t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3])) } } class ss extends Ur { constructor(t, n) { super(t, n), this.current = Lt.transparent } set(t) { t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a)) } } const $r = new Float32Array(16); function fn(r) { return [Ot(255 * r.r, 255 * r.g), Ot(255 * r.b, 255 * r.a)] } class Jr { constructor(t, n, s) { this.value = t, this.uniformNames = n.map(l => `u_${l}`), this.type = s } setUniform(t, n, s) { t.set(s.constantOr(this.value)) } getBinding(t, n, s) { return this.type === "color" ? new ss(t, n) : new ns(t, n) } } class mn { constructor(t, n) { this.uniformNames = n.map(s => `u_${s}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1 } setConstantPatternPositions(t, n) { this.pixelRatioFrom = n.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = n.tlbr, this.patternTo = t.tlbr } setUniform(t, n, s, l) { const d = l === "u_pattern_to" ? this.patternTo : l === "u_pattern_from" ? this.patternFrom : l === "u_pixel_ratio_to" ? this.pixelRatioTo : l === "u_pixel_ratio_from" ? this.pixelRatioFrom : null; d && t.set(d) } getBinding(t, n, s) { return s.substr(0, 9) === "u_pattern" ? new po(t, n) : new ns(t, n) } } class Yt { constructor(t, n, s, l) { this.expression = t, this.type = s, this.maxValue = 0, this.paintVertexAttributes = n.map(d => ({ name: `a_${d}`, type: "Float32", components: s === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new l } populatePaintArray(t, n, s, l, d) { const p = this.paintVertexArray.length, _ = this.expression.evaluate(new si(0), n, {}, l, [], d); this.paintVertexArray.resize(t), this._setPaintValue(p, t, _) } updatePaintArray(t, n, s, l) { const d = this.expression.evaluate({ zoom: 0 }, s, l); this._setPaintValue(t, n, d) } _setPaintValue(t, n, s) { if (this.type === "color") { const l = fn(s); for (let d = t; d < n; d++)this.paintVertexArray.emplace(d, l[0], l[1]) } else { for (let l = t; l < n; l++)this.paintVertexArray.emplace(l, s); this.maxValue = Math.max(this.maxValue, Math.abs(s)) } } upload(t) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) } destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy() } } class Xt { constructor(t, n, s, l, d, p) { this.expression = t, this.uniformNames = n.map(_ => `u_${_}_t`), this.type = s, this.useIntegerZoom = l, this.zoom = d, this.maxValue = 0, this.paintVertexAttributes = n.map(_ => ({ name: `a_${_}`, type: "Float32", components: s === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new p } populatePaintArray(t, n, s, l, d) { const p = this.expression.evaluate(new si(this.zoom), n, {}, l, [], d), _ = this.expression.evaluate(new si(this.zoom + 1), n, {}, l, [], d), y = this.paintVertexArray.length; this.paintVertexArray.resize(t), this._setPaintValue(y, t, p, _) } updatePaintArray(t, n, s, l) { const d = this.expression.evaluate({ zoom: this.zoom }, s, l), p = this.expression.evaluate({ zoom: this.zoom + 1 }, s, l); this._setPaintValue(t, n, d, p) } _setPaintValue(t, n, s, l) { if (this.type === "color") { const d = fn(s), p = fn(l); for (let _ = t; _ < n; _++)this.paintVertexArray.emplace(_, d[0], d[1], p[0], p[1]) } else { for (let d = t; d < n; d++)this.paintVertexArray.emplace(d, s, l); this.maxValue = Math.max(this.maxValue, Math.abs(s), Math.abs(l)) } } upload(t) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)) } destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy() } setUniform(t, n) { const s = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom, l = cr(this.expression.interpolationFactor(s, this.zoom, this.zoom + 1), 0, 1); t.set(l) } getBinding(t, n, s) { return new ns(t, n) } } class Ci { constructor(t, n, s, l, d, p) { this.expression = t, this.type = n, this.useIntegerZoom = s, this.zoom = l, this.layerId = p, this.zoomInPaintVertexArray = new d, this.zoomOutPaintVertexArray = new d } populatePaintArray(t, n, s) { const l = this.zoomInPaintVertexArray.length; this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(l, t, n.patterns && n.patterns[this.layerId], s) } updatePaintArray(t, n, s, l, d) { this._setPaintValues(t, n, s.patterns && s.patterns[this.layerId], d) } _setPaintValues(t, n, s, l) { if (!l || !s) return; const { min: d, mid: p, max: _ } = s, y = l[d], b = l[p], T = l[_]; if (y && b && T) for (let M = t; M < n; M++)this.zoomInPaintVertexArray.emplace(M, b.tl[0], b.tl[1], b.br[0], b.br[1], y.tl[0], y.tl[1], y.br[0], y.br[1], b.pixelRatio, y.pixelRatio), this.zoomOutPaintVertexArray.emplace(M, b.tl[0], b.tl[1], b.br[0], b.br[1], T.tl[0], T.tl[1], T.br[0], T.br[1], b.pixelRatio, T.pixelRatio) } upload(t) { this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, Jt.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, Jt.members, this.expression.isStateDependent)) } destroy() { this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy() } } class Ei { constructor(t, n, s) { this.binders = {}, this._buffers = []; const l = []; for (const d in t.paint._values) { if (!s(d)) continue; const p = t.paint.get(d); if (!(p instanceof Zr && Ps(p.property.specification))) continue; const _ = Eh(d, t.type), y = p.value, b = p.property.specification.type, T = p.property.useIntegerZoom, M = p.property.specification["property-type"], k = M === "cross-faded" || M === "cross-faded-data-driven"; if (y.kind === "constant") this.binders[d] = k ? new mn(y.value, _) : new Jr(y.value, _, b), l.push(`/u_${d}`); else if (y.kind === "source" || k) { const R = _u(d, b, "source"); this.binders[d] = k ? new Ci(y, b, T, n, R, t.id) : new Yt(y, _, b, R), l.push(`/a_${d}`) } else { const R = _u(d, b, "composite"); this.binders[d] = new Xt(y, _, b, T, n, R), l.push(`/z_${d}`) } } this.cacheKey = l.sort().join("") } getMaxValue(t) { const n = this.binders[t]; return n instanceof Yt || n instanceof Xt ? n.maxValue : 0 } populatePaintArrays(t, n, s, l, d) { for (const p in this.binders) { const _ = this.binders[p]; (_ instanceof Yt || _ instanceof Xt || _ instanceof Ci) && _.populatePaintArray(t, n, s, l, d) } } setConstantPatternPositions(t, n) { for (const s in this.binders) { const l = this.binders[s]; l instanceof mn && l.setConstantPatternPositions(t, n) } } updatePaintArrays(t, n, s, l, d) { let p = !1; for (const _ in t) { const y = n.getPositions(_); for (const b of y) { const T = s.feature(b.index); for (const M in this.binders) { const k = this.binders[M]; if ((k instanceof Yt || k instanceof Xt || k instanceof Ci) && k.expression.isStateDependent === !0) { const R = l.paint.get(M); k.expression = R.value, k.updatePaintArray(b.start, b.end, T, t[_], d), p = !0 } } } } return p } defines() { const t = []; for (const n in this.binders) { const s = this.binders[n]; (s instanceof Jr || s instanceof mn) && t.push(...s.uniformNames.map(l => `#define HAS_UNIFORM_${l}`)) } return t } getBinderAttributes() { const t = []; for (const n in this.binders) { const s = this.binders[n]; if (s instanceof Yt || s instanceof Xt) for (let l = 0; l < s.paintVertexAttributes.length; l++)t.push(s.paintVertexAttributes[l].name); else if (s instanceof Ci) for (let l = 0; l < Jt.members.length; l++)t.push(Jt.members[l].name) } return t } getBinderUniforms() { const t = []; for (const n in this.binders) { const s = this.binders[n]; if (s instanceof Jr || s instanceof mn || s instanceof Xt) for (const l of s.uniformNames) t.push(l) } return t } getPaintVertexBuffers() { return this._buffers } getUniforms(t, n) { const s = []; for (const l in this.binders) { const d = this.binders[l]; if (d instanceof Jr || d instanceof mn || d instanceof Xt) { for (const p of d.uniformNames) if (n[p]) { const _ = d.getBinding(t, n[p], p); s.push({ name: p, property: l, binding: _ }) } } } return s } setUniforms(t, n, s, l) { for (const { name: d, property: p, binding: _ } of n) this.binders[p].setUniform(_, l, s.get(p), d) } updatePaintBuffers(t) { this._buffers = []; for (const n in this.binders) { const s = this.binders[n]; if (t && s instanceof Ci) { const l = t.fromScale === 2 ? s.zoomInPaintVertexBuffer : s.zoomOutPaintVertexBuffer; l && this._buffers.push(l) } else (s instanceof Yt || s instanceof Xt) && s.paintVertexBuffer && this._buffers.push(s.paintVertexBuffer) } } upload(t) { for (const n in this.binders) { const s = this.binders[n]; (s instanceof Yt || s instanceof Xt || s instanceof Ci) && s.upload(t) } this.updatePaintBuffers() } destroy() { for (const t in this.binders) { const n = this.binders[t]; (n instanceof Yt || n instanceof Xt || n instanceof Ci) && n.destroy() } } } class os { constructor(t, n, s = () => !0) { this.programConfigurations = {}; for (const l of t) this.programConfigurations[l.id] = new Ei(l, n, s); this.needsUpload = !1, this._featureMap = new qi, this._bufferOffset = 0 } populatePaintArrays(t, n, s, l, d, p) { for (const _ in this.programConfigurations) this.programConfigurations[_].populatePaintArrays(t, n, l, d, p); n.id !== void 0 && this._featureMap.add(n.id, s, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0 } updatePaintArrays(t, n, s, l) { for (const d of s) this.needsUpload = this.programConfigurations[d.id].updatePaintArrays(t, this._featureMap, n, d, l) || this.needsUpload } get(t) { return this.programConfigurations[t] } upload(t) { if (this.needsUpload) { for (const n in this.programConfigurations) this.programConfigurations[n].upload(t); this.needsUpload = !1 } } destroy() { for (const t in this.programConfigurations) this.programConfigurations[t].destroy() } } function Eh(r, t) { return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[r] || [r.replace(`${t}-`, "").replace(/-/g, "_")] } function _u(r, t, n) { const s = { color: { source: ts, composite: a }, number: { source: ma, composite: ts } }, l = function (d) { return { "line-pattern": { source: ne, composite: ne }, "fill-pattern": { source: ne, composite: ne }, "fill-extrusion-pattern": { source: ne, composite: ne } }[d] }(r); return l && l[n] || s[t][n] } Je("ConstantBinder", Jr), Je("CrossFadedConstantBinder", mn), Je("SourceExpressionBinder", Yt), Je("CrossFadedCompositeBinder", Ci), Je("CompositeExpressionBinder", Xt), Je("ProgramConfiguration", Ei, { omit: ["_buffers"] }), Je("ProgramConfigurationSet", os); const Nl = Math.pow(2, 14) - 1, gu = -Nl - 1; function as(r) { const t = gt / r.extent, n = r.loadGeometry(); for (let s = 0; s < n.length; s++) { const l = n[s]; for (let d = 0; d < l.length; d++) { const p = l[d], _ = Math.round(p.x * t), y = Math.round(p.y * t); p.x = cr(_, gu, Nl), p.y = cr(y, gu, Nl), (_ < p.x || _ > p.x + 1 || y < p.y || y > p.y + 1) && Ui("Geometry exceeds allowed extent, reduce your vector tile buffer size") } } return n } function Tr(r, t) { return { type: r.type, id: r.id, properties: r.properties, geometry: t ? as(r) : [] } } const Zl = -32768; function yu(r, t, n, s, l) { r.emplaceBack(Zl + 8 * t + s, Zl + 8 * n + l) } class _a { constructor(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(n => n.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new K, this.indexArray = new $e, this.segments = new st, this.programConfigurations = new os(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(n => n.isStateDependent()).map(n => n.id) } populate(t, n, s) { const l = this.layers[0], d = []; let p = null, _ = !1, y = l.type === "heatmap"; if (l.type === "circle") { const T = l; p = T.layout.get("circle-sort-key"), _ = !p.isConstant(), y = y || T.paint.get("circle-pitch-alignment") === "map" } const b = y ? n.subdivisionGranularity.circle : 1; for (const { feature: T, id: M, index: k, sourceLayerIndex: R } of t) { const L = this.layers[0]._featureFilter.needGeometry, O = Tr(T, L); if (!this.layers[0]._featureFilter.filter(new si(this.zoom), O, s)) continue; const U = _ ? p.evaluate(O, {}, s) : void 0, W = { id: M, properties: T.properties, type: T.type, sourceLayerIndex: R, index: k, geometry: L ? O.geometry : as(T), patterns: {}, sortKey: U }; d.push(W) } _ && d.sort((T, M) => T.sortKey - M.sortKey); for (const T of d) { const { geometry: M, index: k, sourceLayerIndex: R } = T, L = t[k].feature; this.addFeature(T, M, k, s, b), n.featureIndex.insert(L, M, k, R, this.index) } } update(t, n, s) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s) } isEmpty() { return this.layoutVertexArray.length === 0 } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, tt), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) } addFeature(t, n, s, l, d = 1) { let p; switch (d) { case 1: p = [0, 7]; break; case 3: p = [0, 2, 5, 7]; break; case 5: p = [0, 1, 3, 4, 6, 7]; break; case 7: p = [0, 1, 2, 3, 4, 5, 6, 7]; break; default: throw new Error(`Invalid circle bucket granularity: ${d}; valid values are 1, 3, 5, 7.`) }const _ = p.length; for (const y of n) for (const b of y) { const T = b.x, M = b.y; if (T < 0 || T >= gt || M < 0 || M >= gt) continue; const k = this.segments.prepareSegment(_ * _, this.layoutVertexArray, this.indexArray, t.sortKey), R = k.vertexLength; for (let L = 0; L < _; L++)for (let O = 0; O < _; O++)yu(this.layoutVertexArray, T, M, p[O], p[L]); for (let L = 0; L < _ - 1; L++)for (let O = 0; O < _ - 1; O++) { const U = R + L * _ + O, W = R + (L + 1) * _ + O; this.indexArray.emplaceBack(U, W + 1, U + 1), this.indexArray.emplaceBack(U, W, W + 1) } k.vertexLength += _ * _, k.primitiveLength += (_ - 1) * (_ - 1) * 2 } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, {}, l) } } function ga(r, t) { for (let n = 0; n < r.length; n++)if (xa(t, r[n])) return !0; for (let n = 0; n < t.length; n++)if (xa(r, t[n])) return !0; return !!Ah(r, t) } function xu(r, t, n) { return !!xa(r, t) || !!zh(t, r, n) } function ya(r, t) { if (r.length === 1) return op(t, r[0]); for (let n = 0; n < t.length; n++) { const s = t[n]; for (let l = 0; l < s.length; l++)if (xa(r, s[l])) return !0 } for (let n = 0; n < r.length; n++)if (op(t, r[n])) return !0; for (let n = 0; n < t.length; n++)if (Ah(r, t[n])) return !0; return !1 } function x_(r, t, n) { if (r.length > 1) { if (Ah(r, t)) return !0; for (let s = 0; s < t.length; s++)if (zh(t[s], r, n)) return !0 } for (let s = 0; s < r.length; s++)if (zh(r[s], t, n)) return !0; return !1 } function Ah(r, t) { if (r.length === 0 || t.length === 0) return !1; for (let n = 0; n < r.length - 1; n++) { const s = r[n], l = r[n + 1]; for (let d = 0; d < t.length - 1; d++)if (v_(s, l, t[d], t[d + 1])) return !0 } return !1 } function v_(r, t, n, s) { return te(r, n, s) !== te(t, n, s) && te(r, t, n) !== te(r, t, s) } function zh(r, t, n) { const s = n * n; if (t.length === 1) return r.distSqr(t[0]) < s; for (let l = 1; l < t.length; l++)if (sp(r, t[l - 1], t[l]) < s) return !0; return !1 } function sp(r, t, n) { const s = t.distSqr(n); if (s === 0) return r.distSqr(t); const l = ((r.x - t.x) * (n.x - t.x) + (r.y - t.y) * (n.y - t.y)) / s; return r.distSqr(l < 0 ? t : l > 1 ? n : n.sub(t)._mult(l)._add(t)) } function op(r, t) { let n, s, l, d = !1; for (let p = 0; p < r.length; p++) { n = r[p]; for (let _ = 0, y = n.length - 1; _ < n.length; y = _++)s = n[_], l = n[y], s.y > t.y != l.y > t.y && t.x < (l.x - s.x) * (t.y - s.y) / (l.y - s.y) + s.x && (d = !d) } return d } function xa(r, t) { let n = !1; for (let s = 0, l = r.length - 1; s < r.length; l = s++) { const d = r[s], p = r[l]; d.y > t.y != p.y > t.y && t.x < (p.x - d.x) * (t.y - d.y) / (p.y - d.y) + d.x && (n = !n) } return n } function b_(r, t, n) { const s = n[0], l = n[2]; if (r.x < s.x && t.x < s.x || r.x > l.x && t.x > l.x || r.y < s.y && t.y < s.y || r.y > l.y && t.y > l.y) return !1; const d = te(r, t, n[0]); return d !== te(r, t, n[1]) || d !== te(r, t, n[2]) || d !== te(r, t, n[3]) } function Ul(r, t, n) { const s = t.paint.get(r).value; return s.kind === "constant" ? s.value : n.programConfigurations.get(t.id).getMaxValue(r) } function vu(r) { return Math.sqrt(r[0] * r[0] + r[1] * r[1]) } function bu(r, t, n, s, l) { if (!t[0] && !t[1]) return r; const d = Ge.convert(t)._mult(l); n === "viewport" && d._rotate(-s); const p = []; for (let _ = 0; _ < r.length; _++)p.push(r[_].sub(d)); return p } let ap, lp; Je("CircleBucket", _a, { omit: ["layers"] }); var w_ = { get paint() { return lp = lp || new mr({ "circle-radius": new ht(C.paint_circle["circle-radius"]), "circle-color": new ht(C.paint_circle["circle-color"]), "circle-blur": new ht(C.paint_circle["circle-blur"]), "circle-opacity": new ht(C.paint_circle["circle-opacity"]), "circle-translate": new nt(C.paint_circle["circle-translate"]), "circle-translate-anchor": new nt(C.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new nt(C.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new nt(C.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ht(C.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ht(C.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ht(C.paint_circle["circle-stroke-opacity"]) }) }, get layout() { return ap = ap || new mr({ "circle-sort-key": new ht(C.layout_circle["circle-sort-key"]) }) } }; class T_ extends hn { constructor(t) { super(t, w_) } createBucket(t) { return new _a(t) } queryRadius(t) { const n = t; return Ul("circle-radius", this, n) + Ul("circle-stroke-width", this, n) + vu(this.paint.get("circle-translate")) } queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: s, geometry: l, transform: d, pixelsToTileUnits: p, pixelPosMatrix: _ }) { const y = bu(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -d.bearingInRadians, p), b = this.paint.get("circle-radius").evaluate(n, s) + this.paint.get("circle-stroke-width").evaluate(n, s), T = this.paint.get("circle-pitch-alignment") === "map", M = T ? y : function (R, L) { return R.map(O => cp(O, L)) }(y, _), k = T ? b * p : b; for (const R of l) for (const L of R) { const O = T ? L : cp(L, _); let U = k; const W = ar([], [L.x, L.y, 0, 1], _); if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? U *= W[3] / d.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (U *= d.cameraToCenterDistance / W[3]), xu(M, O, U)) return !0 } return !1 } } function cp(r, t) { const n = ar([], [r.x, r.y, 0, 1], t); return new Ge(n[0] / n[3], n[1] / n[3]) } class up extends _a { } let hp; Je("HeatmapBucket", up, { omit: ["layers"] }); var P_ = { get paint() { return hp = hp || new mr({ "heatmap-radius": new ht(C.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ht(C.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new nt(C.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Fl(C.paint_heatmap["heatmap-color"]), "heatmap-opacity": new nt(C.paint_heatmap["heatmap-opacity"]) }) } }; function kh(r, { width: t, height: n }, s, l) { if (l) { if (l instanceof Uint8ClampedArray) l = new Uint8Array(l.buffer); else if (l.length !== t * n * s) throw new RangeError(`mismatched image size. expected: ${l.length} but got: ${t * n * s}`) } else l = new Uint8Array(t * n * s); return r.width = t, r.height = n, r.data = l, r } function dp(r, { width: t, height: n }, s) { if (t === r.width && n === r.height) return; const l = kh({}, { width: t, height: n }, s); Dh(r, l, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r.width, t), height: Math.min(r.height, n) }, s), r.width = t, r.height = n, r.data = l.data } function Dh(r, t, n, s, l, d) { if (l.width === 0 || l.height === 0) return t; if (l.width > r.width || l.height > r.height || n.x > r.width - l.width || n.y > r.height - l.height) throw new RangeError("out of range source coordinates for image copy"); if (l.width > t.width || l.height > t.height || s.x > t.width - l.width || s.y > t.height - l.height) throw new RangeError("out of range destination coordinates for image copy"); const p = r.data, _ = t.data; if (p === _) throw new Error("srcData equals dstData, so image is already copied"); for (let y = 0; y < l.height; y++) { const b = ((n.y + y) * r.width + n.x) * d, T = ((s.y + y) * t.width + s.x) * d; for (let M = 0; M < l.width * d; M++)_[T + M] = p[b + M] } return t } class $l { constructor(t, n) { kh(this, t, 1, n) } resize(t) { dp(this, t, 1) } clone() { return new $l({ width: this.width, height: this.height }, new Uint8Array(this.data)) } static copy(t, n, s, l, d) { Dh(t, n, s, l, d, 1) } } class Yr { constructor(t, n) { kh(this, t, 4, n) } resize(t) { dp(this, t, 4) } replace(t, n) { n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t } clone() { return new Yr({ width: this.width, height: this.height }, new Uint8Array(this.data)) } static copy(t, n, s, l, d) { Dh(t, n, s, l, d, 4) } } function pp(r) { const t = {}, n = r.resolution || 256, s = r.clips ? r.clips.length : 1, l = r.image || new Yr({ width: n, height: s }); if (Math.log(n) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${n}`); const d = (p, _, y) => { t[r.evaluationKey] = y; const b = r.expression.evaluate(t); l.data[p + _ + 0] = Math.floor(255 * b.r / b.a), l.data[p + _ + 1] = Math.floor(255 * b.g / b.a), l.data[p + _ + 2] = Math.floor(255 * b.b / b.a), l.data[p + _ + 3] = Math.floor(255 * b.a) }; if (r.clips) for (let p = 0, _ = 0; p < s; ++p, _ += 4 * n)for (let y = 0, b = 0; y < n; y++, b += 4) { const T = y / (n - 1), { start: M, end: k } = r.clips[p]; d(_, b, M * (1 - T) + k * T) } else for (let p = 0, _ = 0; p < n; p++, _ += 4)d(0, _, p / (n - 1)); return l } Je("AlphaImage", $l), Je("RGBAImage", Yr); const Rh = "big-fb"; class S_ extends hn { createBucket(t) { return new up(t) } constructor(t) { super(t, P_), this.heatmapFbos = new Map, this._updateColorRamp() } _handleSpecialPaintPropertyUpdate(t) { t === "heatmap-color" && this._updateColorRamp() } _updateColorRamp() { this.colorRamp = pp({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null } resize() { this.heatmapFbos.has(Rh) && this.heatmapFbos.delete(Rh) } queryRadius() { return 0 } queryIntersectsFeature() { return !1 } hasOffscreenPass() { return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none" } } let fp; var M_ = { get paint() { return fp = fp || new mr({ "hillshade-illumination-direction": new nt(C.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new nt(C.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new nt(C.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new nt(C.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new nt(C.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new nt(C.paint_hillshade["hillshade-accent-color"]) }) } }; class I_ extends hn { constructor(t) { super(t, M_) } hasOffscreenPass() { return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none" } } const C_ = xi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: E_ } = C_; function Lh(r, t, n) { const s = n.patternDependencies; let l = !1; for (const d of t) { const p = d.paint.get(`${r}-pattern`); p.isConstant() || (l = !0); const _ = p.constantOr(null); _ && (l = !0, s[_.to] = !0, s[_.from] = !0) } return l } function Fh(r, t, n, s, l) { const d = l.patternDependencies; for (const p of t) { const _ = p.paint.get(`${r}-pattern`).value; if (_.kind !== "constant") { let y = _.evaluate({ zoom: s - 1 }, n, {}, l.availableImages), b = _.evaluate({ zoom: s }, n, {}, l.availableImages), T = _.evaluate({ zoom: s + 1 }, n, {}, l.availableImages); y = y && y.name ? y.name : y, b = b && b.name ? b.name : b, T = T && T.name ? T.name : T, d[y] = !0, d[b] = !0, d[T] = !0, n.patterns[p.id] = { min: y, mid: b, max: T } } } return n } function mp(r, t, n, s, l) { let d; if (l === function (p, _, y, b) { let T = 0; for (let M = _, k = y - b; M < y; M += b)T += (p[k] - p[M]) * (p[M + 1] + p[k + 1]), k = M; return T }(r, t, n, s) > 0) for (let p = t; p < n; p += s)d = xp(p / s | 0, r[p], r[p + 1], d); else for (let p = n - s; p >= t; p -= s)d = xp(p / s | 0, r[p], r[p + 1], d); return d && va(d, d.next) && (Wl(d), d = d.next), d } function fo(r, t) { if (!r) return r; t || (t = r); let n, s = r; do if (n = !1, s.steiner || !va(s, s.next) && vi(s.prev, s, s.next) !== 0) s = s.next; else { if (Wl(s), s = t = s.prev, s === s.next) break; n = !0 } while (n || s !== t); return t } function Gl(r, t, n, s, l, d, p) { if (!r) return; !p && d && function (y, b, T, M) { let k = y; do k.z === 0 && (k.z = Bh(k.x, k.y, b, T, M)), k.prevZ = k.prev, k.nextZ = k.next, k = k.next; while (k !== y); k.prevZ.nextZ = null, k.prevZ = null, function (R) { let L, O = 1; do { let U, W = R; R = null; let se = null; for (L = 0; W;) { L++; let J = W, D = 0; for (let Y = 0; Y < O && (D++, J = J.nextZ, J); Y++); let N = O; for (; D > 0 || N > 0 && J;)D !== 0 && (N === 0 || !J || W.z <= J.z) ? (U = W, W = W.nextZ, D--) : (U = J, J = J.nextZ, N--), se ? se.nextZ = U : R = U, U.prevZ = se, se = U; W = J } se.nextZ = null, O *= 2 } while (L > 1) }(k) }(r, s, l, d); let _ = r; for (; r.prev !== r.next;) { const y = r.prev, b = r.next; if (d ? z_(r, s, l, d) : A_(r)) t.push(y.i, r.i, b.i), Wl(r), r = b.next, _ = b.next; else if ((r = b) === _) { p ? p === 1 ? Gl(r = k_(fo(r), t), t, n, s, l, d, 2) : p === 2 && D_(r, t, n, s, l, d) : Gl(fo(r), t, n, s, l, d, 1); break } } } function A_(r) { const t = r.prev, n = r, s = r.next; if (vi(t, n, s) >= 0) return !1; const l = t.x, d = n.x, p = s.x, _ = t.y, y = n.y, b = s.y, T = Math.min(l, d, p), M = Math.min(_, y, b), k = Math.max(l, d, p), R = Math.max(_, y, b); let L = s.next; for (; L !== t;) { if (L.x >= T && L.x <= k && L.y >= M && L.y <= R && ql(l, _, d, y, p, b, L.x, L.y) && vi(L.prev, L, L.next) >= 0) return !1; L = L.next } return !0 } function z_(r, t, n, s) { const l = r.prev, d = r, p = r.next; if (vi(l, d, p) >= 0) return !1; const _ = l.x, y = d.x, b = p.x, T = l.y, M = d.y, k = p.y, R = Math.min(_, y, b), L = Math.min(T, M, k), O = Math.max(_, y, b), U = Math.max(T, M, k), W = Bh(R, L, t, n, s), se = Bh(O, U, t, n, s); let J = r.prevZ, D = r.nextZ; for (; J && J.z >= W && D && D.z <= se;) { if (J.x >= R && J.x <= O && J.y >= L && J.y <= U && J !== l && J !== p && ql(_, T, y, M, b, k, J.x, J.y) && vi(J.prev, J, J.next) >= 0 || (J = J.prevZ, D.x >= R && D.x <= O && D.y >= L && D.y <= U && D !== l && D !== p && ql(_, T, y, M, b, k, D.x, D.y) && vi(D.prev, D, D.next) >= 0)) return !1; D = D.nextZ } for (; J && J.z >= W;) { if (J.x >= R && J.x <= O && J.y >= L && J.y <= U && J !== l && J !== p && ql(_, T, y, M, b, k, J.x, J.y) && vi(J.prev, J, J.next) >= 0) return !1; J = J.prevZ } for (; D && D.z <= se;) { if (D.x >= R && D.x <= O && D.y >= L && D.y <= U && D !== l && D !== p && ql(_, T, y, M, b, k, D.x, D.y) && vi(D.prev, D, D.next) >= 0) return !1; D = D.nextZ } return !0 } function k_(r, t) { let n = r; do { const s = n.prev, l = n.next.next; !va(s, l) && gp(s, n, n.next, l) && Hl(s, l) && Hl(l, s) && (t.push(s.i, n.i, l.i), Wl(n), Wl(n.next), n = r = l), n = n.next } while (n !== r); return fo(n) } function D_(r, t, n, s, l, d) { let p = r; do { let _ = p.next.next; for (; _ !== p.prev;) { if (p.i !== _.i && O_(p, _)) { let y = yp(p, _); return p = fo(p, p.next), y = fo(y, y.next), Gl(p, t, n, s, l, d, 0), void Gl(y, t, n, s, l, d, 0) } _ = _.next } p = p.next } while (p !== r) } function R_(r, t) { let n = r.x - t.x; return n === 0 && (n = r.y - t.y, n === 0) && (n = (r.next.y - r.y) / (r.next.x - r.x) - (t.next.y - t.y) / (t.next.x - t.x)), n } function L_(r, t) { const n = function (l, d) { let p = d; const _ = l.x, y = l.y; let b, T = -1 / 0; if (va(l, p)) return p; do { if (va(l, p.next)) return p.next; if (y <= p.y && y >= p.next.y && p.next.y !== p.y) { const O = p.x + (y - p.y) * (p.next.x - p.x) / (p.next.y - p.y); if (O <= _ && O > T && (T = O, b = p.x < p.next.x ? p : p.next, O === _)) return b } p = p.next } while (p !== d); if (!b) return null; const M = b, k = b.x, R = b.y; let L = 1 / 0; p = b; do { if (_ >= p.x && p.x >= k && _ !== p.x && _p(y < R ? _ : T, y, k, R, y < R ? T : _, y, p.x, p.y)) { const O = Math.abs(y - p.y) / (_ - p.x); Hl(p, l) && (O < L || O === L && (p.x > b.x || p.x === b.x && F_(b, p))) && (b = p, L = O) } p = p.next } while (p !== M); return b }(r, t); if (!n) return t; const s = yp(n, r); return fo(s, s.next), fo(n, n.next) } function F_(r, t) { return vi(r.prev, r, t.prev) < 0 && vi(t.next, r, r.next) < 0 } function Bh(r, t, n, s, l) { return (r = 1431655765 & ((r = 858993459 & ((r = 252645135 & ((r = 16711935 & ((r = (r - n) * l | 0) | r << 8)) | r << 4)) | r << 2)) | r << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - s) * l | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function B_(r) { let t = r, n = r; do (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next; while (t !== r); return n } function _p(r, t, n, s, l, d, p, _) { return (l - p) * (t - _) >= (r - p) * (d - _) && (r - p) * (s - _) >= (n - p) * (t - _) && (n - p) * (d - _) >= (l - p) * (s - _) } function ql(r, t, n, s, l, d, p, _) { return !(r === p && t === _) && _p(r, t, n, s, l, d, p, _) } function O_(r, t) { return r.next.i !== t.i && r.prev.i !== t.i && !function (n, s) { let l = n; do { if (l.i !== n.i && l.next.i !== n.i && l.i !== s.i && l.next.i !== s.i && gp(l, l.next, n, s)) return !0; l = l.next } while (l !== n); return !1 }(r, t) && (Hl(r, t) && Hl(t, r) && function (n, s) { let l = n, d = !1; const p = (n.x + s.x) / 2, _ = (n.y + s.y) / 2; do l.y > _ != l.next.y > _ && l.next.y !== l.y && p < (l.next.x - l.x) * (_ - l.y) / (l.next.y - l.y) + l.x && (d = !d), l = l.next; while (l !== n); return d }(r, t) && (vi(r.prev, r, t.prev) || vi(r, t.prev, t)) || va(r, t) && vi(r.prev, r, r.next) > 0 && vi(t.prev, t, t.next) > 0) } function vi(r, t, n) { return (t.y - r.y) * (n.x - t.x) - (t.x - r.x) * (n.y - t.y) } function va(r, t) { return r.x === t.x && r.y === t.y } function gp(r, t, n, s) { const l = Tu(vi(r, t, n)), d = Tu(vi(r, t, s)), p = Tu(vi(n, s, r)), _ = Tu(vi(n, s, t)); return l !== d && p !== _ || !(l !== 0 || !wu(r, n, t)) || !(d !== 0 || !wu(r, s, t)) || !(p !== 0 || !wu(n, r, s)) || !(_ !== 0 || !wu(n, t, s)) } function wu(r, t, n) { return t.x <= Math.max(r.x, n.x) && t.x >= Math.min(r.x, n.x) && t.y <= Math.max(r.y, n.y) && t.y >= Math.min(r.y, n.y) } function Tu(r) { return r > 0 ? 1 : r < 0 ? -1 : 0 } function Hl(r, t) { return vi(r.prev, r, r.next) < 0 ? vi(r, t, r.next) >= 0 && vi(r, r.prev, t) >= 0 : vi(r, t, r.prev) < 0 || vi(r, r.next, t) < 0 } function yp(r, t) { const n = Oh(r.i, r.x, r.y), s = Oh(t.i, t.x, t.y), l = r.next, d = t.prev; return r.next = t, t.prev = r, n.next = l, l.prev = n, s.next = n, n.prev = s, d.next = s, s.prev = d, s } function xp(r, t, n, s) { const l = Oh(r, t, n); return s ? (l.next = s.next, l.prev = s, s.next.prev = l, s.next = l) : (l.prev = l, l.next = l), l } function Wl(r) { r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ) } function Oh(r, t, n) { return { i: r, x: t, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 } } class ba { constructor(t, n) { if (n > t) throw new Error("Min granularity must not be greater than base granularity."); this._baseZoomGranularity = t, this._minGranularity = n } getGranularityForZoomLevel(t) { return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1) } } class Pu { constructor(t) { this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle } } Pu.noSubdivision = new Pu({ fill: new ba(0, 0), line: new ba(0, 0), tile: new ba(0, 0), stencil: new ba(0, 0), circle: 1 }), Je("SubdivisionGranularityExpression", ba), Je("SubdivisionGranularitySetting", Pu); const wa = -32768, Xl = 32767; class j_ { constructor(t, n) { this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = gt / t, this._canonical = n } _getKey(t, n) { return (t += 32768) << 16 | (n += 32768) << 0 } _vertexToIndex(t, n) { if (t < -32768 || n < -32768 || t > 32767 || n > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range."); const s = 0 | Math.round(t), l = 0 | Math.round(n), d = this._getKey(s, l); if (this._vertexDictionary.has(d)) return this._vertexDictionary.get(d); const p = this._vertexBuffer.length / 2; return this._vertexDictionary.set(d, p), this._vertexBuffer.push(s, l), p } _subdivideTrianglesScanline(t) { if (this._granularity < 2) return function (l, d) { const p = []; for (let _ = 0; _ < d.length; _ += 3) { const y = d[_], b = d[_ + 1], T = d[_ + 2], M = l[2 * y], k = l[2 * y + 1]; (l[2 * b] - M) * (l[2 * T + 1] - k) - (l[2 * b + 1] - k) * (l[2 * T] - M) > 0 ? (p.push(y), p.push(T), p.push(b)) : (p.push(y), p.push(b), p.push(T)) } return p }(this._vertexBuffer, t); const n = [], s = t.length; for (let l = 0; l < s; l += 3) { const d = [t[l + 0], t[l + 1], t[l + 2]], p = [this._vertexBuffer[2 * t[l + 0] + 0], this._vertexBuffer[2 * t[l + 0] + 1], this._vertexBuffer[2 * t[l + 1] + 0], this._vertexBuffer[2 * t[l + 1] + 1], this._vertexBuffer[2 * t[l + 2] + 0], this._vertexBuffer[2 * t[l + 2] + 1]]; let _ = 1 / 0, y = 1 / 0, b = -1 / 0, T = -1 / 0; for (let O = 0; O < 3; O++) { const U = p[2 * O], W = p[2 * O + 1]; _ = Math.min(_, U), b = Math.max(b, U), y = Math.min(y, W), T = Math.max(T, W) } if (_ === b || y === T) continue; const M = Math.floor(_ / this._granularityCellSize), k = Math.ceil(b / this._granularityCellSize), R = Math.floor(y / this._granularityCellSize), L = Math.ceil(T / this._granularityCellSize); if (M !== k || R !== L) for (let O = R; O < L; O++) { const U = this._scanlineGenerateVertexRingForCellRow(O, p, d); V_(this._vertexBuffer, U, n) } else n.push(...d) } return n } _scanlineGenerateVertexRingForCellRow(t, n, s) { const l = t * this._granularityCellSize, d = l + this._granularityCellSize, p = []; for (let _ = 0; _ < 3; _++) { const y = n[2 * _], b = n[2 * _ + 1], T = n[2 * (_ + 1) % 6], M = n[(2 * (_ + 1) + 1) % 6], k = n[2 * (_ + 2) % 6], R = n[(2 * (_ + 2) + 1) % 6], L = T - y, O = M - b, U = L === 0, W = O === 0, se = (l - b) / O, J = (d - b) / O, D = Math.min(se, J), N = Math.max(se, J); if (!W && (D >= 1 || N <= 0) || W && (b < l || b > d)) { M >= l && M <= d && p.push(s[(_ + 1) % 3]); continue } !W && D > 0 && p.push(this._vertexToIndex(y + L * D, b + O * D)); const Y = y + L * Math.max(D, 0), _e = y + L * Math.min(N, 1); U || this._generateIntraEdgeVertices(p, y, b, T, M, Y, _e), !W && N < 1 && p.push(this._vertexToIndex(y + L * N, b + O * N)), (W || M >= l && M <= d) && p.push(s[(_ + 1) % 3]), !W && (M <= l || M >= d) && this._generateInterEdgeVertices(p, y, b, T, M, k, R, _e, l, d) } return p } _generateIntraEdgeVertices(t, n, s, l, d, p, _) { const y = l - n, b = d - s, T = b === 0, M = T ? Math.min(n, l) : Math.min(p, _), k = T ? Math.max(n, l) : Math.max(p, _), R = Math.floor(M / this._granularityCellSize) + 1, L = Math.ceil(k / this._granularityCellSize) - 1; if (T ? n < l : p < _) for (let O = R; O <= L; O++) { const U = O * this._granularityCellSize; t.push(this._vertexToIndex(U, s + b * (U - n) / y)) } else for (let O = L; O >= R; O--) { const U = O * this._granularityCellSize; t.push(this._vertexToIndex(U, s + b * (U - n) / y)) } } _generateInterEdgeVertices(t, n, s, l, d, p, _, y, b, T) { const M = d - s, k = p - l, R = _ - d, L = (b - d) / R, O = (T - d) / R, U = Math.min(L, O), W = Math.max(L, O), se = l + k * U; let J = Math.floor(Math.min(se, y) / this._granularityCellSize) + 1, D = Math.ceil(Math.max(se, y) / this._granularityCellSize) - 1, N = y < se; const Y = R === 0; if (Y && (_ === b || _ === T)) return; if (Y || U >= 1 || W <= 0) { const ke = s - _, ve = p + (n - p) * Math.min((b - _) / ke, (T - _) / ke); J = Math.floor(Math.min(ve, y) / this._granularityCellSize) + 1, D = Math.ceil(Math.max(ve, y) / this._granularityCellSize) - 1, N = y < ve } const _e = M > 0 ? T : b; if (N) for (let ke = J; ke <= D; ke++)t.push(this._vertexToIndex(ke * this._granularityCellSize, _e)); else for (let ke = D; ke >= J; ke--)t.push(this._vertexToIndex(ke * this._granularityCellSize, _e)) } _generateOutline(t) { const n = []; for (const s of t) { const l = mo(s, this._granularity, !0), d = this._pointArrayToIndices(l), p = []; for (let _ = 1; _ < d.length; _++)p.push(d[_ - 1]), p.push(d[_]); n.push(p) } return n } _handlePoles(t) { let n = !1, s = !1; this._canonical && (this._canonical.y === 0 && (n = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (s = !0)), (n || s) && this._fillPoles(t, n, s) } _ensureNoPoleVertices() { const t = this._vertexBuffer; for (let n = 0; n < t.length; n += 2) { const s = t[n + 1]; s === wa && (t[n + 1] = -32767), s === Xl && (t[n + 1] = 32766) } } _generatePoleQuad(t, n, s, l, d, p) { l > d != (p === wa) ? (t.push(n), t.push(s), t.push(this._vertexToIndex(l, p)), t.push(s), t.push(this._vertexToIndex(d, p)), t.push(this._vertexToIndex(l, p))) : (t.push(s), t.push(n), t.push(this._vertexToIndex(l, p)), t.push(this._vertexToIndex(d, p)), t.push(s), t.push(this._vertexToIndex(l, p))) } _fillPoles(t, n, s) { const l = this._vertexBuffer, d = gt, p = t.length; for (let _ = 2; _ < p; _ += 3) { const y = t[_ - 2], b = t[_ - 1], T = t[_], M = l[2 * y], k = l[2 * y + 1], R = l[2 * b], L = l[2 * b + 1], O = l[2 * T], U = l[2 * T + 1]; n && (k === 0 && L === 0 && this._generatePoleQuad(t, y, b, M, R, wa), L === 0 && U === 0 && this._generatePoleQuad(t, b, T, R, O, wa), U === 0 && k === 0 && this._generatePoleQuad(t, T, y, O, M, wa)), s && (k === d && L === d && this._generatePoleQuad(t, y, b, M, R, Xl), L === d && U === d && this._generatePoleQuad(t, b, T, R, O, Xl), U === d && k === d && this._generatePoleQuad(t, T, y, O, M, Xl)) } } _initializeVertices(t) { for (let n = 0; n < t.length; n += 2)this._vertexToIndex(t[n], t[n + 1]) } subdividePolygonInternal(t, n) { if (this._used) throw new Error("Subdivision: multiple use not allowed."); this._used = !0; const { flattened: s, holeIndices: l } = function (_) { const y = [], b = []; for (const T of _) if (T.length !== 0) { T !== _[0] && y.push(b.length / 2); for (let M = 0; M < T.length; M++)b.push(T[M].x), b.push(T[M].y) } return { flattened: b, holeIndices: y } }(t); let d; this._initializeVertices(s); try { const _ = function (b, T, M = 2) { const k = T && T.length, R = k ? T[0] * M : b.length; let L = mp(b, 0, R, M, !0); const O = []; if (!L || L.next === L.prev) return O; let U, W, se; if (k && (L = function (J, D, N, Y) { const _e = []; for (let ke = 0, ve = D.length; ke < ve; ke++) { const Te = mp(J, D[ke] * Y, ke < ve - 1 ? D[ke + 1] * Y : J.length, Y, !1); Te === Te.next && (Te.steiner = !0), _e.push(B_(Te)) } _e.sort(R_); for (let ke = 0; ke < _e.length; ke++)N = L_(_e[ke], N); return N }(b, T, L, M)), b.length > 80 * M) { U = 1 / 0, W = 1 / 0; let J = -1 / 0, D = -1 / 0; for (let N = M; N < R; N += M) { const Y = b[N], _e = b[N + 1]; Y < U && (U = Y), _e < W && (W = _e), Y > J && (J = Y), _e > D && (D = _e) } se = Math.max(J - U, D - W), se = se !== 0 ? 32767 / se : 0 } return Gl(L, O, M, U, W, se, 0), O }(s, l), y = this._convertIndices(s, _); d = this._subdivideTrianglesScanline(y) } catch (_) { console.error(_) } let p = []; return n && (p = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(d), { verticesFlattened: this._vertexBuffer, indicesTriangles: d, indicesLineList: p } } _convertIndices(t, n) { const s = []; for (let l = 0; l < n.length; l++)s.push(this._vertexToIndex(t[2 * n[l]], t[2 * n[l] + 1])); return s } _pointArrayToIndices(t) { const n = []; for (let s = 0; s < t.length; s++) { const l = t[s]; n.push(this._vertexToIndex(l.x, l.y)) } return n } } function vp(r, t, n, s = !0) { return new j_(n, t).subdividePolygonInternal(r, s) } function mo(r, t, n = !1) { if (!r || r.length < 1) return []; if (r.length < 2) return []; const s = r[0], l = r[r.length - 1], d = n && (s.x !== l.x || s.y !== l.y); if (t < 2) return d ? [...r, r[0]] : [...r]; const p = Math.floor(gt / t), _ = []; _.push(new Ge(r[0].x, r[0].y)); const y = r.length, b = d ? y : y - 1; for (let T = 0; T < b; T++) { const M = r[T], k = T < y - 1 ? r[T + 1] : r[0], R = M.x, L = M.y, O = k.x, U = k.y, W = R !== O, se = L !== U; if (!W && !se) continue; const J = O - R, D = U - L, N = Math.abs(J), Y = Math.abs(D); let _e = R, ke = L; for (; ;) { const Te = J > 0 ? (Math.floor(_e / p) + 1) * p : (Math.ceil(_e / p) - 1) * p, je = D > 0 ? (Math.floor(ke / p) + 1) * p : (Math.ceil(ke / p) - 1) * p, Re = Math.abs(_e - Te), Ne = Math.abs(ke - je), Ce = Math.abs(_e - O), Ye = Math.abs(ke - U), ut = W ? Re / N : Number.POSITIVE_INFINITY, lt = se ? Ne / Y : Number.POSITIVE_INFINITY; if ((Ce <= Re || !W) && (Ye <= Ne || !se)) break; if (ut < lt && W || !se) { _e = Te, ke += D * ut; const it = new Ge(_e, Math.round(ke)); _[_.length - 1].x === it.x && _[_.length - 1].y === it.y || _.push(it) } else { _e += J * lt, ke = je; const it = new Ge(Math.round(_e), ke); _[_.length - 1].x === it.x && _[_.length - 1].y === it.y || _.push(it) } } const ve = new Ge(O, U); _[_.length - 1].x === ve.x && _[_.length - 1].y === ve.y || _.push(ve) } return _ } function V_(r, t, n) { if (t.length === 0) throw new Error("Subdivision vertex ring is empty."); let s = 0, l = r[2 * t[0]]; for (let y = 1; y < t.length; y++) { const b = r[2 * t[y]]; b < l && (l = b, s = y) } const d = t.length; let p = s, _ = (p + 1) % d; for (; ;) { const y = p - 1 >= 0 ? p - 1 : d - 1, b = (_ + 1) % d, T = r[2 * t[y]], M = r[2 * t[b]], k = r[2 * t[p]], R = r[2 * t[p] + 1], L = r[2 * t[_] + 1]; let O = !1; if (T < M) O = !0; else if (T > M) O = !1; else { const U = L - R, W = -(r[2 * t[_]] - k), se = R < L ? 1 : -1; ((T - k) * U + (r[2 * t[y] + 1] - R) * W) * se > ((M - k) * U + (r[2 * t[b] + 1] - R) * W) * se && (O = !0) } if (O) { const U = t[y], W = t[p], se = t[_]; U !== W && U !== se && W !== se && n.push(se, W, U), p--, p < 0 && (p = d - 1) } else { const U = t[b], W = t[p], se = t[_]; U !== W && U !== se && W !== se && n.push(se, W, U), _++, _ >= d && (_ = 0) } if (y === b) break } } function bp(r, t, n, s, l, d, p, _, y) { const b = l.length / 2, T = p && _ && y; if (b < st.MAX_VERTEX_ARRAY_LENGTH) { const M = t.prepareSegment(b, n, s), k = M.vertexLength; for (let O = 0; O < d.length; O += 3)s.emplaceBack(k + d[O], k + d[O + 1], k + d[O + 2]); let R, L; M.vertexLength += b, M.primitiveLength += d.length / 3, T && (L = p.prepareSegment(b, n, _), R = L.vertexLength, L.vertexLength += b); for (let O = 0; O < l.length; O += 2)r(l[O], l[O + 1]); if (T) for (let O = 0; O < y.length; O++) { const U = y[O]; for (let W = 1; W < U.length; W += 2)_.emplaceBack(R + U[W - 1], R + U[W]); L.primitiveLength += U.length / 2 } } else (function (M, k, R, L, O, U) { const W = []; for (let Y = 0; Y < L.length / 2; Y++)W.push(-1); const se = { count: 0 }; let J = 0, D = M.getOrCreateLatestSegment(k, R), N = D.vertexLength; for (let Y = 2; Y < O.length; Y += 3) { const _e = O[Y - 2], ke = O[Y - 1], ve = O[Y]; let Te = W[_e] < J, je = W[ke] < J, Re = W[ve] < J; D.vertexLength + ((Te ? 1 : 0) + (je ? 1 : 0) + (Re ? 1 : 0)) > st.MAX_VERTEX_ARRAY_LENGTH && (D = M.createNewSegment(k, R), J = se.count, Te = !0, je = !0, Re = !0, N = 0); const Ne = Kl(W, L, U, se, _e, Te, D), Ce = Kl(W, L, U, se, ke, je, D), Ye = Kl(W, L, U, se, ve, Re, D); R.emplaceBack(N + Ne - J, N + Ce - J, N + Ye - J), D.primitiveLength++ } })(t, n, s, l, d, r), T && function (M, k, R, L, O, U) { const W = []; for (let Y = 0; Y < L.length / 2; Y++)W.push(-1); const se = { count: 0 }; let J = 0, D = M.getOrCreateLatestSegment(k, R), N = D.vertexLength; for (let Y = 0; Y < O.length; Y++) { const _e = O[Y]; for (let ke = 1; ke < O[Y].length; ke += 2) { const ve = _e[ke - 1], Te = _e[ke]; let je = W[ve] < J, Re = W[Te] < J; D.vertexLength + ((je ? 1 : 0) + (Re ? 1 : 0)) > st.MAX_VERTEX_ARRAY_LENGTH && (D = M.createNewSegment(k, R), J = se.count, je = !0, Re = !0, N = 0); const Ne = Kl(W, L, U, se, ve, je, D), Ce = Kl(W, L, U, se, Te, Re, D); R.emplaceBack(N + Ne - J, N + Ce - J), D.primitiveLength++ } } }(p, n, _, l, y, r), t.forceNewSegmentOnNextPrepare(), p == null || p.forceNewSegmentOnNextPrepare() } function Kl(r, t, n, s, l, d, p) { if (d) { const _ = s.count; return n(t[2 * l], t[2 * l + 1]), r[l] = s.count, s.count++, p.vertexLength++, _ } return r[l] } class jh { constructor(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(n => n.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Q, this.indexArray = new $e, this.indexArray2 = new Ue, this.programConfigurations = new os(t.layers, t.zoom), this.segments = new st, this.segments2 = new st, this.stateDependentLayerIds = this.layers.filter(n => n.isStateDependent()).map(n => n.id) } populate(t, n, s) { this.hasPattern = Lh("fill", this.layers, n); const l = this.layers[0].layout.get("fill-sort-key"), d = !l.isConstant(), p = []; for (const { feature: _, id: y, index: b, sourceLayerIndex: T } of t) { const M = this.layers[0]._featureFilter.needGeometry, k = Tr(_, M); if (!this.layers[0]._featureFilter.filter(new si(this.zoom), k, s)) continue; const R = d ? l.evaluate(k, {}, s, n.availableImages) : void 0, L = { id: y, properties: _.properties, type: _.type, sourceLayerIndex: T, index: b, geometry: M ? k.geometry : as(_), patterns: {}, sortKey: R }; p.push(L) } d && p.sort((_, y) => _.sortKey - y.sortKey); for (const _ of p) { const { geometry: y, index: b, sourceLayerIndex: T } = _; if (this.hasPattern) { const M = Fh("fill", this.layers, _, this.zoom, n); this.patternFeatures.push(M) } else this.addFeature(_, y, b, s, {}, n.subdivisionGranularity); n.featureIndex.insert(t[b].feature, y, b, T, this.index) } } update(t, n, s) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s) } addFeatures(t, n, s) { for (const l of this.patternFeatures) this.addFeature(l, l.geometry, l.index, n, s, t.subdivisionGranularity) } isEmpty() { return this.layoutVertexArray.length === 0 } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, E_), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0 } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy()) } addFeature(t, n, s, l, d, p) { for (const _ of jo(n, 500)) { const y = vp(_, l, p.fill.getGranularityForZoomLevel(l.z)), b = this.layoutVertexArray; bp((T, M) => { b.emplaceBack(T, M) }, this.segments, this.layoutVertexArray, this.indexArray, y.verticesFlattened, y.indicesTriangles, this.segments2, this.indexArray2, y.indicesLineList) } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, d, l) } } let wp, Tp; Je("FillBucket", jh, { omit: ["layers", "patternFeatures"] }); var N_ = { get paint() { return Tp = Tp || new mr({ "fill-antialias": new nt(C.paint_fill["fill-antialias"]), "fill-opacity": new ht(C.paint_fill["fill-opacity"]), "fill-color": new ht(C.paint_fill["fill-color"]), "fill-outline-color": new ht(C.paint_fill["fill-outline-color"]), "fill-translate": new nt(C.paint_fill["fill-translate"]), "fill-translate-anchor": new nt(C.paint_fill["fill-translate-anchor"]), "fill-pattern": new uo(C.paint_fill["fill-pattern"]) }) }, get layout() { return wp = wp || new mr({ "fill-sort-key": new ht(C.layout_fill["fill-sort-key"]) }) } }; class Z_ extends hn { constructor(t) { super(t, N_) } recalculate(t, n) { super.recalculate(t, n); const s = this.paint._values["fill-outline-color"]; s.value.kind === "constant" && s.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]) } createBucket(t) { return new jh(t) } queryRadius() { return vu(this.paint.get("fill-translate")) } queryIntersectsFeature({ queryGeometry: t, geometry: n, transform: s, pixelsToTileUnits: l }) { return ya(bu(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -s.bearingInRadians, l), n) } isTileClipped() { return !0 } } const U_ = xi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), $_ = xi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: G_ } = U_; var Vh, Pp, Nh, Sp, Zh, Mp, Ip, Su = {}; function Cp() { if (Pp) return Vh; Pp = 1; var r = Fe(); function t(l, d, p, _, y) { this.properties = {}, this.extent = p, this.type = 0, this._pbf = l, this._geometry = -1, this._keys = _, this._values = y, l.readFields(n, this, d) } function n(l, d, p) { l == 1 ? d.id = p.readVarint() : l == 2 ? function (_, y) { for (var b = _.readVarint() + _.pos; _.pos < b;) { var T = y._keys[_.readVarint()], M = y._values[_.readVarint()]; y.properties[T] = M } }(p, d) : l == 3 ? d.type = p.readVarint() : l == 4 && (d._geometry = p.pos) } function s(l) { for (var d, p, _ = 0, y = 0, b = l.length, T = b - 1; y < b; T = y++)_ += ((p = l[T]).x - (d = l[y]).x) * (d.y + p.y); return _ } return Vh = t, t.types = ["Unknown", "Point", "LineString", "Polygon"], t.prototype.loadGeometry = function () { var l = this._pbf; l.pos = this._geometry; for (var d, p = l.readVarint() + l.pos, _ = 1, y = 0, b = 0, T = 0, M = []; l.pos < p;) { if (y <= 0) { var k = l.readVarint(); _ = 7 & k, y = k >> 3 } if (y--, _ === 1 || _ === 2) b += l.readSVarint(), T += l.readSVarint(), _ === 1 && (d && M.push(d), d = []), d.push(new r(b, T)); else { if (_ !== 7) throw new Error("unknown command " + _); d && d.push(d[0].clone()) } } return d && M.push(d), M }, t.prototype.bbox = function () { var l = this._pbf; l.pos = this._geometry; for (var d = l.readVarint() + l.pos, p = 1, _ = 0, y = 0, b = 0, T = 1 / 0, M = -1 / 0, k = 1 / 0, R = -1 / 0; l.pos < d;) { if (_ <= 0) { var L = l.readVarint(); p = 7 & L, _ = L >> 3 } if (_--, p === 1 || p === 2) (y += l.readSVarint()) < T && (T = y), y > M && (M = y), (b += l.readSVarint()) < k && (k = b), b > R && (R = b); else if (p !== 7) throw new Error("unknown command " + p) } return [T, k, M, R] }, t.prototype.toGeoJSON = function (l, d, p) { var _, y, b = this.extent * Math.pow(2, p), T = this.extent * l, M = this.extent * d, k = this.loadGeometry(), R = t.types[this.type]; function L(W) { for (var se = 0; se < W.length; se++) { var J = W[se]; W[se] = [360 * (J.x + T) / b - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (J.y + M) / b) * Math.PI / 180)) - 90] } } switch (this.type) { case 1: var O = []; for (_ = 0; _ < k.length; _++)O[_] = k[_][0]; L(k = O); break; case 2: for (_ = 0; _ < k.length; _++)L(k[_]); break; case 3: for (k = function (W) { var se = W.length; if (se <= 1) return [W]; for (var J, D, N = [], Y = 0; Y < se; Y++) { var _e = s(W[Y]); _e !== 0 && (D === void 0 && (D = _e < 0), D === _e < 0 ? (J && N.push(J), J = [W[Y]]) : J.push(W[Y])) } return J && N.push(J), N }(k), _ = 0; _ < k.length; _++)for (y = 0; y < k[_].length; y++)L(k[_][y]) }k.length === 1 ? k = k[0] : R = "Multi" + R; var U = { type: "Feature", geometry: { type: R, coordinates: k }, properties: this.properties }; return "id" in this && (U.id = this.id), U }, Vh } function Ep() { if (Sp) return Nh; Sp = 1; var r = Cp(); function t(s, l) { this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = s, this._keys = [], this._values = [], this._features = [], s.readFields(n, this, l), this.length = this._features.length } function n(s, l, d) { s === 15 ? l.version = d.readVarint() : s === 1 ? l.name = d.readString() : s === 5 ? l.extent = d.readVarint() : s === 2 ? l._features.push(d.pos) : s === 3 ? l._keys.push(d.readString()) : s === 4 && l._values.push(function (p) { for (var _ = null, y = p.readVarint() + p.pos; p.pos < y;) { var b = p.readVarint() >> 3; _ = b === 1 ? p.readString() : b === 2 ? p.readFloat() : b === 3 ? p.readDouble() : b === 4 ? p.readVarint64() : b === 5 ? p.readVarint() : b === 6 ? p.readSVarint() : b === 7 ? p.readBoolean() : null } return _ }(d)) } return Nh = t, t.prototype.feature = function (s) { if (s < 0 || s >= this._features.length) throw new Error("feature index out of bounds"); this._pbf.pos = this._features[s]; var l = this._pbf.readVarint() + this._pbf.pos; return new r(this._pbf, l, this.extent, this._keys, this._values) }, Nh } function Ap() { return Ip || (Ip = 1, Su.VectorTile = function () { if (Mp) return Zh; Mp = 1; var r = Ep(); function t(n, s, l) { if (n === 3) { var d = new r(l, l.readVarint() + l.pos); d.length && (s[d.name] = d) } } return Zh = function (n, s) { this.layers = n.readFields(t, {}, s) }, Zh }(), Su.VectorTileFeature = Cp(), Su.VectorTileLayer = Ep()), Su } var Jl = de(Ap()); const q_ = Jl.VectorTileFeature.types, Uh = Math.pow(2, 13); function Yl(r, t, n, s, l, d, p, _) { r.emplaceBack(t, n, 2 * Math.floor(s * Uh) + p, l * Uh * 2, d * Uh * 2, Math.round(_)) } class $h { constructor(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(n => n.id), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new ee, this.centroidVertexArray = new H, this.indexArray = new $e, this.programConfigurations = new os(t.layers, t.zoom), this.segments = new st, this.stateDependentLayerIds = this.layers.filter(n => n.isStateDependent()).map(n => n.id) } populate(t, n, s) { this.features = [], this.hasPattern = Lh("fill-extrusion", this.layers, n); for (const { feature: l, id: d, index: p, sourceLayerIndex: _ } of t) { const y = this.layers[0]._featureFilter.needGeometry, b = Tr(l, y); if (!this.layers[0]._featureFilter.filter(new si(this.zoom), b, s)) continue; const T = { id: d, sourceLayerIndex: _, index: p, geometry: y ? b.geometry : as(l), properties: l.properties, type: l.type, patterns: {} }; this.hasPattern ? this.features.push(Fh("fill-extrusion", this.layers, T, this.zoom, n)) : this.addFeature(T, T.geometry, p, s, {}, n.subdivisionGranularity), n.featureIndex.insert(l, T.geometry, p, _, this.index, !0) } } addFeatures(t, n, s) { for (const l of this.features) { const { geometry: d } = l; this.addFeature(l, d, l.index, n, s, t.subdivisionGranularity) } } update(t, n, s) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s) } isEmpty() { return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0 } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, G_), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, $_.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy()) } addFeature(t, n, s, l, d, p) { for (const _ of jo(n, 500)) { const y = { x: 0, y: 0, sampleCount: 0 }, b = this.layoutVertexArray.length; this.processPolygon(y, l, t, _, p); const T = this.layoutVertexArray.length - b, M = Math.floor(y.x / y.sampleCount), k = Math.floor(y.y / y.sampleCount); for (let R = 0; R < T; R++)this.centroidVertexArray.emplaceBack(M, k) } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, d, l) } processPolygon(t, n, s, l, d) { if (l.length < 1 || zp(l[0])) return; for (const M of l) M.length !== 0 && H_(t, M); const p = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, _ = d.fill.getGranularityForZoomLevel(n.z), y = q_[s.type] === "Polygon"; for (const M of l) { if (M.length === 0 || zp(M)) continue; const k = mo(M, _, y); this._generateSideFaces(k, p) } if (!y) return; const b = vp(l, n, _, !1), T = this.layoutVertexArray; bp((M, k) => { Yl(T, M, k, 0, 0, 1, 1, 0) }, this.segments, this.layoutVertexArray, this.indexArray, b.verticesFlattened, b.indicesTriangles) } _generateSideFaces(t, n) { let s = 0; for (let l = 1; l < t.length; l++) { const d = t[l], p = t[l - 1]; if (W_(d, p)) continue; n.segment.vertexLength + 4 > st.MAX_VERTEX_ARRAY_LENGTH && (n.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)); const _ = d.sub(p)._perp()._unit(), y = p.dist(d); s + y > 32768 && (s = 0), Yl(this.layoutVertexArray, d.x, d.y, _.x, _.y, 0, 0, s), Yl(this.layoutVertexArray, d.x, d.y, _.x, _.y, 0, 1, s), s += y, Yl(this.layoutVertexArray, p.x, p.y, _.x, _.y, 0, 0, s), Yl(this.layoutVertexArray, p.x, p.y, _.x, _.y, 0, 1, s); const b = n.segment.vertexLength; this.indexArray.emplaceBack(b, b + 2, b + 1), this.indexArray.emplaceBack(b + 1, b + 2, b + 3), n.segment.vertexLength += 4, n.segment.primitiveLength += 2 } } } function H_(r, t) { for (let n = 0; n < t.length; n++) { const s = t[n]; n === t.length - 1 && t[0].x === s.x && t[0].y === s.y || (r.x += s.x, r.y += s.y, r.sampleCount++) } } function W_(r, t) { return r.x === t.x && (r.x < 0 || r.x > gt) || r.y === t.y && (r.y < 0 || r.y > gt) } function zp(r) { return r.every(t => t.x < 0) || r.every(t => t.x > gt) || r.every(t => t.y < 0) || r.every(t => t.y > gt) } let kp; Je("FillExtrusionBucket", $h, { omit: ["layers", "features"] }); var X_ = { get paint() { return kp = kp || new mr({ "fill-extrusion-opacity": new nt(C["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ht(C["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new nt(C["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new nt(C["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new uo(C["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ht(C["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ht(C["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new nt(C["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) } }; class K_ extends hn { constructor(t) { super(t, X_) } createBucket(t) { return new $h(t) } queryRadius() { return vu(this.paint.get("fill-extrusion-translate")) } is3D() { return !0 } queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: s, geometry: l, transform: d, pixelsToTileUnits: p, pixelPosMatrix: _ }) { const y = bu(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -d.bearingInRadians, p), b = this.paint.get("fill-extrusion-height").evaluate(n, s), T = this.paint.get("fill-extrusion-base").evaluate(n, s), M = function (R, L, O) { const U = []; for (const W of R) { const se = [W.x, W.y, 0, 1]; ar(se, se, L), U.push(new Ge(se[0] / se[3], se[1] / se[3])) } return U }(y, _), k = function (R, L, O, U) { const W = [], se = [], J = U[8] * L, D = U[9] * L, N = U[10] * L, Y = U[11] * L, _e = U[8] * O, ke = U[9] * O, ve = U[10] * O, Te = U[11] * O; for (const je of R) { const Re = [], Ne = []; for (const Ce of je) { const Ye = Ce.x, ut = Ce.y, lt = U[0] * Ye + U[4] * ut + U[12], it = U[1] * Ye + U[5] * ut + U[13], St = U[2] * Ye + U[6] * ut + U[14], fi = U[3] * Ye + U[7] * ut + U[15], zi = St + N, tr = fi + Y, en = lt + _e, Sr = it + ke, Hi = St + ve, ai = fi + Te, Bi = new Ge((lt + J) / tr, (it + D) / tr); Bi.z = zi / tr, Re.push(Bi); const Wi = new Ge(en / ai, Sr / ai); Wi.z = Hi / ai, Ne.push(Wi) } W.push(Re), se.push(Ne) } return [W, se] }(l, T, b, _); return function (R, L, O) { let U = 1 / 0; ya(O, L) && (U = Dp(O, L[0])); for (let W = 0; W < L.length; W++) { const se = L[W], J = R[W]; for (let D = 0; D < se.length - 1; D++) { const N = se[D], Y = [N, se[D + 1], J[D + 1], J[D], N]; ga(O, Y) && (U = Math.min(U, Dp(O, Y))) } } return U !== 1 / 0 && U }(k[0], k[1], M) } } function Ql(r, t) { return r.x * t.x + r.y * t.y } function Dp(r, t) { if (r.length === 1) { let n = 0; const s = t[n++]; let l; for (; !l || s.equals(l);)if (l = t[n++], !l) return 1 / 0; for (; n < t.length; n++) { const d = t[n], p = r[0], _ = l.sub(s), y = d.sub(s), b = p.sub(s), T = Ql(_, _), M = Ql(_, y), k = Ql(y, y), R = Ql(b, _), L = Ql(b, y), O = T * k - M * M, U = (k * R - M * L) / O, W = (T * L - M * R) / O, se = s.z * (1 - U - W) + l.z * U + d.z * W; if (isFinite(se)) return se } return 1 / 0 } { let n = 1 / 0; for (const s of t) n = Math.min(n, s.z); return n } } const J_ = xi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Y_ } = J_, Q_ = xi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: eg } = Q_, tg = Jl.VectorTileFeature.types, ig = Math.cos(Math.PI / 180 * 37.5), Rp = Math.pow(2, 14) / .5; class Gh { constructor(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(n => n.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(n => { this.gradients[n.id] = {} }), this.layoutVertexArray = new re, this.layoutVertexArray2 = new oe, this.indexArray = new $e, this.programConfigurations = new os(t.layers, t.zoom), this.segments = new st, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(n => n.isStateDependent()).map(n => n.id) } populate(t, n, s) { this.hasPattern = Lh("line", this.layers, n); const l = this.layers[0].layout.get("line-sort-key"), d = !l.isConstant(), p = []; for (const { feature: _, id: y, index: b, sourceLayerIndex: T } of t) { const M = this.layers[0]._featureFilter.needGeometry, k = Tr(_, M); if (!this.layers[0]._featureFilter.filter(new si(this.zoom), k, s)) continue; const R = d ? l.evaluate(k, {}, s) : void 0, L = { id: y, properties: _.properties, type: _.type, sourceLayerIndex: T, index: b, geometry: M ? k.geometry : as(_), patterns: {}, sortKey: R }; p.push(L) } d && p.sort((_, y) => _.sortKey - y.sortKey); for (const _ of p) { const { geometry: y, index: b, sourceLayerIndex: T } = _; if (this.hasPattern) { const M = Fh("line", this.layers, _, this.zoom, n); this.patternFeatures.push(M) } else this.addFeature(_, y, b, s, {}, n.subdivisionGranularity); n.featureIndex.insert(t[b].feature, y, b, T, this.index) } } update(t, n, s) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s) } addFeatures(t, n, s) { for (const l of this.patternFeatures) this.addFeature(l, l.geometry, l.index, n, s, t.subdivisionGranularity) } isEmpty() { return this.layoutVertexArray.length === 0 } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(t) { this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, eg)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Y_), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0 } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()) } lineFeatureClips(t) { if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end } } addFeature(t, n, s, l, d, p) { const _ = this.layers[0].layout, y = _.get("line-join").evaluate(t, {}), b = _.get("line-cap"), T = _.get("line-miter-limit"), M = _.get("line-round-limit"); this.lineClips = this.lineFeatureClips(t); for (const k of n) this.addLine(k, t, y, b, T, M, l, p); this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, d, l) } addLine(t, n, s, l, d, p, _, y) { if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = mo(t, _ ? y.line.getGranularityForZoomLevel(_.z) : 1), this.lineClips) { this.lineClipsArray.push(this.lineClips); for (let J = 0; J < t.length - 1; J++)this.totalDistance += t[J].dist(t[J + 1]); this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance) } const b = tg[n.type] === "Polygon"; let T = t.length; for (; T >= 2 && t[T - 1].equals(t[T - 2]);)T--; let M = 0; for (; M < T - 1 && t[M].equals(t[M + 1]);)M++; if (T < (b ? 3 : 2)) return; s === "bevel" && (d = 1.05); const k = this.overscaling <= 16 ? 15 * gt / (512 * this.overscaling) : 0, R = this.segments.prepareSegment(10 * T, this.layoutVertexArray, this.indexArray); let L, O, U, W, se; this.e1 = this.e2 = -1, b && (L = t[T - 2], se = t[M].sub(L)._unit()._perp()); for (let J = M; J < T; J++) { if (U = J === T - 1 ? b ? t[M + 1] : void 0 : t[J + 1], U && t[J].equals(U)) continue; se && (W = se), L && (O = L), L = t[J], se = U ? U.sub(L)._unit()._perp() : W, W = W || se; let D = W.add(se); D.x === 0 && D.y === 0 || D._unit(); const N = W.x * se.x + W.y * se.y, Y = D.x * se.x + D.y * se.y, _e = Y !== 0 ? 1 / Y : 1 / 0, ke = 2 * Math.sqrt(2 - 2 * Y), ve = Y < ig && O && U, Te = W.x * se.y - W.y * se.x > 0; if (ve && J > M) { const Ne = L.dist(O); if (Ne > 2 * k) { const Ce = L.sub(L.sub(O)._mult(k / Ne)._round()); this.updateDistance(O, Ce), this.addCurrentVertex(Ce, W, 0, 0, R), O = Ce } } const je = O && U; let Re = je ? s : b ? "butt" : l; if (je && Re === "round" && (_e < p ? Re = "miter" : _e <= 2 && (Re = "fakeround")), Re === "miter" && _e > d && (Re = "bevel"), Re === "bevel" && (_e > 2 && (Re = "flipbevel"), _e < d && (Re = "miter")), O && this.updateDistance(O, L), Re === "miter") D._mult(_e), this.addCurrentVertex(L, D, 0, 0, R); else if (Re === "flipbevel") { if (_e > 100) D = se.mult(-1); else { const Ne = _e * W.add(se).mag() / W.sub(se).mag(); D._perp()._mult(Ne * (Te ? -1 : 1)) } this.addCurrentVertex(L, D, 0, 0, R), this.addCurrentVertex(L, D.mult(-1), 0, 0, R) } else if (Re === "bevel" || Re === "fakeround") { const Ne = -Math.sqrt(_e * _e - 1), Ce = Te ? Ne : 0, Ye = Te ? 0 : Ne; if (O && this.addCurrentVertex(L, W, Ce, Ye, R), Re === "fakeround") { const ut = Math.round(180 * ke / Math.PI / 20); for (let lt = 1; lt < ut; lt++) { let it = lt / ut; if (it !== .5) { const fi = it - .5; it += it * fi * (it - 1) * ((1.0904 + N * (N * (3.55645 - 1.43519 * N) - 3.2452)) * fi * fi + (.848013 + N * (.215638 * N - 1.06021))) } const St = se.sub(W)._mult(it)._add(W)._unit()._mult(Te ? -1 : 1); this.addHalfVertex(L, St.x, St.y, !1, Te, 0, R) } } U && this.addCurrentVertex(L, se, -Ce, -Ye, R) } else if (Re === "butt") this.addCurrentVertex(L, D, 0, 0, R); else if (Re === "square") { const Ne = O ? 1 : -1; this.addCurrentVertex(L, D, Ne, Ne, R) } else Re === "round" && (O && (this.addCurrentVertex(L, W, 0, 0, R), this.addCurrentVertex(L, W, 1, 1, R, !0)), U && (this.addCurrentVertex(L, se, -1, -1, R, !0), this.addCurrentVertex(L, se, 0, 0, R))); if (ve && J < T - 1) { const Ne = L.dist(U); if (Ne > 2 * k) { const Ce = L.add(U.sub(L)._mult(k / Ne)._round()); this.updateDistance(L, Ce), this.addCurrentVertex(Ce, se, 0, 0, R), L = Ce } } } } addCurrentVertex(t, n, s, l, d, p = !1) { const _ = n.y * l - n.x, y = -n.y - n.x * l; this.addHalfVertex(t, n.x + n.y * s, n.y - n.x * s, p, !1, s, d), this.addHalfVertex(t, _, y, p, !0, -l, d), this.distance > Rp / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, n, s, l, d, p)) } addHalfVertex({ x: t, y: n }, s, l, d, p, _, y) { const b = .5 * (this.lineClips ? this.scaledDistance * (Rp - 1) : this.scaledDistance); this.layoutVertexArray.emplaceBack((t << 1) + (d ? 1 : 0), (n << 1) + (p ? 1 : 0), Math.round(63 * s) + 128, Math.round(63 * l) + 128, 1 + (_ === 0 ? 0 : _ < 0 ? -1 : 1) | (63 & b) << 2, b >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length); const T = y.vertexLength++; this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, T, this.e2), y.primitiveLength++), p ? this.e2 = T : this.e1 = T } updateScaledDistance() { this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance } updateDistance(t, n) { this.distance += t.dist(n), this.updateScaledDistance() } } let Lp, Fp; Je("LineBucket", Gh, { omit: ["layers", "patternFeatures"] }); var Bp = { get paint() { return Fp = Fp || new mr({ "line-opacity": new ht(C.paint_line["line-opacity"]), "line-color": new ht(C.paint_line["line-color"]), "line-translate": new nt(C.paint_line["line-translate"]), "line-translate-anchor": new nt(C.paint_line["line-translate-anchor"]), "line-width": new ht(C.paint_line["line-width"]), "line-gap-width": new ht(C.paint_line["line-gap-width"]), "line-offset": new ht(C.paint_line["line-offset"]), "line-blur": new ht(C.paint_line["line-blur"]), "line-dasharray": new la(C.paint_line["line-dasharray"]), "line-pattern": new uo(C.paint_line["line-pattern"]), "line-gradient": new Fl(C.paint_line["line-gradient"]) }) }, get layout() { return Lp = Lp || new mr({ "line-cap": new nt(C.layout_line["line-cap"]), "line-join": new ht(C.layout_line["line-join"]), "line-miter-limit": new nt(C.layout_line["line-miter-limit"]), "line-round-limit": new nt(C.layout_line["line-round-limit"]), "line-sort-key": new ht(C.layout_line["line-sort-key"]) }) } }; class rg extends ht { possiblyEvaluate(t, n) { return n = new si(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, zoomHistory: n.zoomHistory, transition: n.transition }), super.possiblyEvaluate(t, n) } evaluate(t, n, s, l) { return n = Si({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(t, n, s, l) } } let Mu; class ng extends hn { constructor(t) { super(t, Bp), this.gradientVersion = 0, Mu || (Mu = new rg(Bp.paint.properties["line-width"].specification), Mu.useIntegerZoom = !0) } _handleSpecialPaintPropertyUpdate(t) { if (t === "line-gradient") { const n = this.gradientExpression(); this.stepInterpolant = !!function (s) { return s._styleExpression !== void 0 }(n) && n._styleExpression.expression instanceof vs, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER } } gradientExpression() { return this._transitionablePaint._values["line-gradient"].value.expression } recalculate(t, n) { super.recalculate(t, n), this.paint._values["line-floorwidth"] = Mu.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t) } createBucket(t) { return new Gh(t) } queryRadius(t) { const n = t, s = Op(Ul("line-width", this, n), Ul("line-gap-width", this, n)), l = Ul("line-offset", this, n); return s / 2 + Math.abs(l) + vu(this.paint.get("line-translate")) } queryIntersectsFeature({ queryGeometry: t, feature: n, featureState: s, geometry: l, transform: d, pixelsToTileUnits: p }) { const _ = bu(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -d.bearingInRadians, p), y = p / 2 * Op(this.paint.get("line-width").evaluate(n, s), this.paint.get("line-gap-width").evaluate(n, s)), b = this.paint.get("line-offset").evaluate(n, s); return b && (l = function (T, M) { const k = []; for (let R = 0; R < T.length; R++) { const L = T[R], O = []; for (let U = 0; U < L.length; U++) { const W = L[U - 1], se = L[U], J = L[U + 1], D = U === 0 ? new Ge(0, 0) : se.sub(W)._unit()._perp(), N = U === L.length - 1 ? new Ge(0, 0) : J.sub(se)._unit()._perp(), Y = D._add(N)._unit(), _e = Y.x * N.x + Y.y * N.y; _e !== 0 && Y._mult(1 / _e), O.push(Y._mult(M)._add(se)) } k.push(O) } return k }(l, b * p)), function (T, M, k) { for (let R = 0; R < M.length; R++) { const L = M[R]; if (T.length >= 3) { for (let O = 0; O < L.length; O++)if (xa(T, L[O])) return !0 } if (x_(T, L, k)) return !0 } return !1 }(_, l, y) } isTileClipped() { return !0 } } function Op(r, t) { return t > 0 ? t + 2 * r : r } const sg = xi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), og = xi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4); xi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4); const ag = xi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]); xi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]); const jp = xi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), lg = xi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4); function cg(r, t, n) { return r.sections.forEach(s => { s.text = function (l, d, p) { const _ = d.layout.get("text-transform").evaluate(p, {}); return _ === "uppercase" ? l = l.toLocaleUpperCase() : _ === "lowercase" && (l = l.toLocaleLowerCase()), zn.applyArabicShaping && (l = zn.applyArabicShaping(l)), l }(s.text, t, n) }), r } xi([{ name: "triangle", components: 3, type: "Uint16" }]), xi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), xi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), xi([{ type: "Float32", name: "offsetX" }]), xi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), xi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]); const ec = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" }; var Vp, qh, Np, Ai = 24, Hh = {}; function ug() { return Vp || (Vp = 1, Hh.read = function (r, t, n, s, l) { var d, p, _ = 8 * l - s - 1, y = (1 << _) - 1, b = y >> 1, T = -7, M = n ? l - 1 : 0, k = n ? -1 : 1, R = r[t + M]; for (M += k, d = R & (1 << -T) - 1, R >>= -T, T += _; T > 0; d = 256 * d + r[t + M], M += k, T -= 8); for (p = d & (1 << -T) - 1, d >>= -T, T += s; T > 0; p = 256 * p + r[t + M], M += k, T -= 8); if (d === 0) d = 1 - b; else { if (d === y) return p ? NaN : 1 / 0 * (R ? -1 : 1); p += Math.pow(2, s), d -= b } return (R ? -1 : 1) * p * Math.pow(2, d - s) }, Hh.write = function (r, t, n, s, l, d) { var p, _, y, b = 8 * d - l - 1, T = (1 << b) - 1, M = T >> 1, k = l === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, R = s ? 0 : d - 1, L = s ? 1 : -1, O = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (_ = isNaN(t) ? 1 : 0, p = T) : (p = Math.floor(Math.log(t) / Math.LN2), t * (y = Math.pow(2, -p)) < 1 && (p--, y *= 2), (t += p + M >= 1 ? k / y : k * Math.pow(2, 1 - M)) * y >= 2 && (p++, y /= 2), p + M >= T ? (_ = 0, p = T) : p + M >= 1 ? (_ = (t * y - 1) * Math.pow(2, l), p += M) : (_ = t * Math.pow(2, M - 1) * Math.pow(2, l), p = 0)); l >= 8; r[n + R] = 255 & _, R += L, _ /= 256, l -= 8); for (p = p << l | _, b += l; b > 0; r[n + R] = 255 & p, R += L, p /= 256, b -= 8); r[n + R - L] |= 128 * O }), Hh } function Zp() { if (Np) return qh; Np = 1, qh = t; var r = ug(); function t(D) { this.buf = ArrayBuffer.isView && ArrayBuffer.isView(D) ? D : new Uint8Array(D || 0), this.pos = 0, this.type = 0, this.length = this.buf.length } t.Varint = 0, t.Fixed64 = 1, t.Bytes = 2, t.Fixed32 = 5; var n = 4294967296, s = 1 / n, l = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8"); function d(D) { return D.type === t.Bytes ? D.readVarint() + D.pos : D.pos + 1 } function p(D, N, Y) { return Y ? 4294967296 * N + (D >>> 0) : 4294967296 * (N >>> 0) + (D >>> 0) } function _(D, N, Y) { var _e = N <= 16383 ? 1 : N <= 2097151 ? 2 : N <= 268435455 ? 3 : Math.floor(Math.log(N) / (7 * Math.LN2)); Y.realloc(_e); for (var ke = Y.pos - 1; ke >= D; ke--)Y.buf[ke + _e] = Y.buf[ke] } function y(D, N) { for (var Y = 0; Y < D.length; Y++)N.writeVarint(D[Y]) } function b(D, N) { for (var Y = 0; Y < D.length; Y++)N.writeSVarint(D[Y]) } function T(D, N) { for (var Y = 0; Y < D.length; Y++)N.writeFloat(D[Y]) } function M(D, N) { for (var Y = 0; Y < D.length; Y++)N.writeDouble(D[Y]) } function k(D, N) { for (var Y = 0; Y < D.length; Y++)N.writeBoolean(D[Y]) } function R(D, N) { for (var Y = 0; Y < D.length; Y++)N.writeFixed32(D[Y]) } function L(D, N) { for (var Y = 0; Y < D.length; Y++)N.writeSFixed32(D[Y]) } function O(D, N) { for (var Y = 0; Y < D.length; Y++)N.writeFixed64(D[Y]) } function U(D, N) { for (var Y = 0; Y < D.length; Y++)N.writeSFixed64(D[Y]) } function W(D, N) { return (D[N] | D[N + 1] << 8 | D[N + 2] << 16) + 16777216 * D[N + 3] } function se(D, N, Y) { D[Y] = N, D[Y + 1] = N >>> 8, D[Y + 2] = N >>> 16, D[Y + 3] = N >>> 24 } function J(D, N) { return (D[N] | D[N + 1] << 8 | D[N + 2] << 16) + (D[N + 3] << 24) } return t.prototype = { destroy: function () { this.buf = null }, readFields: function (D, N, Y) { for (Y = Y || this.length; this.pos < Y;) { var _e = this.readVarint(), ke = _e >> 3, ve = this.pos; this.type = 7 & _e, D(ke, N, this), this.pos === ve && this.skip(_e) } return N }, readMessage: function (D, N) { return this.readFields(D, N, this.readVarint() + this.pos) }, readFixed32: function () { var D = W(this.buf, this.pos); return this.pos += 4, D }, readSFixed32: function () { var D = J(this.buf, this.pos); return this.pos += 4, D }, readFixed64: function () { var D = W(this.buf, this.pos) + W(this.buf, this.pos + 4) * n; return this.pos += 8, D }, readSFixed64: function () { var D = W(this.buf, this.pos) + J(this.buf, this.pos + 4) * n; return this.pos += 8, D }, readFloat: function () { var D = r.read(this.buf, this.pos, !0, 23, 4); return this.pos += 4, D }, readDouble: function () { var D = r.read(this.buf, this.pos, !0, 52, 8); return this.pos += 8, D }, readVarint: function (D) { var N, Y, _e = this.buf; return N = 127 & (Y = _e[this.pos++]), Y < 128 ? N : (N |= (127 & (Y = _e[this.pos++])) << 7, Y < 128 ? N : (N |= (127 & (Y = _e[this.pos++])) << 14, Y < 128 ? N : (N |= (127 & (Y = _e[this.pos++])) << 21, Y < 128 ? N : function (ke, ve, Te) { var je, Re, Ne = Te.buf; if (je = (112 & (Re = Ne[Te.pos++])) >> 4, Re < 128 || (je |= (127 & (Re = Ne[Te.pos++])) << 3, Re < 128) || (je |= (127 & (Re = Ne[Te.pos++])) << 10, Re < 128) || (je |= (127 & (Re = Ne[Te.pos++])) << 17, Re < 128) || (je |= (127 & (Re = Ne[Te.pos++])) << 24, Re < 128) || (je |= (1 & (Re = Ne[Te.pos++])) << 31, Re < 128)) return p(ke, je, ve); throw new Error("Expected varint not more than 10 bytes") }(N |= (15 & (Y = _e[this.pos])) << 28, D, this)))) }, readVarint64: function () { return this.readVarint(!0) }, readSVarint: function () { var D = this.readVarint(); return D % 2 == 1 ? (D + 1) / -2 : D / 2 }, readBoolean: function () { return !!this.readVarint() }, readString: function () { var D = this.readVarint() + this.pos, N = this.pos; return this.pos = D, D - N >= 12 && l ? function (Y, _e, ke) { return l.decode(Y.subarray(_e, ke)) }(this.buf, N, D) : function (Y, _e, ke) { for (var ve = "", Te = _e; Te < ke;) { var je, Re, Ne, Ce = Y[Te], Ye = null, ut = Ce > 239 ? 4 : Ce > 223 ? 3 : Ce > 191 ? 2 : 1; if (Te + ut > ke) break; ut === 1 ? Ce < 128 && (Ye = Ce) : ut === 2 ? (192 & (je = Y[Te + 1])) == 128 && (Ye = (31 & Ce) << 6 | 63 & je) <= 127 && (Ye = null) : ut === 3 ? (Re = Y[Te + 2], (192 & (je = Y[Te + 1])) == 128 && (192 & Re) == 128 && ((Ye = (15 & Ce) << 12 | (63 & je) << 6 | 63 & Re) <= 2047 || Ye >= 55296 && Ye <= 57343) && (Ye = null)) : ut === 4 && (Re = Y[Te + 2], Ne = Y[Te + 3], (192 & (je = Y[Te + 1])) == 128 && (192 & Re) == 128 && (192 & Ne) == 128 && ((Ye = (15 & Ce) << 18 | (63 & je) << 12 | (63 & Re) << 6 | 63 & Ne) <= 65535 || Ye >= 1114112) && (Ye = null)), Ye === null ? (Ye = 65533, ut = 1) : Ye > 65535 && (Ye -= 65536, ve += String.fromCharCode(Ye >>> 10 & 1023 | 55296), Ye = 56320 | 1023 & Ye), ve += String.fromCharCode(Ye), Te += ut } return ve }(this.buf, N, D) }, readBytes: function () { var D = this.readVarint() + this.pos, N = this.buf.subarray(this.pos, D); return this.pos = D, N }, readPackedVarint: function (D, N) { if (this.type !== t.Bytes) return D.push(this.readVarint(N)); var Y = d(this); for (D = D || []; this.pos < Y;)D.push(this.readVarint(N)); return D }, readPackedSVarint: function (D) { if (this.type !== t.Bytes) return D.push(this.readSVarint()); var N = d(this); for (D = D || []; this.pos < N;)D.push(this.readSVarint()); return D }, readPackedBoolean: function (D) { if (this.type !== t.Bytes) return D.push(this.readBoolean()); var N = d(this); for (D = D || []; this.pos < N;)D.push(this.readBoolean()); return D }, readPackedFloat: function (D) { if (this.type !== t.Bytes) return D.push(this.readFloat()); var N = d(this); for (D = D || []; this.pos < N;)D.push(this.readFloat()); return D }, readPackedDouble: function (D) { if (this.type !== t.Bytes) return D.push(this.readDouble()); var N = d(this); for (D = D || []; this.pos < N;)D.push(this.readDouble()); return D }, readPackedFixed32: function (D) { if (this.type !== t.Bytes) return D.push(this.readFixed32()); var N = d(this); for (D = D || []; this.pos < N;)D.push(this.readFixed32()); return D }, readPackedSFixed32: function (D) { if (this.type !== t.Bytes) return D.push(this.readSFixed32()); var N = d(this); for (D = D || []; this.pos < N;)D.push(this.readSFixed32()); return D }, readPackedFixed64: function (D) { if (this.type !== t.Bytes) return D.push(this.readFixed64()); var N = d(this); for (D = D || []; this.pos < N;)D.push(this.readFixed64()); return D }, readPackedSFixed64: function (D) { if (this.type !== t.Bytes) return D.push(this.readSFixed64()); var N = d(this); for (D = D || []; this.pos < N;)D.push(this.readSFixed64()); return D }, skip: function (D) { var N = 7 & D; if (N === t.Varint) for (; this.buf[this.pos++] > 127;); else if (N === t.Bytes) this.pos = this.readVarint() + this.pos; else if (N === t.Fixed32) this.pos += 4; else { if (N !== t.Fixed64) throw new Error("Unimplemented type: " + N); this.pos += 8 } }, writeTag: function (D, N) { this.writeVarint(D << 3 | N) }, realloc: function (D) { for (var N = this.length || 16; N < this.pos + D;)N *= 2; if (N !== this.length) { var Y = new Uint8Array(N); Y.set(this.buf), this.buf = Y, this.length = N } }, finish: function () { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length) }, writeFixed32: function (D) { this.realloc(4), se(this.buf, D, this.pos), this.pos += 4 }, writeSFixed32: function (D) { this.realloc(4), se(this.buf, D, this.pos), this.pos += 4 }, writeFixed64: function (D) { this.realloc(8), se(this.buf, -1 & D, this.pos), se(this.buf, Math.floor(D * s), this.pos + 4), this.pos += 8 }, writeSFixed64: function (D) { this.realloc(8), se(this.buf, -1 & D, this.pos), se(this.buf, Math.floor(D * s), this.pos + 4), this.pos += 8 }, writeVarint: function (D) { (D = +D || 0) > 268435455 || D < 0 ? function (N, Y) { var _e, ke; if (N >= 0 ? (_e = N % 4294967296 | 0, ke = N / 4294967296 | 0) : (ke = ~(-N / 4294967296), 4294967295 ^ (_e = ~(-N % 4294967296)) ? _e = _e + 1 | 0 : (_e = 0, ke = ke + 1 | 0)), N >= 18446744073709552e3 || N < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes"); Y.realloc(10), function (ve, Te, je) { je.buf[je.pos++] = 127 & ve | 128, ve >>>= 7, je.buf[je.pos++] = 127 & ve | 128, ve >>>= 7, je.buf[je.pos++] = 127 & ve | 128, ve >>>= 7, je.buf[je.pos++] = 127 & ve | 128, je.buf[je.pos] = 127 & (ve >>>= 7) }(_e, 0, Y), function (ve, Te) { var je = (7 & ve) << 4; Te.buf[Te.pos++] |= je | ((ve >>>= 3) ? 128 : 0), ve && (Te.buf[Te.pos++] = 127 & ve | ((ve >>>= 7) ? 128 : 0), ve && (Te.buf[Te.pos++] = 127 & ve | ((ve >>>= 7) ? 128 : 0), ve && (Te.buf[Te.pos++] = 127 & ve | ((ve >>>= 7) ? 128 : 0), ve && (Te.buf[Te.pos++] = 127 & ve | ((ve >>>= 7) ? 128 : 0), ve && (Te.buf[Te.pos++] = 127 & ve))))) }(ke, Y) }(D, this) : (this.realloc(4), this.buf[this.pos++] = 127 & D | (D > 127 ? 128 : 0), D <= 127 || (this.buf[this.pos++] = 127 & (D >>>= 7) | (D > 127 ? 128 : 0), D <= 127 || (this.buf[this.pos++] = 127 & (D >>>= 7) | (D > 127 ? 128 : 0), D <= 127 || (this.buf[this.pos++] = D >>> 7 & 127)))) }, writeSVarint: function (D) { this.writeVarint(D < 0 ? 2 * -D - 1 : 2 * D) }, writeBoolean: function (D) { this.writeVarint(!!D) }, writeString: function (D) { D = String(D), this.realloc(4 * D.length), this.pos++; var N = this.pos; this.pos = function (_e, ke, ve) { for (var Te, je, Re = 0; Re < ke.length; Re++) { if ((Te = ke.charCodeAt(Re)) > 55295 && Te < 57344) { if (!je) { Te > 56319 || Re + 1 === ke.length ? (_e[ve++] = 239, _e[ve++] = 191, _e[ve++] = 189) : je = Te; continue } if (Te < 56320) { _e[ve++] = 239, _e[ve++] = 191, _e[ve++] = 189, je = Te; continue } Te = je - 55296 << 10 | Te - 56320 | 65536, je = null } else je && (_e[ve++] = 239, _e[ve++] = 191, _e[ve++] = 189, je = null); Te < 128 ? _e[ve++] = Te : (Te < 2048 ? _e[ve++] = Te >> 6 | 192 : (Te < 65536 ? _e[ve++] = Te >> 12 | 224 : (_e[ve++] = Te >> 18 | 240, _e[ve++] = Te >> 12 & 63 | 128), _e[ve++] = Te >> 6 & 63 | 128), _e[ve++] = 63 & Te | 128) } return ve }(this.buf, D, this.pos); var Y = this.pos - N; Y >= 128 && _(N, Y, this), this.pos = N - 1, this.writeVarint(Y), this.pos += Y }, writeFloat: function (D) { this.realloc(4), r.write(this.buf, D, this.pos, !0, 23, 4), this.pos += 4 }, writeDouble: function (D) { this.realloc(8), r.write(this.buf, D, this.pos, !0, 52, 8), this.pos += 8 }, writeBytes: function (D) { var N = D.length; this.writeVarint(N), this.realloc(N); for (var Y = 0; Y < N; Y++)this.buf[this.pos++] = D[Y] }, writeRawMessage: function (D, N) { this.pos++; var Y = this.pos; D(N, this); var _e = this.pos - Y; _e >= 128 && _(Y, _e, this), this.pos = Y - 1, this.writeVarint(_e), this.pos += _e }, writeMessage: function (D, N, Y) { this.writeTag(D, t.Bytes), this.writeRawMessage(N, Y) }, writePackedVarint: function (D, N) { N.length && this.writeMessage(D, y, N) }, writePackedSVarint: function (D, N) { N.length && this.writeMessage(D, b, N) }, writePackedBoolean: function (D, N) { N.length && this.writeMessage(D, k, N) }, writePackedFloat: function (D, N) { N.length && this.writeMessage(D, T, N) }, writePackedDouble: function (D, N) { N.length && this.writeMessage(D, M, N) }, writePackedFixed32: function (D, N) { N.length && this.writeMessage(D, R, N) }, writePackedSFixed32: function (D, N) { N.length && this.writeMessage(D, L, N) }, writePackedFixed64: function (D, N) { N.length && this.writeMessage(D, O, N) }, writePackedSFixed64: function (D, N) { N.length && this.writeMessage(D, U, N) }, writeBytesField: function (D, N) { this.writeTag(D, t.Bytes), this.writeBytes(N) }, writeFixed32Field: function (D, N) { this.writeTag(D, t.Fixed32), this.writeFixed32(N) }, writeSFixed32Field: function (D, N) { this.writeTag(D, t.Fixed32), this.writeSFixed32(N) }, writeFixed64Field: function (D, N) { this.writeTag(D, t.Fixed64), this.writeFixed64(N) }, writeSFixed64Field: function (D, N) { this.writeTag(D, t.Fixed64), this.writeSFixed64(N) }, writeVarintField: function (D, N) { this.writeTag(D, t.Varint), this.writeVarint(N) }, writeSVarintField: function (D, N) { this.writeTag(D, t.Varint), this.writeSVarint(N) }, writeStringField: function (D, N) { this.writeTag(D, t.Bytes), this.writeString(N) }, writeFloatField: function (D, N) { this.writeTag(D, t.Fixed32), this.writeFloat(N) }, writeDoubleField: function (D, N) { this.writeTag(D, t.Fixed64), this.writeDouble(N) }, writeBooleanField: function (D, N) { this.writeVarintField(D, !!N) } }, qh } var Wh = de(Zp()); const Xh = 3; function hg(r, t, n) { r === 1 && n.readMessage(dg, t) } function dg(r, t, n) { if (r === 3) { const { id: s, bitmap: l, width: d, height: p, left: _, top: y, advance: b } = n.readMessage(pg, {}); t.push({ id: s, bitmap: new $l({ width: d + 2 * Xh, height: p + 2 * Xh }, l), metrics: { width: d, height: p, left: _, top: y, advance: b } }) } } function pg(r, t, n) { r === 1 ? t.id = n.readVarint() : r === 2 ? t.bitmap = n.readBytes() : r === 3 ? t.width = n.readVarint() : r === 4 ? t.height = n.readVarint() : r === 5 ? t.left = n.readSVarint() : r === 6 ? t.top = n.readSVarint() : r === 7 && (t.advance = n.readVarint()) } const fg = Xh; function Up(r) { let t = 0, n = 0; for (const p of r) t += p.w * p.h, n = Math.max(n, p.w); r.sort((p, _) => _.h - p.h); const s = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / .95)), n), h: 1 / 0 }]; let l = 0, d = 0; for (const p of r) for (let _ = s.length - 1; _ >= 0; _--) { const y = s[_]; if (!(p.w > y.w || p.h > y.h)) { if (p.x = y.x, p.y = y.y, d = Math.max(d, p.y + p.h), l = Math.max(l, p.x + p.w), p.w === y.w && p.h === y.h) { const b = s.pop(); _ < s.length && (s[_] = b) } else p.h === y.h ? (y.x += p.w, y.w -= p.w) : p.w === y.w ? (y.y += p.h, y.h -= p.h) : (s.push({ x: y.x + p.w, y: y.y, w: y.w - p.w, h: p.h }), y.y += p.h, y.h -= p.h); break } } return { w: l, h: d, fill: t / (l * d) || 0 } } const Pr = 1; class Kh { constructor(t, { pixelRatio: n, version: s, stretchX: l, stretchY: d, content: p, textFitWidth: _, textFitHeight: y }) { this.paddedRect = t, this.pixelRatio = n, this.stretchX = l, this.stretchY = d, this.content = p, this.version = s, this.textFitWidth = _, this.textFitHeight = y } get tl() { return [this.paddedRect.x + Pr, this.paddedRect.y + Pr] } get br() { return [this.paddedRect.x + this.paddedRect.w - Pr, this.paddedRect.y + this.paddedRect.h - Pr] } get tlbr() { return this.tl.concat(this.br) } get displaySize() { return [(this.paddedRect.w - 2 * Pr) / this.pixelRatio, (this.paddedRect.h - 2 * Pr) / this.pixelRatio] } } class $p { constructor(t, n) { const s = {}, l = {}; this.haveRenderCallbacks = []; const d = []; this.addImages(t, s, d), this.addImages(n, l, d); const { w: p, h: _ } = Up(d), y = new Yr({ width: p || 1, height: _ || 1 }); for (const b in t) { const T = t[b], M = s[b].paddedRect; Yr.copy(T.data, y, { x: 0, y: 0 }, { x: M.x + Pr, y: M.y + Pr }, T.data) } for (const b in n) { const T = n[b], M = l[b].paddedRect, k = M.x + Pr, R = M.y + Pr, L = T.data.width, O = T.data.height; Yr.copy(T.data, y, { x: 0, y: 0 }, { x: k, y: R }, T.data), Yr.copy(T.data, y, { x: 0, y: O - 1 }, { x: k, y: R - 1 }, { width: L, height: 1 }), Yr.copy(T.data, y, { x: 0, y: 0 }, { x: k, y: R + O }, { width: L, height: 1 }), Yr.copy(T.data, y, { x: L - 1, y: 0 }, { x: k - 1, y: R }, { width: 1, height: O }), Yr.copy(T.data, y, { x: 0, y: 0 }, { x: k + L, y: R }, { width: 1, height: O }) } this.image = y, this.iconPositions = s, this.patternPositions = l } addImages(t, n, s) { for (const l in t) { const d = t[l], p = { x: 0, y: 0, w: d.data.width + 2 * Pr, h: d.data.height + 2 * Pr }; s.push(p), n[l] = new Kh(p, d), d.hasRenderCallback && this.haveRenderCallbacks.push(l) } } patchUpdatedImages(t, n) { t.dispatchRenderCallbacks(this.haveRenderCallbacks); for (const s in t.updatedImages) this.patchUpdatedImage(this.iconPositions[s], t.getImage(s), n), this.patchUpdatedImage(this.patternPositions[s], t.getImage(s), n) } patchUpdatedImage(t, n, s) { if (!t || !n || t.version === n.version) return; t.version = n.version; const [l, d] = t.tl; s.update(n.data, void 0, { x: l, y: d }) } } var Rs; Je("ImagePosition", Kh), Je("ImageAtlas", $p), P.ag = void 0, (Rs = P.ag || (P.ag = {}))[Rs.none = 0] = "none", Rs[Rs.horizontal = 1] = "horizontal", Rs[Rs.vertical = 2] = "vertical", Rs[Rs.horizontalOnly = 3] = "horizontalOnly"; const Iu = -17; class tc { constructor() { this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom" } static forText(t, n, s) { const l = new tc; return l.scale = t || 1, l.fontStack = n, l.verticalAlign = s || "bottom", l } static forImage(t, n) { const s = new tc; return s.imageName = t, s.verticalAlign = n || "bottom", s } } class Ta { constructor() { this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null } static fromFeature(t, n) { const s = new Ta; for (let l = 0; l < t.sections.length; l++) { const d = t.sections[l]; d.image ? s.addImageSection(d) : s.addTextSection(d, n) } return s } length() { return this.text.length } getSection(t) { return this.sections[this.sectionIndex[t]] } getSectionIndex(t) { return this.sectionIndex[t] } getCharCode(t) { return this.text.charCodeAt(t) } verticalizePunctuation() { this.text = function (t) { let n = ""; for (let s = 0; s < t.length; s++) { const l = t.charCodeAt(s + 1) || null, d = t.charCodeAt(s - 1) || null; n += l && kl(l) && !ec[t[s + 1]] || d && kl(d) && !ec[t[s - 1]] || !ec[t[s]] ? t[s] : ec[t[s]] } return n }(this.text) } trim() { let t = 0; for (let s = 0; s < this.text.length && Eu[this.text.charCodeAt(s)]; s++)t++; let n = this.text.length; for (let s = this.text.length - 1; s >= 0 && s >= t && Eu[this.text.charCodeAt(s)]; s--)n--; this.text = this.text.substring(t, n), this.sectionIndex = this.sectionIndex.slice(t, n) } substring(t, n) { const s = new Ta; return s.text = this.text.substring(t, n), s.sectionIndex = this.sectionIndex.slice(t, n), s.sections = this.sections, s } toString() { return this.text } getMaxScale() { return this.sectionIndex.reduce((t, n) => Math.max(t, this.sections[n].scale), 0) } getMaxImageSize(t) { let n = 0, s = 0; for (let l = 0; l < this.length(); l++) { const d = this.getSection(l); if (d.imageName) { const p = t[d.imageName]; if (!p) continue; const _ = p.displaySize; n = Math.max(n, _[0]), s = Math.max(s, _[1]) } } return { maxImageWidth: n, maxImageHeight: s } } addTextSection(t, n) { this.text += t.text, this.sections.push(tc.forText(t.scale, t.fontStack || n, t.verticalAlign)); const s = this.sections.length - 1; for (let l = 0; l < t.text.length; ++l)this.sectionIndex.push(s) } addImageSection(t) { const n = t.image ? t.image.name : ""; if (n.length === 0) return void Ui("Can't add FormattedSection with an empty image."); const s = this.getNextImageSectionCharCode(); s ? (this.text += String.fromCharCode(s), this.sections.push(tc.forImage(n, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Ui("Reached maximum number of images 6401") } getNextImageSectionCharCode() { return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID) } } function Cu(r, t, n, s, l, d, p, _, y, b, T, M, k, R, L) { const O = Ta.fromFeature(r, l); let U; M === P.ag.vertical && O.verticalizePunctuation(); const { processBidirectionalText: W, processStyledBidirectionalText: se } = zn; if (W && O.sections.length === 1) { U = []; const N = W(O.toString(), Jh(O, b, d, t, s, R)); for (const Y of N) { const _e = new Ta; _e.text = Y, _e.sections = O.sections; for (let ke = 0; ke < Y.length; ke++)_e.sectionIndex.push(0); U.push(_e) } } else if (se) { U = []; const N = se(O.text, O.sectionIndex, Jh(O, b, d, t, s, R)); for (const Y of N) { const _e = new Ta; _e.text = Y[0], _e.sectionIndex = Y[1], _e.sections = O.sections, U.push(_e) } } else U = function (N, Y) { const _e = [], ke = N.text; let ve = 0; for (const Te of Y) _e.push(N.substring(ve, Te)), ve = Te; return ve < ke.length && _e.push(N.substring(ve, ke.length)), _e }(O, Jh(O, b, d, t, s, R)); const J = [], D = { positionedLines: J, text: O.toString(), top: T[1], bottom: T[1], left: T[0], right: T[0], writingMode: M, iconsInText: !1, verticalizable: !1 }; return function (N, Y, _e, ke, ve, Te, je, Re, Ne, Ce, Ye, ut) { let lt = 0, it = 0, St = 0, fi = 0; const zi = Re === "right" ? 1 : Re === "left" ? 0 : .5, tr = Ai / ut; let en = 0; for (const ai of ve) { ai.trim(); const Bi = ai.getMaxScale(), Wi = { positionedGlyphs: [], lineOffset: 0 }; N.positionedLines[en] = Wi; const Xi = Wi.positionedGlyphs; let _r = 0; if (!ai.length()) { it += Te, ++en; continue } const tn = yg(ke, ai, tr); for (let Mr = 0; Mr < ai.length(); Mr++) { const ki = ai.getSection(Mr), ji = ai.getSectionIndex(Mr), Vi = ai.getCharCode(Mr), Pi = xg(Ne, Ye, Vi); let ti; if (ki.imageName) { if (N.iconsInText = !0, ki.scale = ki.scale * tr, ti = bg(ki, Pi, Bi, tn, ke), !ti) continue; _r = Math.max(_r, ti.imageOffset) } else if (ti = vg(ki, Vi, Pi, tn, Y, _e), !ti) continue; const { rect: xn, metrics: Ia, baselineOffset: vn } = ti; Xi.push({ glyph: Vi, imageName: ki.imageName, x: lt, y: it + vn + Iu, vertical: Pi, scale: ki.scale, fontStack: ki.fontStack, sectionIndex: ji, metrics: Ia, rect: xn }), Pi ? (N.verticalizable = !0, lt += (ki.imageName ? Ia.advance : Ai) * ki.scale + Ce) : lt += Ia.advance * ki.scale + Ce } Xi.length !== 0 && (St = Math.max(lt - Ce, St), wg(Xi, 0, Xi.length - 1, zi)), lt = 0, Wi.lineOffset = Math.max(_r, (Bi - 1) * Ai); const Oi = Te * Bi + _r; it += Oi, fi = Math.max(Oi, fi), ++en } const { horizontalAlign: Sr, verticalAlign: Hi } = Yh(je); (function (ai, Bi, Wi, Xi, _r, tn, Oi, Mr, ki) { const ji = (Bi - Wi) * _r; let Vi = 0; Vi = tn !== Oi ? -Mr * Xi - Iu : -Xi * ki * Oi + .5 * Oi; for (const Pi of ai) for (const ti of Pi.positionedGlyphs) ti.x += ji, ti.y += Vi })(N.positionedLines, zi, Sr, Hi, St, fi, Te, it, ve.length), N.top += -Hi * it, N.bottom = N.top + it, N.left += -Sr * St, N.right = N.left + St }(D, t, n, s, U, p, _, y, M, b, k, L), !function (N) { for (const Y of N) if (Y.positionedGlyphs.length !== 0) return !1; return !0 }(J) && D } const Eu = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, mg = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, _g = { 40: !0 }; function Gp(r, t, n, s, l, d) { if (t.imageName) { const p = s[t.imageName]; return p ? p.displaySize[0] * t.scale * Ai / d + l : 0 } { const p = n[t.fontStack], _ = p && p[r]; return _ ? _.metrics.advance * t.scale + l : 0 } } function qp(r, t, n, s) { const l = Math.pow(r - t, 2); return s ? r < t ? l / 2 : 2 * l : l + Math.abs(n) * n } function gg(r, t, n) { let s = 0; return r === 10 && (s -= 1e4), n && (s += 150), r !== 40 && r !== 65288 || (s += 50), t !== 41 && t !== 65289 || (s += 50), s } function Hp(r, t, n, s, l, d) { let p = null, _ = qp(t, n, l, d); for (const y of s) { const b = qp(t - y.x, n, l, d) + y.badness; b <= _ && (p = y, _ = b) } return { index: r, x: t, priorBreak: p, badness: _ } } function Wp(r) { return r ? Wp(r.priorBreak).concat(r.index) : [] } function Jh(r, t, n, s, l, d) { if (!r) return []; const p = [], _ = function (M, k, R, L, O, U) { let W = 0; for (let se = 0; se < M.length(); se++) { const J = M.getSection(se); W += Gp(M.getCharCode(se), J, L, O, k, U) } return W / Math.max(1, Math.ceil(W / R)) }(r, t, n, s, l, d), y = r.text.indexOf("​") >= 0; let b = 0; for (let M = 0; M < r.length(); M++) { const k = r.getSection(M), R = r.getCharCode(M); if (Eu[R] || (b += Gp(R, k, s, l, t, d)), M < r.length() - 1) { const L = !((T = R) < 11904) && (!!wt["CJK Compatibility Forms"](T) || !!wt["CJK Compatibility"](T) || !!wt["CJK Strokes"](T) || !!wt["CJK Symbols and Punctuation"](T) || !!wt["Enclosed CJK Letters and Months"](T) || !!wt["Halfwidth and Fullwidth Forms"](T) || !!wt["Ideographic Description Characters"](T) || !!wt["Vertical Forms"](T) || Al.test(String.fromCodePoint(T))); (mg[R] || L || k.imageName || M !== r.length() - 2 && _g[r.getCharCode(M + 1)]) && p.push(Hp(M + 1, b, _, p, gg(R, r.getCharCode(M + 1), L && y), !1)) } } var T; return Wp(Hp(r.length(), b, _, p, 0, !0)) } function Yh(r) { let t = .5, n = .5; switch (r) { case "right": case "top-right": case "bottom-right": t = 1; break; case "left": case "top-left": case "bottom-left": t = 0 }switch (r) { case "bottom": case "bottom-right": case "bottom-left": n = 1; break; case "top": case "top-right": case "top-left": n = 0 }return { horizontalAlign: t, verticalAlign: n } } function yg(r, t, n) { const s = t.getMaxScale() * Ai, { maxImageWidth: l, maxImageHeight: d } = t.getMaxImageSize(r), p = Math.max(s, d * n); return { verticalLineContentWidth: Math.max(s, l * n), horizontalLineContentHeight: p } } function Xp(r) { switch (r) { case "top": return 0; case "center": return .5; default: return 1 } } function xg(r, t, n) { return !(r === P.ag.horizontal || !t && !zl(n) || t && (Eu[n] || (s = n, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(s))))); var s } function vg(r, t, n, s, l, d) { const p = d[r.fontStack], _ = function (b, T, M, k) { if (b && b.rect) return b; const R = T[M.fontStack], L = R && R[k]; return L ? { rect: null, metrics: L.metrics } : null }(p && p[t], l, r, t); if (_ === null) return null; let y; if (n) y = s.verticalLineContentWidth - r.scale * Ai; else { const b = Xp(r.verticalAlign); y = (s.horizontalLineContentHeight - r.scale * Ai) * b } return { rect: _.rect, metrics: _.metrics, baselineOffset: y } } function bg(r, t, n, s, l) { const d = l[r.imageName]; if (!d) return null; const p = d.paddedRect, _ = d.displaySize, y = { width: _[0], height: _[1], left: Pr, top: -3, advance: t ? _[1] : _[0] }; let b; if (t) b = s.verticalLineContentWidth - _[1] * r.scale; else { const T = Xp(r.verticalAlign); b = (s.horizontalLineContentHeight - _[1] * r.scale) * T } return { rect: p, metrics: y, baselineOffset: b, imageOffset: (t ? _[0] : _[1]) * r.scale - Ai * n } } function wg(r, t, n, s) { if (s === 0) return; const l = r[n], d = (r[n].x + l.metrics.advance * l.scale) * s; for (let p = t; p <= n; p++)r[p].x -= d } function Tg(r, t, n) { const { horizontalAlign: s, verticalAlign: l } = Yh(n), d = t[0] - r.displaySize[0] * s, p = t[1] - r.displaySize[1] * l; return { image: r, top: p, bottom: p + r.displaySize[1], left: d, right: d + r.displaySize[0] } } function Kp(r) { var t, n; let s = r.left, l = r.top, d = r.right - s, p = r.bottom - l; const _ = (t = r.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink", y = (n = r.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink", b = (r.image.content[2] - r.image.content[0]) / (r.image.content[3] - r.image.content[1]); if (y === "proportional") { if (_ === "stretchOnly" && d / p < b || _ === "proportional") { const T = Math.ceil(p * b); s *= T / d, d = T } } else if (_ === "proportional" && y === "stretchOnly" && b !== 0 && d / p > b) { const T = Math.ceil(d / b); l *= T / p, p = T } return { x1: s, y1: l, x2: s + d, y2: l + p } } function Jp(r, t, n, s, l, d) { const p = r.image; let _; if (p.content) { const U = p.content, W = p.pixelRatio || 1; _ = [U[0] / W, U[1] / W, p.displaySize[0] - U[2] / W, p.displaySize[1] - U[3] / W] } const y = t.left * d, b = t.right * d; let T, M, k, R; n === "width" || n === "both" ? (R = l[0] + y - s[3], M = l[0] + b + s[1]) : (R = l[0] + (y + b - p.displaySize[0]) / 2, M = R + p.displaySize[0]); const L = t.top * d, O = t.bottom * d; return n === "height" || n === "both" ? (T = l[1] + L - s[0], k = l[1] + O + s[2]) : (T = l[1] + (L + O - p.displaySize[1]) / 2, k = T + p.displaySize[1]), { image: p, top: T, right: M, bottom: k, left: R, collisionPadding: _ } } const ic = 255, Dn = 128, Ls = ic * Dn; function Yp(r, t) { const { expression: n } = t; if (n.kind === "constant") return { kind: "constant", layoutSize: n.evaluate(new si(r + 1)) }; if (n.kind === "source") return { kind: "source" }; { const { zoomStops: s, interpolationType: l } = n; let d = 0; for (; d < s.length && s[d] <= r;)d++; d = Math.max(0, d - 1); let p = d; for (; p < s.length && s[p] < r + 1;)p++; p = Math.min(s.length - 1, p); const _ = s[d], y = s[p]; return n.kind === "composite" ? { kind: "composite", minZoom: _, maxZoom: y, interpolationType: l } : { kind: "camera", minZoom: _, maxZoom: y, minSize: n.evaluate(new si(_)), maxSize: n.evaluate(new si(y)), interpolationType: l } } } function Qh(r, t, n) { let s = "never"; const l = r.get(t); return l ? s = l : r.get(n) && (s = "always"), s } const Pg = Jl.VectorTileFeature.types, Sg = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }]; function Au(r, t, n, s, l, d, p, _, y, b, T, M, k) { const R = _ ? Math.min(Ls, Math.round(_[0])) : 0, L = _ ? Math.min(Ls, Math.round(_[1])) : 0; r.emplaceBack(t, n, Math.round(32 * s), Math.round(32 * l), d, p, (R << 1) + (y ? 1 : 0), L, 16 * b, 16 * T, 256 * M, 256 * k) } function ed(r, t, n) { r.emplaceBack(t.x, t.y, n), r.emplaceBack(t.x, t.y, n), r.emplaceBack(t.x, t.y, n), r.emplaceBack(t.x, t.y, n) } function Mg(r) { for (const t of r.sections) if (pu(t.text)) return !0; return !1 } class td { constructor(t) { this.layoutVertexArray = new me, this.indexArray = new $e, this.programConfigurations = t, this.segments = new st, this.dynamicLayoutVertexArray = new ge, this.opacityVertexArray = new Se, this.hasVisibleVertices = !1, this.placedSymbolArray = new v } isEmpty() { return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0 } upload(t, n, s, l) { this.isEmpty() || (s && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, sg.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, og.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Sg, !0), this.opacityVertexBuffer.itemSize = 1), (s || l) && this.programConfigurations.upload(t)) } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy()) } } Je("SymbolBuffers", td); class id { constructor(t, n, s) { this.layoutVertexArray = new t, this.layoutAttributes = n, this.indexArray = new s, this.segments = new st, this.collisionVertexArray = new Pe } upload(t) { this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, ag.members, !0) } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy()) } } Je("CollisionBuffers", id); class Pa { constructor(t) { this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(p => p.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = []; const n = this.layers[0]._unevaluatedLayout._values; this.textSizeData = Yp(this.zoom, n["text-size"]), this.iconSizeData = Yp(this.zoom, n["icon-size"]); const s = this.layers[0].layout, l = s.get("symbol-sort-key"), d = s.get("symbol-z-order"); this.canOverlap = Qh(s, "text-overlap", "text-allow-overlap") !== "never" || Qh(s, "icon-overlap", "icon-allow-overlap") !== "never" || s.get("text-ignore-placement") || s.get("icon-ignore-placement"), this.sortFeaturesByKey = d !== "viewport-y" && !l.isConstant(), this.sortFeaturesByY = (d === "viewport-y" || d === "auto" && !this.sortFeaturesByKey) && this.canOverlap, s.get("symbol-placement") === "point" && (this.writingModes = s.get("text-writing-mode").map(p => P.ag[p])), this.stateDependentLayerIds = this.layers.filter(p => p.isStateDependent()).map(p => p.id), this.sourceID = t.sourceID } createArrays() { this.text = new td(new os(this.layers, this.zoom, t => /^text/.test(t))), this.icon = new td(new os(this.layers, this.zoom, t => /^icon/.test(t))), this.glyphOffsetArray = new E, this.lineVertexArray = new A, this.symbolInstances = new I, this.textAnchorOffsets = new j } calculateGlyphDependencies(t, n, s, l, d) { for (let p = 0; p < t.length; p++)if (n[t.charCodeAt(p)] = !0, (s || l) && d) { const _ = ec[t.charAt(p)]; _ && (n[_.charCodeAt(0)] = !0) } } populate(t, n, s) { const l = this.layers[0], d = l.layout, p = d.get("text-font"), _ = d.get("text-field"), y = d.get("icon-image"), b = (_.value.kind !== "constant" || _.value.value instanceof Gi && !_.value.value.isEmpty() || _.value.value.toString().length > 0) && (p.value.kind !== "constant" || p.value.value.length > 0), T = y.value.kind !== "constant" || !!y.value.value || Object.keys(y.parameters).length > 0, M = d.get("symbol-sort-key"); if (this.features = [], !b && !T) return; const k = n.iconDependencies, R = n.glyphDependencies, L = n.availableImages, O = new si(this.zoom); for (const { feature: U, id: W, index: se, sourceLayerIndex: J } of t) { const D = l._featureFilter.needGeometry, N = Tr(U, D); if (!l._featureFilter.filter(O, N, s)) continue; let Y, _e; if (D || (N.geometry = as(U)), b) { const ve = l.getValueAndResolveTokens("text-field", N, s, L), Te = Gi.factory(ve), je = this.hasRTLText = this.hasRTLText || Mg(Te); (!je || zn.getRTLTextPluginStatus() === "unavailable" || je && zn.isParsed()) && (Y = cg(Te, l, N)) } if (T) { const ve = l.getValueAndResolveTokens("icon-image", N, s, L); _e = ve instanceof nr ? ve : nr.fromString(ve) } if (!Y && !_e) continue; const ke = this.sortFeaturesByKey ? M.evaluate(N, {}, s) : void 0; if (this.features.push({ id: W, text: Y, icon: _e, index: se, sourceLayerIndex: J, geometry: N.geometry, properties: U.properties, type: Pg[U.type], sortKey: ke }), _e && (k[_e.name] = !0), Y) { const ve = p.evaluate(N, {}, s).join(","), Te = d.get("text-rotation-alignment") !== "viewport" && d.get("symbol-placement") !== "point"; this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(P.ag.vertical) >= 0; for (const je of Y.sections) if (je.image) k[je.image.name] = !0; else { const Re = na(Y.toString()), Ne = je.fontStack || ve, Ce = R[Ne] = R[Ne] || {}; this.calculateGlyphDependencies(je.text, Ce, Te, this.allowVerticalPlacement, Re) } } } d.get("symbol-placement") === "line" && (this.features = function (U) { const W = {}, se = {}, J = []; let D = 0; function N(ve) { J.push(U[ve]), D++ } function Y(ve, Te, je) { const Re = se[ve]; return delete se[ve], se[Te] = Re, J[Re].geometry[0].pop(), J[Re].geometry[0] = J[Re].geometry[0].concat(je[0]), Re } function _e(ve, Te, je) { const Re = W[Te]; return delete W[Te], W[ve] = Re, J[Re].geometry[0].shift(), J[Re].geometry[0] = je[0].concat(J[Re].geometry[0]), Re } function ke(ve, Te, je) { const Re = je ? Te[0][Te[0].length - 1] : Te[0][0]; return `${ve}:${Re.x}:${Re.y}` } for (let ve = 0; ve < U.length; ve++) { const Te = U[ve], je = Te.geometry, Re = Te.text ? Te.text.toString() : null; if (!Re) { N(ve); continue } const Ne = ke(Re, je), Ce = ke(Re, je, !0); if (Ne in se && Ce in W && se[Ne] !== W[Ce]) { const Ye = _e(Ne, Ce, je), ut = Y(Ne, Ce, J[Ye].geometry); delete W[Ne], delete se[Ce], se[ke(Re, J[ut].geometry, !0)] = ut, J[Ye].geometry = null } else Ne in se ? Y(Ne, Ce, je) : Ce in W ? _e(Ne, Ce, je) : (N(ve), W[Ne] = D - 1, se[Ce] = D - 1) } return J.filter(ve => ve.geometry) }(this.features)), this.sortFeaturesByKey && this.features.sort((U, W) => U.sortKey - W.sortKey) } update(t, n, s) { this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, s), this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, s)) } isEmpty() { return this.symbolInstances.length === 0 && !this.hasRTLText } uploadPending() { return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload } upload(t) { !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0 } destroyDebugData() { this.textCollisionBox.destroy(), this.iconCollisionBox.destroy() } destroy() { this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData() } addToLineVertexArray(t, n) { const s = this.lineVertexArray.length; if (t.segment !== void 0) { let l = t.dist(n[t.segment + 1]), d = t.dist(n[t.segment]); const p = {}; for (let _ = t.segment + 1; _ < n.length; _++)p[_] = { x: n[_].x, y: n[_].y, tileUnitDistanceFromAnchor: l }, _ < n.length - 1 && (l += n[_ + 1].dist(n[_])); for (let _ = t.segment || 0; _ >= 0; _--)p[_] = { x: n[_].x, y: n[_].y, tileUnitDistanceFromAnchor: d }, _ > 0 && (d += n[_ - 1].dist(n[_])); for (let _ = 0; _ < n.length; _++) { const y = p[_]; this.lineVertexArray.emplaceBack(y.x, y.y, y.tileUnitDistanceFromAnchor) } } return { lineStartIndex: s, lineLength: this.lineVertexArray.length - s } } addSymbols(t, n, s, l, d, p, _, y, b, T, M, k) { const R = t.indexArray, L = t.layoutVertexArray, O = t.segments.prepareSegment(4 * n.length, L, R, this.canOverlap ? p.sortKey : void 0), U = this.glyphOffsetArray.length, W = O.vertexLength, se = this.allowVerticalPlacement && _ === P.ag.vertical ? Math.PI / 2 : 0, J = p.text && p.text.sections; for (let D = 0; D < n.length; D++) { const { tl: N, tr: Y, bl: _e, br: ke, tex: ve, pixelOffsetTL: Te, pixelOffsetBR: je, minFontScaleX: Re, minFontScaleY: Ne, glyphOffset: Ce, isSDF: Ye, sectionIndex: ut } = n[D], lt = O.vertexLength, it = Ce[1]; Au(L, y.x, y.y, N.x, it + N.y, ve.x, ve.y, s, Ye, Te.x, Te.y, Re, Ne), Au(L, y.x, y.y, Y.x, it + Y.y, ve.x + ve.w, ve.y, s, Ye, je.x, Te.y, Re, Ne), Au(L, y.x, y.y, _e.x, it + _e.y, ve.x, ve.y + ve.h, s, Ye, Te.x, je.y, Re, Ne), Au(L, y.x, y.y, ke.x, it + ke.y, ve.x + ve.w, ve.y + ve.h, s, Ye, je.x, je.y, Re, Ne), ed(t.dynamicLayoutVertexArray, y, se), R.emplaceBack(lt, lt + 2, lt + 1), R.emplaceBack(lt + 1, lt + 2, lt + 3), O.vertexLength += 4, O.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Ce[0]), D !== n.length - 1 && ut === n[D + 1].sectionIndex || t.programConfigurations.populatePaintArrays(L.length, p, p.index, {}, k, J && J[ut]) } t.placedSymbolArray.emplaceBack(y.x, y.y, U, this.glyphOffsetArray.length - U, W, b, T, y.segment, s ? s[0] : 0, s ? s[1] : 0, l[0], l[1], _, 0, !1, 0, M) } _addCollisionDebugVertex(t, n, s, l, d, p) { return n.emplaceBack(0, 0), t.emplaceBack(s.x, s.y, l, d, Math.round(p.x), Math.round(p.y)) } addCollisionDebugVertices(t, n, s, l, d, p, _) { const y = d.segments.prepareSegment(4, d.layoutVertexArray, d.indexArray), b = y.vertexLength, T = d.layoutVertexArray, M = d.collisionVertexArray, k = _.anchorX, R = _.anchorY; this._addCollisionDebugVertex(T, M, p, k, R, new Ge(t, n)), this._addCollisionDebugVertex(T, M, p, k, R, new Ge(s, n)), this._addCollisionDebugVertex(T, M, p, k, R, new Ge(s, l)), this._addCollisionDebugVertex(T, M, p, k, R, new Ge(t, l)), y.vertexLength += 4; const L = d.indexArray; L.emplaceBack(b, b + 1), L.emplaceBack(b + 1, b + 2), L.emplaceBack(b + 2, b + 3), L.emplaceBack(b + 3, b), y.primitiveLength += 4 } addDebugCollisionBoxes(t, n, s, l) { for (let d = t; d < n; d++) { const p = this.collisionBoxArray.get(d); this.addCollisionDebugVertices(p.x1, p.y1, p.x2, p.y2, l ? this.textCollisionBox : this.iconCollisionBox, p.anchorPoint, s) } } generateCollisionDebugBuffers() { this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new id(Ie, jp.members, Ue), this.iconCollisionBox = new id(Ie, jp.members, Ue); for (let t = 0; t < this.symbolInstances.length; t++) { const n = this.symbolInstances.get(t); this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0), this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1), this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1) } } _deserializeCollisionBoxesForSymbol(t, n, s, l, d, p, _, y, b) { const T = {}; for (let M = n; M < s; M++) { const k = t.get(M); T.textBox = { x1: k.x1, y1: k.y1, x2: k.x2, y2: k.y2, anchorPointX: k.anchorPointX, anchorPointY: k.anchorPointY }, T.textFeatureIndex = k.featureIndex; break } for (let M = l; M < d; M++) { const k = t.get(M); T.verticalTextBox = { x1: k.x1, y1: k.y1, x2: k.x2, y2: k.y2, anchorPointX: k.anchorPointX, anchorPointY: k.anchorPointY }, T.verticalTextFeatureIndex = k.featureIndex; break } for (let M = p; M < _; M++) { const k = t.get(M); T.iconBox = { x1: k.x1, y1: k.y1, x2: k.x2, y2: k.y2, anchorPointX: k.anchorPointX, anchorPointY: k.anchorPointY }, T.iconFeatureIndex = k.featureIndex; break } for (let M = y; M < b; M++) { const k = t.get(M); T.verticalIconBox = { x1: k.x1, y1: k.y1, x2: k.x2, y2: k.y2, anchorPointX: k.anchorPointX, anchorPointY: k.anchorPointY }, T.verticalIconFeatureIndex = k.featureIndex; break } return T } deserializeCollisionBoxes(t) { this.collisionArrays = []; for (let n = 0; n < this.symbolInstances.length; n++) { const s = this.symbolInstances.get(n); this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, s.textBoxStartIndex, s.textBoxEndIndex, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s.iconBoxStartIndex, s.iconBoxEndIndex, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex)) } } hasTextData() { return this.text.segments.get().length > 0 } hasIconData() { return this.icon.segments.get().length > 0 } hasDebugData() { return this.textCollisionBox && this.iconCollisionBox } hasTextCollisionBoxData() { return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0 } hasIconCollisionBoxData() { return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0 } addIndicesForPlacedSymbol(t, n) { const s = t.placedSymbolArray.get(n), l = s.vertexStartIndex + 4 * s.numGlyphs; for (let d = s.vertexStartIndex; d < l; d += 4)t.indexArray.emplaceBack(d, d + 2, d + 1), t.indexArray.emplaceBack(d + 1, d + 2, d + 3) } getSortedSymbolIndexes(t) { if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes; const n = Math.sin(t), s = Math.cos(t), l = [], d = [], p = []; for (let _ = 0; _ < this.symbolInstances.length; ++_) { p.push(_); const y = this.symbolInstances.get(_); l.push(0 | Math.round(n * y.anchorX + s * y.anchorY)), d.push(y.featureIndex) } return p.sort((_, y) => l[_] - l[y] || d[y] - d[_]), p } addToSortKeyRanges(t, n) { const s = this.sortKeyRanges[this.sortKeyRanges.length - 1]; s && s.sortKey === n ? s.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: t, symbolInstanceEnd: t + 1 }) } sortFeatures(t) { if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) { this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = []; for (const n of this.symbolInstanceIndexes) { const s = this.symbolInstances.get(n); this.featureSortOrder.push(s.featureIndex), [s.rightJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.leftJustifiedTextSymbolIndex].forEach((l, d, p) => { l >= 0 && p.indexOf(l) === d && this.addIndicesForPlacedSymbol(this.text, l) }), s.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, s.verticalPlacedTextSymbolIndex), s.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, s.placedIconSymbolIndex), s.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, s.verticalPlacedIconSymbolIndex) } this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray) } } } let Qp, ef; Je("SymbolBucket", Pa, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Pa.MAX_GLYPHS = 65535, Pa.addDynamicAttributes = ed; var rd = { get paint() { return ef = ef || new mr({ "icon-opacity": new ht(C.paint_symbol["icon-opacity"]), "icon-color": new ht(C.paint_symbol["icon-color"]), "icon-halo-color": new ht(C.paint_symbol["icon-halo-color"]), "icon-halo-width": new ht(C.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ht(C.paint_symbol["icon-halo-blur"]), "icon-translate": new nt(C.paint_symbol["icon-translate"]), "icon-translate-anchor": new nt(C.paint_symbol["icon-translate-anchor"]), "text-opacity": new ht(C.paint_symbol["text-opacity"]), "text-color": new ht(C.paint_symbol["text-color"], { runtimeType: xt, getOverride: r => r.textColor, hasOverride: r => !!r.textColor }), "text-halo-color": new ht(C.paint_symbol["text-halo-color"]), "text-halo-width": new ht(C.paint_symbol["text-halo-width"]), "text-halo-blur": new ht(C.paint_symbol["text-halo-blur"]), "text-translate": new nt(C.paint_symbol["text-translate"]), "text-translate-anchor": new nt(C.paint_symbol["text-translate-anchor"]) }) }, get layout() { return Qp = Qp || new mr({ "symbol-placement": new nt(C.layout_symbol["symbol-placement"]), "symbol-spacing": new nt(C.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new nt(C.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ht(C.layout_symbol["symbol-sort-key"]), "symbol-z-order": new nt(C.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new nt(C.layout_symbol["icon-allow-overlap"]), "icon-overlap": new nt(C.layout_symbol["icon-overlap"]), "icon-ignore-placement": new nt(C.layout_symbol["icon-ignore-placement"]), "icon-optional": new nt(C.layout_symbol["icon-optional"]), "icon-rotation-alignment": new nt(C.layout_symbol["icon-rotation-alignment"]), "icon-size": new ht(C.layout_symbol["icon-size"]), "icon-text-fit": new nt(C.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new nt(C.layout_symbol["icon-text-fit-padding"]), "icon-image": new ht(C.layout_symbol["icon-image"]), "icon-rotate": new ht(C.layout_symbol["icon-rotate"]), "icon-padding": new ht(C.layout_symbol["icon-padding"]), "icon-keep-upright": new nt(C.layout_symbol["icon-keep-upright"]), "icon-offset": new ht(C.layout_symbol["icon-offset"]), "icon-anchor": new ht(C.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new nt(C.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new nt(C.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new nt(C.layout_symbol["text-rotation-alignment"]), "text-field": new ht(C.layout_symbol["text-field"]), "text-font": new ht(C.layout_symbol["text-font"]), "text-size": new ht(C.layout_symbol["text-size"]), "text-max-width": new ht(C.layout_symbol["text-max-width"]), "text-line-height": new nt(C.layout_symbol["text-line-height"]), "text-letter-spacing": new ht(C.layout_symbol["text-letter-spacing"]), "text-justify": new ht(C.layout_symbol["text-justify"]), "text-radial-offset": new ht(C.layout_symbol["text-radial-offset"]), "text-variable-anchor": new nt(C.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new ht(C.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new ht(C.layout_symbol["text-anchor"]), "text-max-angle": new nt(C.layout_symbol["text-max-angle"]), "text-writing-mode": new nt(C.layout_symbol["text-writing-mode"]), "text-rotate": new ht(C.layout_symbol["text-rotate"]), "text-padding": new nt(C.layout_symbol["text-padding"]), "text-keep-upright": new nt(C.layout_symbol["text-keep-upright"]), "text-transform": new ht(C.layout_symbol["text-transform"]), "text-offset": new ht(C.layout_symbol["text-offset"]), "text-allow-overlap": new nt(C.layout_symbol["text-allow-overlap"]), "text-overlap": new nt(C.layout_symbol["text-overlap"]), "text-ignore-placement": new nt(C.layout_symbol["text-ignore-placement"]), "text-optional": new nt(C.layout_symbol["text-optional"]) }) } }; class tf { constructor(t) { if (t.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class"); this.type = t.property.overrides ? t.property.overrides.runtimeType : pt, this.defaultValue = t } evaluate(t) { if (t.formattedSection) { const n = this.defaultValue.property.overrides; if (n && n.hasOverride(t.formattedSection)) return n.getOverride(t.formattedSection) } return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default } eachChild(t) { this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression) } outputDefined() { return !1 } serialize() { return null } } Je("FormatSectionOverride", tf, { omit: ["defaultValue"] }); class zu extends hn { constructor(t) { super(t, rd) } recalculate(t, n) { if (super.recalculate(t, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") { const s = this.layout.get("text-writing-mode"); if (s) { const l = []; for (const d of s) l.indexOf(d) < 0 && l.push(d); this.layout._values["text-writing-mode"] = l } else this.layout._values["text-writing-mode"] = ["horizontal"] } this._setPaintOverrides() } getValueAndResolveTokens(t, n, s, l) { const d = this.layout.get(t).evaluate(n, {}, s, l), p = this._unevaluatedLayout._values[t]; return p.isDataDriven() || Ko(p.value) || !d ? d : function (_, y) { return y.replace(/{([^{}]+)}/g, (b, T) => _ && T in _ ? String(_[T]) : "") }(n.properties, d) } createBucket(t) { return new Pa(t) } queryRadius() { return 0 } queryIntersectsFeature() { throw new Error("Should take a different path in FeatureIndex") } _setPaintOverrides() { for (const t of rd.paint.overridableProperties) { if (!zu.hasPaintOverride(this.layout, t)) continue; const n = this.paint.get(t), s = new tf(n), l = new ml(s, n.property.specification); let d = null; d = n.value.kind === "constant" || n.value.kind === "source" ? new Jo("source", l) : new _l("composite", l, n.value.zoomStops), this.paint._values[t] = new Zr(n.property, d, n.parameters) } } _handleOverridablePaintPropertyUpdate(t, n, s) { return !(!this.layout || n.isDataDriven() || s.isDataDriven()) && zu.hasPaintOverride(this.layout, t) } static hasPaintOverride(t, n) { const s = t.get("text-field"), l = rd.paint.properties[n]; let d = !1; const p = _ => { for (const y of _) if (l.overrides && l.overrides.hasOverride(y)) return void (d = !0) }; if (s.value.kind === "constant" && s.value.value instanceof Gi) p(s.value.value.sections); else if (s.value.kind === "source") { const _ = b => { d || (b instanceof Br && Ti(b.value) === wi ? p(b.value.sections) : b instanceof Gn ? p(b.sections) : b.eachChild(_)) }, y = s.value; y._styleExpression && _(y._styleExpression.expression) } return d } } let rf; var Ig = { get paint() { return rf = rf || new mr({ "background-color": new nt(C.paint_background["background-color"]), "background-pattern": new la(C.paint_background["background-pattern"]), "background-opacity": new nt(C.paint_background["background-opacity"]) }) } }; class Cg extends hn { constructor(t) { super(t, Ig) } } let nf; var Eg = { get paint() { return nf = nf || new mr({ "raster-opacity": new nt(C.paint_raster["raster-opacity"]), "raster-hue-rotate": new nt(C.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new nt(C.paint_raster["raster-brightness-min"]), "raster-brightness-max": new nt(C.paint_raster["raster-brightness-max"]), "raster-saturation": new nt(C.paint_raster["raster-saturation"]), "raster-contrast": new nt(C.paint_raster["raster-contrast"]), "raster-resampling": new nt(C.paint_raster["raster-resampling"]), "raster-fade-duration": new nt(C.paint_raster["raster-fade-duration"]) }) } }; class Ag extends hn { constructor(t) { super(t, Eg) } } class zg extends hn { constructor(t) { super(t, {}), this.onAdd = n => { this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl) }, this.onRemove = n => { this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl) }, this.implementation = t } is3D() { return this.implementation.renderingMode === "3d" } hasOffscreenPass() { return this.implementation.prerender !== void 0 } recalculate() { } updateTransitions() { } hasTransition() { return !1 } serialize() { throw new Error("Custom layers cannot be serialized") } } class kg { constructor(t) { this._methodToThrottle = t, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => { this._triggered = !1, this._methodToThrottle() }) } trigger() { this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => { this._triggered = !1, this._methodToThrottle() }, 0)) } remove() { delete this._channel, this._methodToThrottle = () => { } } } const Dg = { once: !0 }, nd = 63710088e-1; class Fs { constructor(t, n) { if (isNaN(t) || isNaN(n)) throw new Error(`Invalid LngLat object: (${t}, ${n})`); if (this.lng = +t, this.lat = +n, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90") } wrap() { return new Fs(ur(this.lng, -180, 180), this.lat) } toArray() { return [this.lng, this.lat] } toString() { return `LngLat(${this.lng}, ${this.lat})` } distanceTo(t) { const n = Math.PI / 180, s = this.lat * n, l = t.lat * n, d = Math.sin(s) * Math.sin(l) + Math.cos(s) * Math.cos(l) * Math.cos((t.lng - this.lng) * n); return nd * Math.acos(Math.min(d, 1)) } static convert(t) { if (t instanceof Fs) return t; if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new Fs(Number(t[0]), Number(t[1])); if (!Array.isArray(t) && typeof t == "object" && t !== null) return new Fs(Number("lng" in t ? t.lng : t.lon), Number(t.lat)); throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]") } } const sf = 2 * Math.PI * nd; function of(r) { return sf * Math.cos(r * Math.PI / 180) } function af(r) { return (180 + r) / 360 } function lf(r) { return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360 } function cf(r, t) { return r / of(t) } function sd(r) { return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90 } function uf(r, t) { return r * of(sd(t)) } class rc { constructor(t, n, s = 0) { this.x = +t, this.y = +n, this.z = +s } static fromLngLat(t, n = 0) { const s = Fs.convert(t); return new rc(af(s.lng), lf(s.lat), cf(n, s.lat)) } toLngLat() { return new Fs(360 * this.x - 180, sd(this.y)) } toAltitude() { return uf(this.z, this.y) } meterInMercatorCoordinateUnits() { return 1 / sf * (t = sd(this.y), 1 / Math.cos(t * Math.PI / 180)); var t } } function hf(r, t, n) { var s = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n); return [r * s - 2 * Math.PI * 6378137 / 2, t * s - 2 * Math.PI * 6378137 / 2] } class od { constructor(t, n, s) { if (!function (l, d, p) { return !(l < 0 || l > 25 || p < 0 || p >= Math.pow(2, l) || d < 0 || d >= Math.pow(2, l)) }(t, n, s)) throw new Error(`x=${n}, y=${s}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `); this.z = t, this.x = n, this.y = s, this.key = Sa(0, t, t, n, s) } equals(t) { return this.z === t.z && this.x === t.x && this.y === t.y } url(t, n, s) { const l = (p = this.y, _ = this.z, y = hf(256 * (d = this.x), 256 * (p = Math.pow(2, _) - p - 1), _), b = hf(256 * (d + 1), 256 * (p + 1), _), y[0] + "," + y[1] + "," + b[0] + "," + b[1]); var d, p, _, y, b; const T = function (M, k, R) { let L, O = ""; for (let U = M; U > 0; U--)L = 1 << U - 1, O += (k & L ? 1 : 0) + (R & L ? 2 : 0); return O }(this.z, this.x, this.y); return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(s === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, T).replace(/{bbox-epsg-3857}/g, l) } isChildOf(t) { const n = this.z - t.z; return n > 0 && t.x === this.x >> n && t.y === this.y >> n } getTilePoint(t) { const n = Math.pow(2, this.z); return new Ge((t.x * n - this.x) * gt, (t.y * n - this.y) * gt) } toString() { return `${this.z}/${this.x}/${this.y}` } } class df { constructor(t, n) { this.wrap = t, this.canonical = n, this.key = Sa(t, n.z, n.z, n.x, n.y) } } class Qr { constructor(t, n, s, l, d) { if (this.terrainRttPosMatrix32f = null, t < s) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${s}`); this.overscaledZ = t, this.wrap = n, this.canonical = new od(s, +l, +d), this.key = Sa(n, t, s, l, d) } clone() { return new Qr(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) } equals(t) { return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical) } scaledTo(t) { if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`); const n = this.canonical.z - t; return t > this.canonical.z ? new Qr(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Qr(t, this.wrap, t, this.canonical.x >> n, this.canonical.y >> n) } calculateScaledKey(t, n) { if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`); const s = this.canonical.z - t; return t > this.canonical.z ? Sa(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : Sa(this.wrap * +n, t, t, this.canonical.x >> s, this.canonical.y >> s) } isChildOf(t) { if (t.wrap !== this.wrap) return !1; const n = this.canonical.z - t.canonical.z; return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n } children(t) { if (this.overscaledZ >= t) return [new Qr(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)]; const n = this.canonical.z + 1, s = 2 * this.canonical.x, l = 2 * this.canonical.y; return [new Qr(n, this.wrap, n, s, l), new Qr(n, this.wrap, n, s + 1, l), new Qr(n, this.wrap, n, s, l + 1), new Qr(n, this.wrap, n, s + 1, l + 1)] } isLessThan(t) { return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y)) } wrapped() { return new Qr(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y) } unwrapTo(t) { return new Qr(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y) } overscaleFactor() { return Math.pow(2, this.overscaledZ - this.canonical.z) } toUnwrapped() { return new df(this.wrap, this.canonical) } toString() { return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}` } getTilePoint(t) { return this.canonical.getTilePoint(new rc(t.x - this.wrap, t.y)) } } function Sa(r, t, n, s, l) { (r *= 2) < 0 && (r = -1 * r - 1); const d = 1 << n; return (d * d * r + d * l + s).toString(36) + n.toString(36) + t.toString(36) } Je("CanonicalTileID", od), Je("OverscaledTileID", Qr, { omit: ["terrainRttPosMatrix32f"] }); class pf { constructor(t, n, s, l = 1, d = 1, p = 1, _ = 0) { if (this.uid = t, n.height !== n.width) throw new RangeError("DEM tiles must be square"); if (s && !["mapbox", "terrarium", "custom"].includes(s)) return void Ui(`"${s}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`); this.stride = n.height; const y = this.dim = n.height - 2; switch (this.data = new Uint32Array(n.data.buffer), s) { case "terrarium": this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768; break; case "custom": this.redFactor = l, this.greenFactor = d, this.blueFactor = p, this.baseShift = _; break; default: this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4 }for (let b = 0; b < y; b++)this.data[this._idx(-1, b)] = this.data[this._idx(0, b)], this.data[this._idx(y, b)] = this.data[this._idx(y - 1, b)], this.data[this._idx(b, -1)] = this.data[this._idx(b, 0)], this.data[this._idx(b, y)] = this.data[this._idx(b, y - 1)]; this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(y, -1)] = this.data[this._idx(y - 1, 0)], this.data[this._idx(-1, y)] = this.data[this._idx(0, y - 1)], this.data[this._idx(y, y)] = this.data[this._idx(y - 1, y - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER; for (let b = 0; b < y; b++)for (let T = 0; T < y; T++) { const M = this.get(b, T); M > this.max && (this.max = M), M < this.min && (this.min = M) } } get(t, n) { const s = new Uint8Array(this.data.buffer), l = 4 * this._idx(t, n); return this.unpack(s[l], s[l + 1], s[l + 2]) } getUnpackVector() { return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift] } _idx(t, n) { if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data"); return (n + 1) * this.stride + (t + 1) } unpack(t, n, s) { return t * this.redFactor + n * this.greenFactor + s * this.blueFactor - this.baseShift } getPixels() { return new Yr({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer)) } backfillBorder(t, n, s) { if (this.dim !== t.dim) throw new Error("dem dimension mismatch"); let l = n * this.dim, d = n * this.dim + this.dim, p = s * this.dim, _ = s * this.dim + this.dim; switch (n) { case -1: l = d - 1; break; case 1: d = l + 1 }switch (s) { case -1: p = _ - 1; break; case 1: _ = p + 1 }const y = -n * this.dim, b = -s * this.dim; for (let T = p; T < _; T++)for (let M = l; M < d; M++)this.data[this._idx(M, T)] = t.data[this._idx(M + y, T + b)] } } Je("DEMData", pf); class ff { constructor(t) { this._stringToNumber = {}, this._numberToString = []; for (let n = 0; n < t.length; n++) { const s = t[n]; this._stringToNumber[s] = n, this._numberToString[n] = s } } encode(t) { return this._stringToNumber[t] } decode(t) { if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`); return this._numberToString[t] } } class mf { constructor(t, n, s, l, d) { this.type = "Feature", this._vectorTileFeature = t, t._z = n, t._x = s, t._y = l, this.properties = t.properties, this.id = d } get geometry() { return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry } set geometry(t) { this._geometry = t } toJSON() { const t = { geometry: this.geometry }; for (const n in this) n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]); return t } } class _f { constructor(t, n) { this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new oo(gt, 16, 0), this.grid3D = new oo(gt, 16, 0), this.featureIndexArray = new G, this.promoteId = n } insert(t, n, s, l, d, p) { const _ = this.featureIndexArray.length; this.featureIndexArray.emplaceBack(s, l, d); const y = p ? this.grid3D : this.grid; for (let b = 0; b < n.length; b++) { const T = n[b], M = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (let k = 0; k < T.length; k++) { const R = T[k]; M[0] = Math.min(M[0], R.x), M[1] = Math.min(M[1], R.y), M[2] = Math.max(M[2], R.x), M[3] = Math.max(M[3], R.y) } M[0] < gt && M[1] < gt && M[2] >= 0 && M[3] >= 0 && y.insert(_, M[0], M[1], M[2], M[3]) } } loadVTLayers() { return this.vtLayers || (this.vtLayers = new Jl.VectorTile(new Wh(this.rawTileData)).layers, this.sourceLayerCoder = new ff(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers } query(t, n, s, l) { this.loadVTLayers(); const d = t.params, p = gt / t.tileSize / t.scale, _ = ea(d.filter), y = t.queryGeometry, b = t.queryPadding * p, T = yf(y), M = this.grid.query(T.minX - b, T.minY - b, T.maxX + b, T.maxY + b), k = yf(t.cameraQueryGeometry), R = this.grid3D.query(k.minX - b, k.minY - b, k.maxX + b, k.maxY + b, (U, W, se, J) => function (D, N, Y, _e, ke) { for (const Te of D) if (N <= Te.x && Y <= Te.y && _e >= Te.x && ke >= Te.y) return !0; const ve = [new Ge(N, Y), new Ge(N, ke), new Ge(_e, ke), new Ge(_e, Y)]; if (D.length > 2) { for (const Te of ve) if (xa(D, Te)) return !0 } for (let Te = 0; Te < D.length - 1; Te++)if (b_(D[Te], D[Te + 1], ve)) return !0; return !1 }(t.cameraQueryGeometry, U - b, W - b, se + b, J + b)); for (const U of R) M.push(U); M.sort(Rg); const L = {}; let O; for (let U = 0; U < M.length; U++) { const W = M[U]; if (W === O) continue; O = W; const se = this.featureIndexArray.get(W); let J = null; this.loadMatchingFeature(L, se.bucketIndex, se.sourceLayerIndex, se.featureIndex, _, d.layers, d.availableImages, n, s, l, (D, N, Y) => (J || (J = as(D)), N.queryIntersectsFeature({ queryGeometry: y, feature: D, featureState: Y, geometry: J, zoom: this.z, transform: t.transform, pixelsToTileUnits: p, pixelPosMatrix: t.pixelPosMatrix }))) } return L } loadMatchingFeature(t, n, s, l, d, p, _, y, b, T, M) { const k = this.bucketLayerIDs[n]; if (p && !k.some(U => p.has(U))) return; const R = this.sourceLayerCoder.decode(s), L = this.vtLayers[R].feature(l); if (d.needGeometry) { const U = Tr(L, !0); if (!d.filter(new si(this.tileID.overscaledZ), U, this.tileID.canonical)) return } else if (!d.filter(new si(this.tileID.overscaledZ), L)) return; const O = this.getId(L, R); for (let U = 0; U < k.length; U++) { const W = k[U]; if (p && !p.has(W)) continue; const se = y[W]; if (!se) continue; let J = {}; O && T && (J = T.getState(se.sourceLayer || "_geojsonTileLayer", O)); const D = Si({}, b[W]); D.paint = gf(D.paint, se.paint, L, J, _), D.layout = gf(D.layout, se.layout, L, J, _); const N = !M || M(L, se, J); if (!N) continue; const Y = new mf(L, this.z, this.x, this.y, O); Y.layer = D; let _e = t[W]; _e === void 0 && (_e = t[W] = []), _e.push({ featureIndex: l, feature: Y, intersectionZ: N }) } } lookupSymbolFeatures(t, n, s, l, d, p, _, y) { const b = {}; this.loadVTLayers(); const T = ea(d); for (const M of t) this.loadMatchingFeature(b, s, l, M, T, p, _, y, n); return b } hasLayer(t) { for (const n of this.bucketLayerIDs) for (const s of n) if (t === s) return !0; return !1 } getId(t, n) { var s; let l = t.id; return this.promoteId && (l = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]], typeof l == "boolean" && (l = Number(l)), l === void 0 && (!((s = t.properties) === null || s === void 0) && s.cluster) && this.promoteId && (l = Number(t.properties.cluster_id))), l } } function gf(r, t, n, s, l) { return Dr(r, (d, p) => { const _ = t instanceof aa ? t.get(p) : null; return _ && _.evaluate ? _.evaluate(n, s, l) : _ }) } function yf(r) { let t = 1 / 0, n = 1 / 0, s = -1 / 0, l = -1 / 0; for (const d of r) t = Math.min(t, d.x), n = Math.min(n, d.y), s = Math.max(s, d.x), l = Math.max(l, d.y); return { minX: t, minY: n, maxX: s, maxY: l } } function Rg(r, t) { return t - r } function xf(r, t, n, s, l) { const d = []; for (let p = 0; p < r.length; p++) { const _ = r[p]; let y; for (let b = 0; b < _.length - 1; b++) { let T = _[b], M = _[b + 1]; T.x < t && M.x < t || (T.x < t ? T = new Ge(t, T.y + (t - T.x) / (M.x - T.x) * (M.y - T.y))._round() : M.x < t && (M = new Ge(t, T.y + (t - T.x) / (M.x - T.x) * (M.y - T.y))._round()), T.y < n && M.y < n || (T.y < n ? T = new Ge(T.x + (n - T.y) / (M.y - T.y) * (M.x - T.x), n)._round() : M.y < n && (M = new Ge(T.x + (n - T.y) / (M.y - T.y) * (M.x - T.x), n)._round()), T.x >= s && M.x >= s || (T.x >= s ? T = new Ge(s, T.y + (s - T.x) / (M.x - T.x) * (M.y - T.y))._round() : M.x >= s && (M = new Ge(s, T.y + (s - T.x) / (M.x - T.x) * (M.y - T.y))._round()), T.y >= l && M.y >= l || (T.y >= l ? T = new Ge(T.x + (l - T.y) / (M.y - T.y) * (M.x - T.x), l)._round() : M.y >= l && (M = new Ge(T.x + (l - T.y) / (M.y - T.y) * (M.x - T.x), l)._round()), y && T.equals(y[y.length - 1]) || (y = [T], d.push(y)), y.push(M))))) } } return d } Je("FeatureIndex", _f, { omit: ["rawTileData", "sourceLayerCoder"] }); class Bs extends Ge { constructor(t, n, s, l) { super(t, n), this.angle = s, l !== void 0 && (this.segment = l) } clone() { return new Bs(this.x, this.y, this.angle, this.segment) } } function vf(r, t, n, s, l) { if (t.segment === void 0 || n === 0) return !0; let d = t, p = t.segment + 1, _ = 0; for (; _ > -n / 2;) { if (p--, p < 0) return !1; _ -= r[p].dist(d), d = r[p] } _ += r[p].dist(r[p + 1]), p++; const y = []; let b = 0; for (; _ < n / 2;) { const T = r[p], M = r[p + 1]; if (!M) return !1; let k = r[p - 1].angleTo(T) - T.angleTo(M); for (k = Math.abs((k + 3 * Math.PI) % (2 * Math.PI) - Math.PI), y.push({ distance: _, angleDelta: k }), b += k; _ - y[0].distance > s;)b -= y.shift().angleDelta; if (b > l) return !1; p++, _ += T.dist(M) } return !0 } function bf(r) { let t = 0; for (let n = 0; n < r.length - 1; n++)t += r[n].dist(r[n + 1]); return t } function wf(r, t, n) { return r ? .6 * t * n : 0 } function Tf(r, t) { return Math.max(r ? r.right - r.left : 0, t ? t.right - t.left : 0) } function Lg(r, t, n, s, l, d) { const p = wf(n, l, d), _ = Tf(n, s) * d; let y = 0; const b = bf(r) / 2; for (let T = 0; T < r.length - 1; T++) { const M = r[T], k = r[T + 1], R = M.dist(k); if (y + R > b) { const L = (b - y) / R, O = br.number(M.x, k.x, L), U = br.number(M.y, k.y, L), W = new Bs(O, U, k.angleTo(M), T); return W._round(), !p || vf(r, W, _, p, t) ? W : void 0 } y += R } } function Fg(r, t, n, s, l, d, p, _, y) { const b = wf(s, d, p), T = Tf(s, l), M = T * p, k = r[0].x === 0 || r[0].x === y || r[0].y === 0 || r[0].y === y; return t - M < t / 4 && (t = M + t / 4), Pf(r, k ? t / 2 * _ % t : (T / 2 + 2 * d) * p * _ % t, t, b, n, M, k, !1, y) } function Pf(r, t, n, s, l, d, p, _, y) { const b = d / 2, T = bf(r); let M = 0, k = t - n, R = []; for (let L = 0; L < r.length - 1; L++) { const O = r[L], U = r[L + 1], W = O.dist(U), se = U.angleTo(O); for (; k + n < M + W;) { k += n; const J = (k - M) / W, D = br.number(O.x, U.x, J), N = br.number(O.y, U.y, J); if (D >= 0 && D < y && N >= 0 && N < y && k - b >= 0 && k + b <= T) { const Y = new Bs(D, N, se, L); Y._round(), s && !vf(r, Y, d, s, l) || R.push(Y) } } M += W } return _ || R.length || p || (R = Pf(r, M / 2, n, s, l, d, p, !0, y)), R } Je("Anchor", Bs); const nc = Pr; function Sf(r, t, n, s) { const l = [], d = r.image, p = d.pixelRatio, _ = d.paddedRect.w - 2 * nc, y = d.paddedRect.h - 2 * nc; let b = { x1: r.left, y1: r.top, x2: r.right, y2: r.bottom }; const T = d.stretchX || [[0, _]], M = d.stretchY || [[0, y]], k = (Ce, Ye) => Ce + Ye[1] - Ye[0], R = T.reduce(k, 0), L = M.reduce(k, 0), O = _ - R, U = y - L; let W = 0, se = R, J = 0, D = L, N = 0, Y = O, _e = 0, ke = U; if (d.content && s) { const Ce = d.content, Ye = Ce[2] - Ce[0], ut = Ce[3] - Ce[1]; (d.textFitWidth || d.textFitHeight) && (b = Kp(r)), W = ku(T, 0, Ce[0]), J = ku(M, 0, Ce[1]), se = ku(T, Ce[0], Ce[2]), D = ku(M, Ce[1], Ce[3]), N = Ce[0] - W, _e = Ce[1] - J, Y = Ye - se, ke = ut - D } const ve = b.x1, Te = b.y1, je = b.x2 - ve, Re = b.y2 - Te, Ne = (Ce, Ye, ut, lt) => { const it = Du(Ce.stretch - W, se, je, ve), St = Ru(Ce.fixed - N, Y, Ce.stretch, R), fi = Du(Ye.stretch - J, D, Re, Te), zi = Ru(Ye.fixed - _e, ke, Ye.stretch, L), tr = Du(ut.stretch - W, se, je, ve), en = Ru(ut.fixed - N, Y, ut.stretch, R), Sr = Du(lt.stretch - J, D, Re, Te), Hi = Ru(lt.fixed - _e, ke, lt.stretch, L), ai = new Ge(it, fi), Bi = new Ge(tr, fi), Wi = new Ge(tr, Sr), Xi = new Ge(it, Sr), _r = new Ge(St / p, zi / p), tn = new Ge(en / p, Hi / p), Oi = t * Math.PI / 180; if (Oi) { const ji = Math.sin(Oi), Vi = Math.cos(Oi), Pi = [Vi, -ji, ji, Vi]; ai._matMult(Pi), Bi._matMult(Pi), Xi._matMult(Pi), Wi._matMult(Pi) } const Mr = Ce.stretch + Ce.fixed, ki = Ye.stretch + Ye.fixed; return { tl: ai, tr: Bi, bl: Xi, br: Wi, tex: { x: d.paddedRect.x + nc + Mr, y: d.paddedRect.y + nc + ki, w: ut.stretch + ut.fixed - Mr, h: lt.stretch + lt.fixed - ki }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: _r, pixelOffsetBR: tn, minFontScaleX: Y / p / je, minFontScaleY: ke / p / Re, isSDF: n } }; if (s && (d.stretchX || d.stretchY)) { const Ce = Mf(T, O, R), Ye = Mf(M, U, L); for (let ut = 0; ut < Ce.length - 1; ut++) { const lt = Ce[ut], it = Ce[ut + 1]; for (let St = 0; St < Ye.length - 1; St++)l.push(Ne(lt, Ye[St], it, Ye[St + 1])) } } else l.push(Ne({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: _ + 1 }, { fixed: 0, stretch: y + 1 })); return l } function ku(r, t, n) { let s = 0; for (const l of r) s += Math.max(t, Math.min(n, l[1])) - Math.max(t, Math.min(n, l[0])); return s } function Mf(r, t, n) { const s = [{ fixed: -1, stretch: 0 }]; for (const [l, d] of r) { const p = s[s.length - 1]; s.push({ fixed: l - p.stretch, stretch: p.stretch }), s.push({ fixed: l - p.stretch, stretch: p.stretch + (d - l) }) } return s.push({ fixed: t + nc, stretch: n }), s } function Du(r, t, n, s) { return r / t * n + s } function Ru(r, t, n, s) { return r - t * n / s } class Lu { constructor(t, n, s, l, d, p, _, y, b, T) { var M; if (this.boxStartIndex = t.length, b) { let k = p.top, R = p.bottom; const L = p.collisionPadding; L && (k -= L[1], R += L[3]); let O = R - k; O > 0 && (O = Math.max(10, O), this.circleDiameter = O) } else { const k = !((M = p.image) === null || M === void 0) && M.content && (p.image.textFitWidth || p.image.textFitHeight) ? Kp(p) : { x1: p.left, y1: p.top, x2: p.right, y2: p.bottom }; k.y1 = k.y1 * _ - y[0], k.y2 = k.y2 * _ + y[2], k.x1 = k.x1 * _ - y[3], k.x2 = k.x2 * _ + y[1]; const R = p.collisionPadding; if (R && (k.x1 -= R[0] * _, k.y1 -= R[1] * _, k.x2 += R[2] * _, k.y2 += R[3] * _), T) { const L = new Ge(k.x1, k.y1), O = new Ge(k.x2, k.y1), U = new Ge(k.x1, k.y2), W = new Ge(k.x2, k.y2), se = T * Math.PI / 180; L._rotate(se), O._rotate(se), U._rotate(se), W._rotate(se), k.x1 = Math.min(L.x, O.x, U.x, W.x), k.x2 = Math.max(L.x, O.x, U.x, W.x), k.y1 = Math.min(L.y, O.y, U.y, W.y), k.y2 = Math.max(L.y, O.y, U.y, W.y) } t.emplaceBack(n.x, n.y, k.x1, k.y1, k.x2, k.y2, s, l, d) } this.boxEndIndex = t.length } } class Bg { constructor(t = [], n = (s, l) => s < l ? -1 : s > l ? 1 : 0) { if (this.data = t, this.length = this.data.length, this.compare = n, this.length > 0) for (let s = (this.length >> 1) - 1; s >= 0; s--)this._down(s) } push(t) { this.data.push(t), this._up(this.length++) } pop() { if (this.length === 0) return; const t = this.data[0], n = this.data.pop(); return --this.length > 0 && (this.data[0] = n, this._down(0)), t } peek() { return this.data[0] } _up(t) { const { data: n, compare: s } = this, l = n[t]; for (; t > 0;) { const d = t - 1 >> 1, p = n[d]; if (s(l, p) >= 0) break; n[t] = p, t = d } n[t] = l } _down(t) { const { data: n, compare: s } = this, l = this.length >> 1, d = n[t]; for (; t < l;) { let p = 1 + (t << 1); const _ = p + 1; if (_ < this.length && s(n[_], n[p]) < 0 && (p = _), s(n[p], d) >= 0) break; n[t] = n[p], t = p } n[t] = d } } function Og(r, t = 1, n = !1) { let s = 1 / 0, l = 1 / 0, d = -1 / 0, p = -1 / 0; const _ = r[0]; for (let R = 0; R < _.length; R++) { const L = _[R]; (!R || L.x < s) && (s = L.x), (!R || L.y < l) && (l = L.y), (!R || L.x > d) && (d = L.x), (!R || L.y > p) && (p = L.y) } const y = Math.min(d - s, p - l); let b = y / 2; const T = new Bg([], jg); if (y === 0) return new Ge(s, l); for (let R = s; R < d; R += y)for (let L = l; L < p; L += y)T.push(new Ma(R + b, L + b, b, r)); let M = function (R) { let L = 0, O = 0, U = 0; const W = R[0]; for (let se = 0, J = W.length, D = J - 1; se < J; D = se++) { const N = W[se], Y = W[D], _e = N.x * Y.y - Y.x * N.y; O += (N.x + Y.x) * _e, U += (N.y + Y.y) * _e, L += 3 * _e } return new Ma(O / L, U / L, 0, R) }(r), k = T.length; for (; T.length;) { const R = T.pop(); (R.d > M.d || !M.d) && (M = R, n && console.log("found best %d after %d probes", Math.round(1e4 * R.d) / 1e4, k)), R.max - M.d <= t || (b = R.h / 2, T.push(new Ma(R.p.x - b, R.p.y - b, b, r)), T.push(new Ma(R.p.x + b, R.p.y - b, b, r)), T.push(new Ma(R.p.x - b, R.p.y + b, b, r)), T.push(new Ma(R.p.x + b, R.p.y + b, b, r)), k += 4) } return n && (console.log(`num probes: ${k}`), console.log(`best distance: ${M.d}`)), M.p } function jg(r, t) { return t.max - r.max } function Ma(r, t, n, s) { this.p = new Ge(r, t), this.h = n, this.d = function (l, d) { let p = !1, _ = 1 / 0; for (let y = 0; y < d.length; y++) { const b = d[y]; for (let T = 0, M = b.length, k = M - 1; T < M; k = T++) { const R = b[T], L = b[k]; R.y > l.y != L.y > l.y && l.x < (L.x - R.x) * (l.y - R.y) / (L.y - R.y) + R.x && (p = !p), _ = Math.min(_, sp(l, R, L)) } } return (p ? 1 : -1) * Math.sqrt(_) }(this.p, s), this.max = this.d + this.h * Math.SQRT2 } var er; P.ax = void 0, (er = P.ax || (P.ax = {}))[er.center = 1] = "center", er[er.left = 2] = "left", er[er.right = 3] = "right", er[er.top = 4] = "top", er[er.bottom = 5] = "bottom", er[er["top-left"] = 6] = "top-left", er[er["top-right"] = 7] = "top-right", er[er["bottom-left"] = 8] = "bottom-left", er[er["bottom-right"] = 9] = "bottom-right"; const Os = 7, ad = Number.POSITIVE_INFINITY; function If(r, t) { return t[1] !== ad ? function (n, s, l) { let d = 0, p = 0; switch (s = Math.abs(s), l = Math.abs(l), n) { case "top-right": case "top-left": case "top": p = l - Os; break; case "bottom-right": case "bottom-left": case "bottom": p = -l + Os }switch (n) { case "top-right": case "bottom-right": case "right": d = -s; break; case "top-left": case "bottom-left": case "left": d = s }return [d, p] }(r, t[0], t[1]) : function (n, s) { let l = 0, d = 0; s < 0 && (s = 0); const p = s / Math.SQRT2; switch (n) { case "top-right": case "top-left": d = p - Os; break; case "bottom-right": case "bottom-left": d = -p + Os; break; case "bottom": d = -s + Os; break; case "top": d = s - Os }switch (n) { case "top-right": case "bottom-right": l = -p; break; case "top-left": case "bottom-left": l = p; break; case "left": l = s; break; case "right": l = -s }return [l, d] }(r, t[0]) } function Cf(r, t, n) { var s; const l = r.layout, d = (s = l.get("text-variable-anchor-offset")) === null || s === void 0 ? void 0 : s.evaluate(t, {}, n); if (d) { const _ = d.values, y = []; for (let b = 0; b < _.length; b += 2) { const T = y[b] = _[b], M = _[b + 1].map(k => k * Ai); T.startsWith("top") ? M[1] -= Os : T.startsWith("bottom") && (M[1] += Os), y[b + 1] = M } return new Ri(y) } const p = l.get("text-variable-anchor"); if (p) { let _; _ = r._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [l.get("text-radial-offset").evaluate(t, {}, n) * Ai, ad] : l.get("text-offset").evaluate(t, {}, n).map(b => b * Ai); const y = []; for (const b of p) y.push(b, If(b, _)); return new Ri(y) } return null } function ld(r) { switch (r) { case "right": case "top-right": case "bottom-right": return "right"; case "left": case "top-left": case "bottom-left": return "left" }return "center" } function Vg(r, t, n, s, l, d, p, _, y, b, T, M) { let k = d.textMaxSize.evaluate(t, {}); k === void 0 && (k = p); const R = r.layers[0].layout, L = R.get("icon-offset").evaluate(t, {}, T), O = Af(n.horizontal), U = p / 24, W = r.tilePixelRatio * U, se = r.tilePixelRatio * k / 24, J = r.tilePixelRatio * _, D = r.tilePixelRatio * R.get("symbol-spacing"), N = R.get("text-padding") * r.tilePixelRatio, Y = function (ut, lt, it, St = 1) { const fi = ut.get("icon-padding").evaluate(lt, {}, it), zi = fi && fi.values; return [zi[0] * St, zi[1] * St, zi[2] * St, zi[3] * St] }(R, t, T, r.tilePixelRatio), _e = R.get("text-max-angle") / 180 * Math.PI, ke = R.get("text-rotation-alignment") !== "viewport" && R.get("symbol-placement") !== "point", ve = R.get("icon-rotation-alignment") === "map" && R.get("symbol-placement") !== "point", Te = R.get("symbol-placement"), je = D / 2, Re = R.get("icon-text-fit"); let Ne; s && Re !== "none" && (r.allowVerticalPlacement && n.vertical && (Ne = Jp(s, n.vertical, Re, R.get("icon-text-fit-padding"), L, U)), O && (s = Jp(s, O, Re, R.get("icon-text-fit-padding"), L, U))); const Ce = T ? M.line.getGranularityForZoomLevel(T.z) : 1, Ye = (ut, lt) => { lt.x < 0 || lt.x >= gt || lt.y < 0 || lt.y >= gt || function (it, St, fi, zi, tr, en, Sr, Hi, ai, Bi, Wi, Xi, _r, tn, Oi, Mr, ki, ji, Vi, Pi, ti, xn, Ia, vn, Ug) { const Ca = it.addToLineVertexArray(St, fi); let _o, Ea, Aa, za, Rf = 0, Lf = 0, Ff = 0, Bf = 0, _d = -1, gd = -1; const ls = {}; let Of = Ii(""); if (it.allowVerticalPlacement && zi.vertical) { const sr = Hi.layout.get("text-rotate").evaluate(ti, {}, vn) + 90; Aa = new Lu(ai, St, Bi, Wi, Xi, zi.vertical, _r, tn, Oi, sr), Sr && (za = new Lu(ai, St, Bi, Wi, Xi, Sr, ki, ji, Oi, sr)) } if (tr) { const sr = Hi.layout.get("icon-rotate").evaluate(ti, {}), rn = Hi.layout.get("icon-text-fit") !== "none", go = Sf(tr, sr, Ia, rn), wn = Sr ? Sf(Sr, sr, Ia, rn) : void 0; Ea = new Lu(ai, St, Bi, Wi, Xi, tr, ki, ji, !1, sr), Rf = 4 * go.length; const yo = it.iconSizeData; let Rn = null; yo.kind === "source" ? (Rn = [Dn * Hi.layout.get("icon-size").evaluate(ti, {})], Rn[0] > Ls && Ui(`${it.layerIds[0]}: Value for "icon-size" is >= ${ic}. Reduce your "icon-size".`)) : yo.kind === "composite" && (Rn = [Dn * xn.compositeIconSizes[0].evaluate(ti, {}, vn), Dn * xn.compositeIconSizes[1].evaluate(ti, {}, vn)], (Rn[0] > Ls || Rn[1] > Ls) && Ui(`${it.layerIds[0]}: Value for "icon-size" is >= ${ic}. Reduce your "icon-size".`)), it.addSymbols(it.icon, go, Rn, Pi, Vi, ti, P.ag.none, St, Ca.lineStartIndex, Ca.lineLength, -1, vn), _d = it.icon.placedSymbolArray.length - 1, wn && (Lf = 4 * wn.length, it.addSymbols(it.icon, wn, Rn, Pi, Vi, ti, P.ag.vertical, St, Ca.lineStartIndex, Ca.lineLength, -1, vn), gd = it.icon.placedSymbolArray.length - 1) } const jf = Object.keys(zi.horizontal); for (const sr of jf) { const rn = zi.horizontal[sr]; if (!_o) { Of = Ii(rn.text); const wn = Hi.layout.get("text-rotate").evaluate(ti, {}, vn); _o = new Lu(ai, St, Bi, Wi, Xi, rn, _r, tn, Oi, wn) } const go = rn.positionedLines.length === 1; if (Ff += Ef(it, St, rn, en, Hi, Oi, ti, Mr, Ca, zi.vertical ? P.ag.horizontal : P.ag.horizontalOnly, go ? jf : [sr], ls, _d, xn, vn), go) break } zi.vertical && (Bf += Ef(it, St, zi.vertical, en, Hi, Oi, ti, Mr, Ca, P.ag.vertical, ["vertical"], ls, gd, xn, vn)); const $g = _o ? _o.boxStartIndex : it.collisionBoxArray.length, Gg = _o ? _o.boxEndIndex : it.collisionBoxArray.length, qg = Aa ? Aa.boxStartIndex : it.collisionBoxArray.length, Hg = Aa ? Aa.boxEndIndex : it.collisionBoxArray.length, Wg = Ea ? Ea.boxStartIndex : it.collisionBoxArray.length, Xg = Ea ? Ea.boxEndIndex : it.collisionBoxArray.length, Kg = za ? za.boxStartIndex : it.collisionBoxArray.length, Jg = za ? za.boxEndIndex : it.collisionBoxArray.length; let bn = -1; const Bu = (sr, rn) => sr && sr.circleDiameter ? Math.max(sr.circleDiameter, rn) : rn; bn = Bu(_o, bn), bn = Bu(Aa, bn), bn = Bu(Ea, bn), bn = Bu(za, bn); const Vf = bn > -1 ? 1 : 0; Vf && (bn *= Ug / Ai), it.glyphOffsetArray.length >= Pa.MAX_GLYPHS && Ui("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), ti.sortKey !== void 0 && it.addToSortKeyRanges(it.symbolInstances.length, ti.sortKey); const Yg = Cf(Hi, ti, vn), [Qg, ey] = function (sr, rn) { const go = sr.length, wn = rn == null ? void 0 : rn.values; if ((wn == null ? void 0 : wn.length) > 0) for (let yo = 0; yo < wn.length; yo += 2) { const Rn = wn[yo + 1]; sr.emplaceBack(P.ax[wn[yo]], Rn[0], Rn[1]) } return [go, sr.length] }(it.textAnchorOffsets, Yg); it.symbolInstances.emplaceBack(St.x, St.y, ls.right >= 0 ? ls.right : -1, ls.center >= 0 ? ls.center : -1, ls.left >= 0 ? ls.left : -1, ls.vertical || -1, _d, gd, Of, $g, Gg, qg, Hg, Wg, Xg, Kg, Jg, Bi, Ff, Bf, Rf, Lf, Vf, 0, _r, bn, Qg, ey) }(r, lt, ut, n, s, l, Ne, r.layers[0], r.collisionBoxArray, t.index, t.sourceLayerIndex, r.index, W, [N, N, N, N], ke, y, J, Y, ve, L, t, d, b, T, p) }; if (Te === "line") for (const ut of xf(t.geometry, 0, 0, gt, gt)) { const lt = mo(ut, Ce), it = Fg(lt, D, _e, n.vertical || O, s, 24, se, r.overscaling, gt); for (const St of it) O && Ng(r, O.text, je, St) || Ye(lt, St) } else if (Te === "line-center") { for (const ut of t.geometry) if (ut.length > 1) { const lt = mo(ut, Ce), it = Lg(lt, _e, n.vertical || O, s, 24, se); it && Ye(lt, it) } } else if (t.type === "Polygon") for (const ut of jo(t.geometry, 0)) { const lt = Og(ut, 16); Ye(mo(ut[0], Ce, !0), new Bs(lt.x, lt.y, 0)) } else if (t.type === "LineString") for (const ut of t.geometry) { const lt = mo(ut, Ce); Ye(lt, new Bs(lt[0].x, lt[0].y, 0)) } else if (t.type === "Point") for (const ut of t.geometry) for (const lt of ut) Ye([lt], new Bs(lt.x, lt.y, 0)) } function Ef(r, t, n, s, l, d, p, _, y, b, T, M, k, R, L) { const O = function (se, J, D, N, Y, _e, ke, ve) { const Te = N.layout.get("text-rotate").evaluate(_e, {}) * Math.PI / 180, je = []; for (const Re of J.positionedLines) for (const Ne of Re.positionedGlyphs) { if (!Ne.rect) continue; const Ce = Ne.rect || {}; let Ye = fg + 1, ut = !0, lt = 1, it = 0; const St = (Y || ve) && Ne.vertical, fi = Ne.metrics.advance * Ne.scale / 2; if (ve && J.verticalizable && (it = Re.lineOffset / 2 - (Ne.imageName ? -(Ai - Ne.metrics.width * Ne.scale) / 2 : (Ne.scale - 1) * Ai)), Ne.imageName) { const ji = ke[Ne.imageName]; ut = ji.sdf, lt = ji.pixelRatio, Ye = Pr / lt } const zi = Y ? [Ne.x + fi, Ne.y] : [0, 0]; let tr = Y ? [0, 0] : [Ne.x + fi + D[0], Ne.y + D[1] - it], en = [0, 0]; St && (en = tr, tr = [0, 0]); const Sr = Ne.metrics.isDoubleResolution ? 2 : 1, Hi = (Ne.metrics.left - Ye) * Ne.scale - fi + tr[0], ai = (-Ne.metrics.top - Ye) * Ne.scale + tr[1], Bi = Hi + Ce.w / Sr * Ne.scale / lt, Wi = ai + Ce.h / Sr * Ne.scale / lt, Xi = new Ge(Hi, ai), _r = new Ge(Bi, ai), tn = new Ge(Hi, Wi), Oi = new Ge(Bi, Wi); if (St) { const ji = new Ge(-fi, fi - Iu), Vi = -Math.PI / 2, Pi = Ai / 2 - fi, ti = new Ge(5 - Iu - Pi, -(Ne.imageName ? Pi : 0)), xn = new Ge(...en); Xi._rotateAround(Vi, ji)._add(ti)._add(xn), _r._rotateAround(Vi, ji)._add(ti)._add(xn), tn._rotateAround(Vi, ji)._add(ti)._add(xn), Oi._rotateAround(Vi, ji)._add(ti)._add(xn) } if (Te) { const ji = Math.sin(Te), Vi = Math.cos(Te), Pi = [Vi, -ji, ji, Vi]; Xi._matMult(Pi), _r._matMult(Pi), tn._matMult(Pi), Oi._matMult(Pi) } const Mr = new Ge(0, 0), ki = new Ge(0, 0); je.push({ tl: Xi, tr: _r, bl: tn, br: Oi, tex: Ce, writingMode: J.writingMode, glyphOffset: zi, sectionIndex: Ne.sectionIndex, isSDF: ut, pixelOffsetTL: Mr, pixelOffsetBR: ki, minFontScaleX: 0, minFontScaleY: 0 }) } return je }(0, n, _, l, d, p, s, r.allowVerticalPlacement), U = r.textSizeData; let W = null; U.kind === "source" ? (W = [Dn * l.layout.get("text-size").evaluate(p, {})], W[0] > Ls && Ui(`${r.layerIds[0]}: Value for "text-size" is >= ${ic}. Reduce your "text-size".`)) : U.kind === "composite" && (W = [Dn * R.compositeTextSizes[0].evaluate(p, {}, L), Dn * R.compositeTextSizes[1].evaluate(p, {}, L)], (W[0] > Ls || W[1] > Ls) && Ui(`${r.layerIds[0]}: Value for "text-size" is >= ${ic}. Reduce your "text-size".`)), r.addSymbols(r.text, O, W, _, d, p, b, t, y.lineStartIndex, y.lineLength, k, L); for (const se of T) M[se] = r.text.placedSymbolArray.length - 1; return 4 * O.length } function Af(r) { for (const t in r) return r[t]; return null } function Ng(r, t, n, s) { const l = r.compareText; if (t in l) { const d = l[t]; for (let p = d.length - 1; p >= 0; p--)if (s.dist(d[p]) < n) return !0 } else l[t] = []; return l[t].push(s), !1 } const zf = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array]; class cd { static from(t) { if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer."); const [n, s] = new Uint8Array(t, 0, 2); if (n !== 219) throw new Error("Data does not appear to be in a KDBush format."); const l = s >> 4; if (l !== 1) throw new Error(`Got v${l} data when expected v1.`); const d = zf[15 & s]; if (!d) throw new Error("Unrecognized array type."); const [p] = new Uint16Array(t, 2, 1), [_] = new Uint32Array(t, 4, 1); return new cd(_, p, d, t) } constructor(t, n = 64, s = Float64Array, l) { if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`); this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = s, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array; const d = zf.indexOf(this.ArrayType), p = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, _ = t * this.IndexArrayType.BYTES_PER_ELEMENT, y = (8 - _ % 8) % 8; if (d < 0) throw new Error(`Unexpected typed array class: ${s}.`); l && l instanceof ArrayBuffer ? (this.data = l, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + _ + y, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + p + _ + y), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + _ + y, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + d]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t) } add(t, n) { const s = this._pos >> 1; return this.ids[s] = s, this.coords[this._pos++] = t, this.coords[this._pos++] = n, s } finish() { const t = this._pos >> 1; if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`); return ud(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this } range(t, n, s, l) { if (!this._finished) throw new Error("Data not yet indexed - call index.finish()."); const { ids: d, coords: p, nodeSize: _ } = this, y = [0, d.length - 1, 0], b = []; for (; y.length;) { const T = y.pop() || 0, M = y.pop() || 0, k = y.pop() || 0; if (M - k <= _) { for (let U = k; U <= M; U++) { const W = p[2 * U], se = p[2 * U + 1]; W >= t && W <= s && se >= n && se <= l && b.push(d[U]) } continue } const R = k + M >> 1, L = p[2 * R], O = p[2 * R + 1]; L >= t && L <= s && O >= n && O <= l && b.push(d[R]), (T === 0 ? t <= L : n <= O) && (y.push(k), y.push(R - 1), y.push(1 - T)), (T === 0 ? s >= L : l >= O) && (y.push(R + 1), y.push(M), y.push(1 - T)) } return b } within(t, n, s) { if (!this._finished) throw new Error("Data not yet indexed - call index.finish()."); const { ids: l, coords: d, nodeSize: p } = this, _ = [0, l.length - 1, 0], y = [], b = s * s; for (; _.length;) { const T = _.pop() || 0, M = _.pop() || 0, k = _.pop() || 0; if (M - k <= p) { for (let U = k; U <= M; U++)Df(d[2 * U], d[2 * U + 1], t, n) <= b && y.push(l[U]); continue } const R = k + M >> 1, L = d[2 * R], O = d[2 * R + 1]; Df(L, O, t, n) <= b && y.push(l[R]), (T === 0 ? t - s <= L : n - s <= O) && (_.push(k), _.push(R - 1), _.push(1 - T)), (T === 0 ? t + s >= L : n + s >= O) && (_.push(R + 1), _.push(M), _.push(1 - T)) } return y } } function ud(r, t, n, s, l, d) { if (l - s <= n) return; const p = s + l >> 1; kf(r, t, p, s, l, d), ud(r, t, n, s, p - 1, 1 - d), ud(r, t, n, p + 1, l, 1 - d) } function kf(r, t, n, s, l, d) { for (; l > s;) { if (l - s > 600) { const b = l - s + 1, T = n - s + 1, M = Math.log(b), k = .5 * Math.exp(2 * M / 3), R = .5 * Math.sqrt(M * k * (b - k) / b) * (T - b / 2 < 0 ? -1 : 1); kf(r, t, n, Math.max(s, Math.floor(n - T * k / b + R)), Math.min(l, Math.floor(n + (b - T) * k / b + R)), d) } const p = t[2 * n + d]; let _ = s, y = l; for (sc(r, t, s, n), t[2 * l + d] > p && sc(r, t, s, l); _ < y;) { for (sc(r, t, _, y), _++, y--; t[2 * _ + d] < p;)_++; for (; t[2 * y + d] > p;)y-- } t[2 * s + d] === p ? sc(r, t, s, y) : (y++, sc(r, t, y, l)), y <= n && (s = y + 1), n <= y && (l = y - 1) } } function sc(r, t, n, s) { hd(r, n, s), hd(t, 2 * n, 2 * s), hd(t, 2 * n + 1, 2 * s + 1) } function hd(r, t, n) { const s = r[t]; r[t] = r[n], r[n] = s } function Df(r, t, n, s) { const l = r - n, d = t - s; return l * l + d * d } var dd; P.cg = void 0, (dd = P.cg || (P.cg = {})).create = "create", dd.load = "load", dd.fullLoad = "fullLoad"; let Fu = null, oc = []; const pd = 1e3 / 60, fd = "loadTime", md = "fullLoadTime", Zg = { mark(r) { performance.mark(r) }, frame(r) { const t = r; Fu != null && oc.push(t - Fu), Fu = t }, clearMetrics() { Fu = null, oc = [], performance.clearMeasures(fd), performance.clearMeasures(md); for (const r in P.cg) performance.clearMarks(P.cg[r]) }, getPerformanceMetrics() { performance.measure(fd, P.cg.create, P.cg.load), performance.measure(md, P.cg.create, P.cg.fullLoad); const r = performance.getEntriesByName(fd)[0].duration, t = performance.getEntriesByName(md)[0].duration, n = oc.length, s = 1 / (oc.reduce((d, p) => d + p, 0) / n / 1e3), l = oc.filter(d => d > pd).reduce((d, p) => d + (p - pd) / pd, 0); return { loadTime: r, fullLoadTime: t, fps: s, percentDroppedFrames: l / (n + l) * 100, totalFrames: n } } }; P.$ = rc, P.A = Et, P.B = br, P.C = si, P.D = nt, P.E = ue, P.F = lu, P.G = function (r) { if (we == null) { const t = r.navigator ? r.navigator.userAgent : null; we = !!r.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome"))) } return we }, P.H = class { constructor(r, t) { this.target = r, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new kg(() => this.process()), this.subscription = qe(this.target, "message", n => this.receive(n), !1), this.globalScope = le(self) ? r : window } registerMessageHandler(r, t) { this.messageHandlers[r] = t } sendAsync(r, t) { return new Promise((n, s) => { const l = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), d = t ? qe(t.signal, "abort", () => { d == null || d.unsubscribe(), delete this.resolveRejects[l]; const y = { id: l, type: "<cancel>", origin: location.origin, targetMapId: r.targetMapId, sourceMapId: this.mapId }; this.target.postMessage(y) }, Dg) : null; this.resolveRejects[l] = { resolve: y => { d == null || d.unsubscribe(), n(y) }, reject: y => { d == null || d.unsubscribe(), s(y) } }; const p = [], _ = Object.assign(Object.assign({}, r), { id: l, sourceMapId: this.mapId, origin: location.origin, data: An(r.data, p) }); this.target.postMessage(_, { transfer: p }) }) } receive(r) { const t = r.data, n = t.id; if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) { if (t.type === "<cancel>") { delete this.tasks[n]; const s = this.abortControllers[n]; return delete this.abortControllers[n], void (s && s.abort()) } if (le(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger(); this.processTask(n, t) } } process() { if (this.taskQueue.length === 0) return; const r = this.taskQueue.shift(), t = this.tasks[r]; delete this.tasks[r], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(r, t) } processTask(r, t) { return c(this, void 0, void 0, function* () { if (t.type === "<response>") { const l = this.resolveRejects[r]; return delete this.resolveRejects[r], l ? void (t.error ? l.reject(ao(t.error)) : l.resolve(ao(t.data))) : void 0 } if (!this.messageHandlers[t.type]) return void this.completeTask(r, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`)); const n = ao(t.data), s = new AbortController; this.abortControllers[r] = s; try { const l = yield this.messageHandlers[t.type](t.sourceMapId, n, s); this.completeTask(r, null, l) } catch (l) { this.completeTask(r, l) } }) } completeTask(r, t, n) { const s = []; delete this.abortControllers[r]; const l = { id: r, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: t ? An(t) : null, data: An(n, s) }; this.target.postMessage(l, { transfer: s }) } remove() { this.invoker.remove(), this.subscription.unsubscribe() } }, P.I = Kh, P.J = vt, P.K = function () { var r = new Et(16); return Et != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r }, P.L = function (r, t, n) { var s, l, d, p, _, y, b, T, M, k, R, L, O = n[0], U = n[1], W = n[2]; return t === r ? (r[12] = t[0] * O + t[4] * U + t[8] * W + t[12], r[13] = t[1] * O + t[5] * U + t[9] * W + t[13], r[14] = t[2] * O + t[6] * U + t[10] * W + t[14], r[15] = t[3] * O + t[7] * U + t[11] * W + t[15]) : (l = t[1], d = t[2], p = t[3], _ = t[4], y = t[5], b = t[6], T = t[7], M = t[8], k = t[9], R = t[10], L = t[11], r[0] = s = t[0], r[1] = l, r[2] = d, r[3] = p, r[4] = _, r[5] = y, r[6] = b, r[7] = T, r[8] = M, r[9] = k, r[10] = R, r[11] = L, r[12] = s * O + _ * U + M * W + t[12], r[13] = l * O + y * U + k * W + t[13], r[14] = d * O + b * U + R * W + t[14], r[15] = p * O + T * U + L * W + t[15]), r }, P.M = function (r, t, n) { var s = n[0], l = n[1], d = n[2]; return r[0] = t[0] * s, r[1] = t[1] * s, r[2] = t[2] * s, r[3] = t[3] * s, r[4] = t[4] * l, r[5] = t[5] * l, r[6] = t[6] * l, r[7] = t[7] * l, r[8] = t[8] * d, r[9] = t[9] * d, r[10] = t[10] * d, r[11] = t[11] * d, r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15], r }, P.N = function (r, t, n) { var s = t[0], l = t[1], d = t[2], p = t[3], _ = t[4], y = t[5], b = t[6], T = t[7], M = t[8], k = t[9], R = t[10], L = t[11], O = t[12], U = t[13], W = t[14], se = t[15], J = n[0], D = n[1], N = n[2], Y = n[3]; return r[0] = J * s + D * _ + N * M + Y * O, r[1] = J * l + D * y + N * k + Y * U, r[2] = J * d + D * b + N * R + Y * W, r[3] = J * p + D * T + N * L + Y * se, r[4] = (J = n[4]) * s + (D = n[5]) * _ + (N = n[6]) * M + (Y = n[7]) * O, r[5] = J * l + D * y + N * k + Y * U, r[6] = J * d + D * b + N * R + Y * W, r[7] = J * p + D * T + N * L + Y * se, r[8] = (J = n[8]) * s + (D = n[9]) * _ + (N = n[10]) * M + (Y = n[11]) * O, r[9] = J * l + D * y + N * k + Y * U, r[10] = J * d + D * b + N * R + Y * W, r[11] = J * p + D * T + N * L + Y * se, r[12] = (J = n[12]) * s + (D = n[13]) * _ + (N = n[14]) * M + (Y = n[15]) * O, r[13] = J * l + D * y + N * k + Y * U, r[14] = J * d + D * b + N * R + Y * W, r[15] = J * p + D * T + N * L + Y * se, r }, P.O = function (r, t) { const n = {}; for (let s = 0; s < t.length; s++) { const l = t[s]; l in r && (n[l] = r[l]) } return n }, P.P = Ge, P.Q = Fs, P.R = Yr, P.S = lf, P.T = Rl, P.U = af, P.V = qt, P.W = ot, P.X = Oe, P.Y = Qr, P.Z = gt, P._ = c, P.a = ct, P.a$ = function () { const r = new Float32Array(16); return ln(r), r }, P.a0 = od, P.a1 = r => { const t = window.document.createElement("video"); return t.muted = !0, new Promise(n => { t.onloadstart = () => { n(t) }; for (const s of r) { const l = window.document.createElement("source"); ui(s) || (t.crossOrigin = "Anonymous"), l.src = s, t.appendChild(l) } }) }, P.a2 = fe, P.a3 = function () { return xr++ }, P.a4 = f, P.a5 = Pa, P.a6 = ea, P.a7 = Tr, P.a8 = mf, P.a9 = function (r) { const t = {}; if (r.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (n, s, l, d) => { const p = l || d; return t[s] = !p || p.toLowerCase(), "" }), t["max-age"]) { const n = parseInt(t["max-age"], 10); isNaN(n) ? delete t["max-age"] : t["max-age"] = n } return t }, P.aA = Yh, P.aB = cd, P.aC = xi, P.aD = Pu, P.aE = H, P.aF = st, P.aG = $e, P.aH = function (r) { return Math.pow(2, r) }, P.aI = 85.051129, P.aJ = cf, P.aK = ur, P.aL = Ve, P.aM = uf, P.aN = function (r, t, n) { return r[0] = t[0] * n, r[1] = t[1] * n, r[2] = t[2] * n, r }, P.aO = function (r, t, n) { return r[0] = t[0] + n[0], r[1] = t[1] + n[1], r[2] = t[2] + n[2], r }, P.aP = function (r) { var t = new Et(3); return t[0] = r[0], t[1] = r[1], t[2] = r[2], t }, P.aQ = function (r, t, n) { return r[0] = t[0] * n[0], r[1] = t[1] * n[1], r[2] = t[2] * n[2], r[3] = t[3] * n[3], r }, P.aR = function (r, t, n) { return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], r }, P.aS = function (r, t) { var n = t[0], s = t[1], l = t[2], d = n * n + s * s + l * l; return d > 0 && (d = 1 / Math.sqrt(d)), r[0] = t[0] * d, r[1] = t[1] * d, r[2] = t[2] * d, r }, P.aT = function (r, t, n) { var s = t[0], l = t[1], d = t[2], p = n[0], _ = n[1], y = n[2]; return r[0] = l * y - d * _, r[1] = d * p - s * y, r[2] = s * _ - l * p, r }, P.aU = function (r, t) { return r[0] * t[0] + r[1] * t[1] + r[2] * t[2] }, P.aV = df, P.aW = Sa, P.aX = function (r, t, n, s, l) { var d, p = 1 / Math.tan(t / 2); return r[0] = p / n, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = p, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, l != null && l !== 1 / 0 ? (r[10] = (l + s) * (d = 1 / (s - l)), r[14] = 2 * l * s * d) : (r[10] = -1, r[14] = -2 * s), r }, P.aY = function (r) { var t = new Et(16); return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], t }, P.aZ = function (r, t, n) { var s = Math.sin(n), l = Math.cos(n), d = t[0], p = t[1], _ = t[2], y = t[3], b = t[4], T = t[5], M = t[6], k = t[7]; return t !== r && (r[8] = t[8], r[9] = t[9], r[10] = t[10], r[11] = t[11], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15]), r[0] = d * l + b * s, r[1] = p * l + T * s, r[2] = _ * l + M * s, r[3] = y * l + k * s, r[4] = b * l - d * s, r[5] = T * l - p * s, r[6] = M * l - _ * s, r[7] = k * l - y * s, r }, P.a_ = function (r, t, n) { var s = Math.sin(n), l = Math.cos(n), d = t[4], p = t[5], _ = t[6], y = t[7], b = t[8], T = t[9], M = t[10], k = t[11]; return t !== r && (r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15]), r[4] = d * l + b * s, r[5] = p * l + T * s, r[6] = _ * l + M * s, r[7] = y * l + k * s, r[8] = b * l - d * s, r[9] = T * l - p * s, r[10] = M * l - _ * s, r[11] = k * l - y * s, r }, P.aa = function (r) { return Math.log(r) / Math.LN2 }, P.ab = function (r) { var t = r[0], n = r[1]; return t * t + n * n }, P.ac = function (r) { return r * Math.PI / 180 }, P.ad = cr, P.ae = function (r, t) { const n = []; for (const s in r) s in t || n.push(s); return n }, P.af = function (r, t) { let n = 0, s = 0; if (r.kind === "constant") s = r.layoutSize; else if (r.kind !== "source") { const { interpolationType: l, minZoom: d, maxZoom: p } = r, _ = l ? cr(Qi.interpolationFactor(l, t, d, p), 0, 1) : 0; r.kind === "camera" ? s = br.number(r.minSize, r.maxSize, _) : n = _ } return { uSizeT: n, uSize: s } }, P.ah = function (r, { uSize: t, uSizeT: n }, { lowerSize: s, upperSize: l }) { return r.kind === "source" ? s / Dn : r.kind === "composite" ? br.number(s / Dn, l / Dn, n) : t }, P.ai = function (r, t) { var n = t[0], s = t[1], l = t[2], d = t[3], p = t[4], _ = t[5], y = t[6], b = t[7], T = t[8], M = t[9], k = t[10], R = t[11], L = t[12], O = t[13], U = t[14], W = t[15], se = n * _ - s * p, J = n * y - l * p, D = n * b - d * p, N = s * y - l * _, Y = s * b - d * _, _e = l * b - d * y, ke = T * O - M * L, ve = T * U - k * L, Te = T * W - R * L, je = M * U - k * O, Re = M * W - R * O, Ne = k * W - R * U, Ce = se * Ne - J * Re + D * je + N * Te - Y * ve + _e * ke; return Ce ? (r[0] = (_ * Ne - y * Re + b * je) * (Ce = 1 / Ce), r[1] = (l * Re - s * Ne - d * je) * Ce, r[2] = (O * _e - U * Y + W * N) * Ce, r[3] = (k * Y - M * _e - R * N) * Ce, r[4] = (y * Te - p * Ne - b * ve) * Ce, r[5] = (n * Ne - l * Te + d * ve) * Ce, r[6] = (U * D - L * _e - W * J) * Ce, r[7] = (T * _e - k * D + R * J) * Ce, r[8] = (p * Re - _ * Te + b * ke) * Ce, r[9] = (s * Te - n * Re - d * ke) * Ce, r[10] = (L * Y - O * D + W * se) * Ce, r[11] = (M * D - T * Y - R * se) * Ce, r[12] = (_ * ve - p * je - y * ke) * Ce, r[13] = (n * je - s * ve + l * ke) * Ce, r[14] = (O * J - L * N - U * se) * Ce, r[15] = (T * N - M * J + k * se) * Ce, r) : null }, P.aj = bi, P.ak = function (r) { return Math.hypot(r[0], r[1]) }, P.al = function (r) { return r[0] = 0, r[1] = 0, r }, P.am = function (r, t, n) { return r[0] = t[0] * n, r[1] = t[1] * n, r }, P.an = ed, P.ao = ar, P.ap = function (r, t, n, s) { const l = t.y - r.y, d = t.x - r.x, p = s.y - n.y, _ = s.x - n.x, y = p * d - _ * l; if (y === 0) return null; const b = (_ * (r.y - n.y) - p * (r.x - n.x)) / y; return new Ge(r.x + b * d, r.y + b * l) }, P.aq = xf, P.ar = ga, P.as = ln, P.at = function (r) { let t = 1 / 0, n = 1 / 0, s = -1 / 0, l = -1 / 0; for (const d of r) t = Math.min(t, d.x), n = Math.min(n, d.y), s = Math.max(s, d.x), l = Math.max(l, d.y); return [t, n, s, l] }, P.au = Ai, P.av = Ut, P.aw = function (r, t, n, s, l = !1) { if (!n[0] && !n[1]) return [0, 0]; const d = l ? s === "map" ? -r.bearingInRadians : 0 : s === "viewport" ? r.bearingInRadians : 0; if (d) { const p = Math.sin(d), _ = Math.cos(d); n = [n[0] * _ - n[1] * p, n[0] * p + n[1] * _] } return [l ? n[0] : Ut(t, n[0], r.zoom), l ? n[1] : Ut(t, n[1], r.zoom)] }, P.ay = Qh, P.az = ld, P.b = Ze, P.b$ = r => r.type === "circle", P.b0 = function () { const r = new Float64Array(16); return ln(r), r }, P.b1 = function () { return new Float64Array(16) }, P.b2 = function (r, t, n) { const s = new Float64Array(4); return function (l, d, p, _) { var y = .5 * Math.PI / 180; d *= y, p *= y, _ *= y; var b = Math.sin(d), T = Math.cos(d), M = Math.sin(p), k = Math.cos(p), R = Math.sin(_), L = Math.cos(_); l[0] = b * k * L - T * M * R, l[1] = T * M * L + b * k * R, l[2] = T * k * R - b * M * L, l[3] = T * k * L + b * M * R }(s, r, t - 90, n), s }, P.b3 = function (r, t, n, s) { var l, d, p, _, y, b = t[0], T = t[1], M = t[2], k = t[3], R = n[0], L = n[1], O = n[2], U = n[3]; return (d = b * R + T * L + M * O + k * U) < 0 && (d = -d, R = -R, L = -L, O = -O, U = -U), 1 - d > Vt ? (l = Math.acos(d), p = Math.sin(l), _ = Math.sin((1 - s) * l) / p, y = Math.sin(s * l) / p) : (_ = 1 - s, y = s), r[0] = _ * b + y * R, r[1] = _ * T + y * L, r[2] = _ * M + y * O, r[3] = _ * k + y * U, r }, P.b4 = function (r) { const t = new Float64Array(9); var n, s, l, d, p, _, y, b, T, M, k, R, L, O, U, W, se, J; M = (l = (s = r)[0]) * (y = l + l), k = (d = s[1]) * y, L = (p = s[2]) * y, O = p * (b = d + d), W = (_ = s[3]) * y, se = _ * b, J = _ * (T = p + p), (n = t)[0] = 1 - (R = d * b) - (U = p * T), n[3] = k - J, n[6] = L + se, n[1] = k + J, n[4] = 1 - M - U, n[7] = O - W, n[2] = L - se, n[5] = O + W, n[8] = 1 - M - R; const D = Ve(-Math.asin(cr(t[2], -1, 1))); let N, Y; return Math.hypot(t[5], t[8]) < .001 ? (N = 0, Y = -Ve(Math.atan2(t[3], t[4]))) : (N = Ve(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), Y = Ve(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), { roll: N, pitch: D + 90, bearing: Y } }, P.b5 = function (r, t) { return r.roll == t.roll && r.pitch == t.pitch && r.bearing == t.bearing }, P.b6 = Lt, P.b7 = ns, P.b8 = wa, P.b9 = Xl, P.bA = function (r) { const t = [], n = r.id; return n === void 0 && t.push({ message: `layers.${n}: missing required property "id"` }), r.render === void 0 && t.push({ message: `layers.${n}: missing required method "render"` }), r.renderingMode && r.renderingMode !== "2d" && r.renderingMode !== "3d" && t.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), t }, P.bB = function r(t, n) { if (Array.isArray(t)) { if (!Array.isArray(n) || t.length !== n.length) return !1; for (let s = 0; s < t.length; s++)if (!r(t[s], n[s])) return !1; return !0 } if (typeof t == "object" && t !== null && n !== null) { if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return !1; for (const s in t) if (!r(t[s], n[s])) return !1; return !0 } return t === n }, P.bC = Dr, P.bD = Gr, P.bE = class extends Ur { constructor(r, t) { super(r, t), this.current = 0 } set(r) { this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r)) } }, P.bF = ss, P.bG = class extends Ur { constructor(r, t) { super(r, t), this.current = $r } set(r) { if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r); for (let t = 1; t < 16; t++)if (r[t] !== this.current[t]) { this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r); break } } }, P.bH = po, P.bI = class extends Ur { constructor(r, t) { super(r, t), this.current = [0, 0, 0] } set(r) { r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])) } }, P.bJ = class extends Ur { constructor(r, t) { super(r, t), this.current = [0, 0] } set(r) { r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])) } }, P.bK = Nt, P.bL = function (r, t) { var n = Math.sin(t), s = Math.cos(t); return r[0] = s, r[1] = n, r[2] = 0, r[3] = -n, r[4] = s, r[5] = 0, r[6] = 0, r[7] = 0, r[8] = 1, r }, P.bM = function (r, t, n) { var s = t[0], l = t[1], d = t[2]; return r[0] = s * n[0] + l * n[3] + d * n[6], r[1] = s * n[1] + l * n[4] + d * n[7], r[2] = s * n[2] + l * n[5] + d * n[8], r }, P.bN = function (r, t, n, s, l, d, p) { var _ = 1 / (t - n), y = 1 / (s - l), b = 1 / (d - p); return r[0] = -2 * _, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * y, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * b, r[11] = 0, r[12] = (t + n) * _, r[13] = (l + s) * y, r[14] = (p + d) * b, r[15] = 1, r }, P.bO = class extends da { }, P.bP = lg, P.bQ = class extends pa { }, P.bR = Rh, P.bS = function (r) { return r <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2)) }, P.bT = pp, P.bU = function (r, t, n) { var s = t[0], l = t[1], d = t[2], p = n[3] * s + n[7] * l + n[11] * d + n[15]; return r[0] = (n[0] * s + n[4] * l + n[8] * d + n[12]) / (p = p || 1), r[1] = (n[1] * s + n[5] * l + n[9] * d + n[13]) / p, r[2] = (n[2] * s + n[6] * l + n[10] * d + n[14]) / p, r }, P.bV = class extends Bl { }, P.bW = class extends o { }, P.bX = function (r, t) { return r[0] === t[0] && r[1] === t[1] && r[2] === t[2] && r[3] === t[3] && r[4] === t[4] && r[5] === t[5] && r[6] === t[6] && r[7] === t[7] && r[8] === t[8] && r[9] === t[9] && r[10] === t[10] && r[11] === t[11] && r[12] === t[12] && r[13] === t[13] && r[14] === t[14] && r[15] === t[15] }, P.bY = function (r, t) { var n = r[0], s = r[1], l = r[2], d = r[3], p = r[4], _ = r[5], y = r[6], b = r[7], T = r[8], M = r[9], k = r[10], R = r[11], L = r[12], O = r[13], U = r[14], W = r[15], se = t[0], J = t[1], D = t[2], N = t[3], Y = t[4], _e = t[5], ke = t[6], ve = t[7], Te = t[8], je = t[9], Re = t[10], Ne = t[11], Ce = t[12], Ye = t[13], ut = t[14], lt = t[15]; return Math.abs(n - se) <= Vt * Math.max(1, Math.abs(n), Math.abs(se)) && Math.abs(s - J) <= Vt * Math.max(1, Math.abs(s), Math.abs(J)) && Math.abs(l - D) <= Vt * Math.max(1, Math.abs(l), Math.abs(D)) && Math.abs(d - N) <= Vt * Math.max(1, Math.abs(d), Math.abs(N)) && Math.abs(p - Y) <= Vt * Math.max(1, Math.abs(p), Math.abs(Y)) && Math.abs(_ - _e) <= Vt * Math.max(1, Math.abs(_), Math.abs(_e)) && Math.abs(y - ke) <= Vt * Math.max(1, Math.abs(y), Math.abs(ke)) && Math.abs(b - ve) <= Vt * Math.max(1, Math.abs(b), Math.abs(ve)) && Math.abs(T - Te) <= Vt * Math.max(1, Math.abs(T), Math.abs(Te)) && Math.abs(M - je) <= Vt * Math.max(1, Math.abs(M), Math.abs(je)) && Math.abs(k - Re) <= Vt * Math.max(1, Math.abs(k), Math.abs(Re)) && Math.abs(R - Ne) <= Vt * Math.max(1, Math.abs(R), Math.abs(Ne)) && Math.abs(L - Ce) <= Vt * Math.max(1, Math.abs(L), Math.abs(Ce)) && Math.abs(O - Ye) <= Vt * Math.max(1, Math.abs(O), Math.abs(Ye)) && Math.abs(U - ut) <= Vt * Math.max(1, Math.abs(U), Math.abs(ut)) && Math.abs(W - lt) <= Vt * Math.max(1, Math.abs(W), Math.abs(lt)) }, P.bZ = function (r, t) { return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4], r[5] = t[5], r[6] = t[6], r[7] = t[7], r[8] = t[8], r[9] = t[9], r[10] = t[10], r[11] = t[11], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15], r }, P.b_ = r => r.type === "symbol", P.ba = ba, P.bb = rr, P.bc = kr, P.bd = dr, P.be = function (r, t, n, s, l) { return rr(s, l, cr((r - t) / (n - t), 0, 1)) }, P.bf = Dt, P.bg = function () { return new Float64Array(4) }, P.bh = function () { return new Float64Array(3) }, P.bi = function (r, t, n, s) { var l = [], d = []; return l[0] = t[0] - n[0], l[1] = t[1] - n[1], l[2] = t[2] - n[2], d[0] = l[0] * Math.cos(s) - l[1] * Math.sin(s), d[1] = l[0] * Math.sin(s) + l[1] * Math.cos(s), d[2] = l[2], r[0] = d[0] + n[0], r[1] = d[1] + n[1], r[2] = d[2] + n[2], r }, P.bj = function (r, t, n, s) { var l = [], d = []; return l[0] = t[0] - n[0], l[1] = t[1] - n[1], l[2] = t[2] - n[2], d[0] = l[0], d[1] = l[1] * Math.cos(s) - l[2] * Math.sin(s), d[2] = l[1] * Math.sin(s) + l[2] * Math.cos(s), r[0] = d[0] + n[0], r[1] = d[1] + n[1], r[2] = d[2] + n[2], r }, P.bk = function (r, t, n, s) { var l = [], d = []; return l[0] = t[0] - n[0], l[1] = t[1] - n[1], l[2] = t[2] - n[2], d[0] = l[2] * Math.sin(s) + l[0] * Math.cos(s), d[1] = l[1], d[2] = l[2] * Math.cos(s) - l[0] * Math.sin(s), r[0] = d[0] + n[0], r[1] = d[1] + n[1], r[2] = d[2] + n[2], r }, P.bl = function (r, t, n) { var s = Math.sin(n), l = Math.cos(n), d = t[0], p = t[1], _ = t[2], y = t[3], b = t[8], T = t[9], M = t[10], k = t[11]; return t !== r && (r[4] = t[4], r[5] = t[5], r[6] = t[6], r[7] = t[7], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15]), r[0] = d * l - b * s, r[1] = p * l - T * s, r[2] = _ * l - M * s, r[3] = y * l - k * s, r[8] = d * s + b * l, r[9] = p * s + T * l, r[10] = _ * s + M * l, r[11] = y * s + k * l, r }, P.bm = function (r, t) { const n = Dt(r, 360), s = Dt(t, 360), l = s - n, d = s > n ? l - 360 : l + 360; return Math.abs(l) < Math.abs(d) ? l : d }, P.bn = function (r) { return r[0] = 0, r[1] = 0, r[2] = 0, r }, P.bo = function (r, t, n, s) { const l = Math.sqrt(r * r + t * t), d = Math.sqrt(n * n + s * s); r /= l, t /= l, n /= d, s /= d; const p = Math.acos(r * n + t * s); return -t * n + r * s > 0 ? p : -p }, P.bp = function (r, t) { return r[0] * t[0] + r[1] * t[1] + r[2] * t[2] + r[3] }, P.bq = nd, P.br = function (r, t) { const n = Dt(r, 2 * Math.PI), s = Dt(t, 2 * Math.PI); return Math.min(Math.abs(n - s), Math.abs(n - s + 2 * Math.PI), Math.abs(n - s - 2 * Math.PI)) }, P.bs = function (r) { return Math.hypot(r[0], r[1], r[2]) }, P.bt = function () { const r = {}, t = C.$version; for (const n in C.$root) { const s = C.$root[n]; if (s.required) { let l = null; l = n === "version" ? t : s.type === "array" ? [] : {}, l != null && (r[n] = l) } } return r }, P.bu = ra, P.bv = Pt, P.bw = function (r) { r = r.slice(); const t = Object.create(null); for (let n = 0; n < r.length; n++)t[r[n].id] = r[n]; for (let n = 0; n < r.length; n++)"ref" in r[n] && (r[n] = $(r[n], t[r[n].ref])); return r }, P.bx = function (r) { if (r.type === "custom") return new zg(r); switch (r.type) { case "background": return new Cg(r); case "circle": return new T_(r); case "fill": return new Z_(r); case "fill-extrusion": return new K_(r); case "heatmap": return new S_(r); case "hillshade": return new I_(r); case "line": return new ng(r); case "raster": return new Ag(r); case "symbol": return new zu(r) } }, P.by = Ki, P.bz = function (r, t) { if (!r) return [{ command: "setStyle", args: [t] }]; let n = []; try { if (!X(r.version, t.version)) return [{ command: "setStyle", args: [t] }]; X(r.center, t.center) || n.push({ command: "setCenter", args: [t.center] }), X(r.centerAltitude, t.centerAltitude) || n.push({ command: "setCenterAltitude", args: [t.centerAltitude] }), X(r.zoom, t.zoom) || n.push({ command: "setZoom", args: [t.zoom] }), X(r.bearing, t.bearing) || n.push({ command: "setBearing", args: [t.bearing] }), X(r.pitch, t.pitch) || n.push({ command: "setPitch", args: [t.pitch] }), X(r.roll, t.roll) || n.push({ command: "setRoll", args: [t.roll] }), X(r.sprite, t.sprite) || n.push({ command: "setSprite", args: [t.sprite] }), X(r.glyphs, t.glyphs) || n.push({ command: "setGlyphs", args: [t.glyphs] }), X(r.transition, t.transition) || n.push({ command: "setTransition", args: [t.transition] }), X(r.light, t.light) || n.push({ command: "setLight", args: [t.light] }), X(r.terrain, t.terrain) || n.push({ command: "setTerrain", args: [t.terrain] }), X(r.sky, t.sky) || n.push({ command: "setSky", args: [t.sky] }), X(r.projection, t.projection) || n.push({ command: "setProjection", args: [t.projection] }); const s = {}, l = []; (function (p, _, y, b) { let T; for (T in _ = _ || {}, p = p || {}) Object.prototype.hasOwnProperty.call(p, T) && (Object.prototype.hasOwnProperty.call(_, T) || ye(T, y, b)); for (T in _) Object.prototype.hasOwnProperty.call(_, T) && (Object.prototype.hasOwnProperty.call(p, T) ? X(p[T], _[T]) || (p[T].type === "geojson" && _[T].type === "geojson" && Me(p, _, T) ? ie(y, { command: "setGeoJSONSourceData", args: [T, _[T].data] }) : ce(T, _, y, b)) : he(T, _, y)) })(r.sources, t.sources, l, s); const d = []; r.layers && r.layers.forEach(p => { "source" in p && s[p.source] ? n.push({ command: "removeLayer", args: [p.id] }) : d.push(p) }), n = n.concat(l), function (p, _, y) { _ = _ || []; const b = (p = p || []).map(pe), T = _.map(pe), M = p.reduce(Ae, {}), k = _.reduce(Ae, {}), R = b.slice(), L = Object.create(null); let O, U, W, se, J; for (let D = 0, N = 0; D < b.length; D++)O = b[D], Object.prototype.hasOwnProperty.call(k, O) ? N++ : (ie(y, { command: "removeLayer", args: [O] }), R.splice(R.indexOf(O, N), 1)); for (let D = 0, N = 0; D < T.length; D++)O = T[T.length - 1 - D], R[R.length - 1 - D] !== O && (Object.prototype.hasOwnProperty.call(M, O) ? (ie(y, { command: "removeLayer", args: [O] }), R.splice(R.lastIndexOf(O, R.length - N), 1)) : N++, se = R[R.length - D], ie(y, { command: "addLayer", args: [k[O], se] }), R.splice(R.length - D, 0, O), L[O] = !0); for (let D = 0; D < T.length; D++)if (O = T[D], U = M[O], W = k[O], !L[O] && !X(U, W)) if (X(U.source, W.source) && X(U["source-layer"], W["source-layer"]) && X(U.type, W.type)) { for (J in be(U.layout, W.layout, y, O, null, "setLayoutProperty"), be(U.paint, W.paint, y, O, null, "setPaintProperty"), X(U.filter, W.filter) || ie(y, { command: "setFilter", args: [O, W.filter] }), X(U.minzoom, W.minzoom) && X(U.maxzoom, W.maxzoom) || ie(y, { command: "setLayerZoomRange", args: [O, W.minzoom, W.maxzoom] }), U) Object.prototype.hasOwnProperty.call(U, J) && J !== "layout" && J !== "paint" && J !== "filter" && J !== "metadata" && J !== "minzoom" && J !== "maxzoom" && (J.indexOf("paint.") === 0 ? be(U[J], W[J], y, O, J.slice(6), "setPaintProperty") : X(U[J], W[J]) || ie(y, { command: "setLayerProperty", args: [O, J, W[J]] })); for (J in W) Object.prototype.hasOwnProperty.call(W, J) && !Object.prototype.hasOwnProperty.call(U, J) && J !== "layout" && J !== "paint" && J !== "filter" && J !== "metadata" && J !== "minzoom" && J !== "maxzoom" && (J.indexOf("paint.") === 0 ? be(U[J], W[J], y, O, J.slice(6), "setPaintProperty") : X(U[J], W[J]) || ie(y, { command: "setLayerProperty", args: [O, J, W[J]] })) } else ie(y, { command: "removeLayer", args: [O] }), se = R[R.lastIndexOf(O) + 1], ie(y, { command: "addLayer", args: [W, se] }) }(d, t.layers, n) } catch (s) { console.warn("Unable to compute style diff:", s), n = [{ command: "setStyle", args: [t] }] } return n }, P.c = Ke, P.c0 = r => r.type === "heatmap", P.c1 = r => r.type === "line", P.c2 = r => r.type === "fill", P.c3 = r => r.type === "fill-extrusion", P.c4 = r => r.type === "hillshade", P.c5 = r => r.type === "raster", P.c6 = r => r.type === "background", P.c7 = r => r.type === "custom", P.c8 = lr, P.c9 = function (r, t, n) { const s = Pn(t.x - n.x, t.y - n.y), l = Pn(r.x - n.x, r.y - n.y); var d, p; return Ve(Math.atan2(s[0] * l[1] - s[1] * l[0], (d = s)[0] * (p = l)[0] + d[1] * p[1])) }, P.cA = Fe, P.cB = Ap, P.cC = Zp, P.cD = Yn, P.cE = zn, P.ca = gi, P.cb = function (r, t, n) { var s = t[0], l = t[1]; return r[0] = n[0] * s + n[4] * l + n[12], r[1] = n[1] * s + n[5] * l + n[13], r }, P.cc = function (r, t) { const { x: n, y: s } = rc.fromLngLat(t); return !(r < 0 || r > 25 || s < 0 || s >= 1 || n < 0 || n >= 1) }, P.cd = function (r, t) { return r[0] = t[0], r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = t[1], r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = t[2], r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r }, P.ce = class extends ca { }, P.cf = Zg, P.ch = function (r) { return r.message === dt }, P.ci = At, P.cj = function (r, t) { ct.REGISTERED_PROTOCOLS[r] = t }, P.ck = function (r) { delete ct.REGISTERED_PROTOCOLS[r] }, P.cl = function (r, t) { const n = {}; for (let l = 0; l < r.length; l++) { const d = t && t[r[l].id] || vl(r[l]); t && (t[r[l].id] = d); let p = n[d]; p || (p = n[d] = []), p.push(r[l]) } const s = []; for (const l in n) s.push(n[l]); return s }, P.cm = Je, P.cn = ff, P.co = _f, P.cp = $p, P.cq = function (r) { r.bucket.createArrays(), r.bucket.tilePixelRatio = gt / (512 * r.bucket.overscaling), r.bucket.compareText = {}, r.bucket.iconsNeedLinear = !1; const t = r.bucket.layers[0], n = t.layout, s = t._unevaluatedLayout._values, l = { layoutIconSize: s["icon-size"].possiblyEvaluate(new si(r.bucket.zoom + 1), r.canonical), layoutTextSize: s["text-size"].possiblyEvaluate(new si(r.bucket.zoom + 1), r.canonical), textMaxSize: s["text-size"].possiblyEvaluate(new si(18)) }; if (r.bucket.textSizeData.kind === "composite") { const { minZoom: b, maxZoom: T } = r.bucket.textSizeData; l.compositeTextSizes = [s["text-size"].possiblyEvaluate(new si(b), r.canonical), s["text-size"].possiblyEvaluate(new si(T), r.canonical)] } if (r.bucket.iconSizeData.kind === "composite") { const { minZoom: b, maxZoom: T } = r.bucket.iconSizeData; l.compositeIconSizes = [s["icon-size"].possiblyEvaluate(new si(b), r.canonical), s["icon-size"].possiblyEvaluate(new si(T), r.canonical)] } const d = n.get("text-line-height") * Ai, p = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point", _ = n.get("text-keep-upright"), y = n.get("text-size"); for (const b of r.bucket.features) { const T = n.get("text-font").evaluate(b, {}, r.canonical).join(","), M = y.evaluate(b, {}, r.canonical), k = l.layoutTextSize.evaluate(b, {}, r.canonical), R = l.layoutIconSize.evaluate(b, {}, r.canonical), L = { horizontal: {}, vertical: void 0 }, O = b.text; let U, W = [0, 0]; if (O) { const D = O.toString(), N = n.get("text-letter-spacing").evaluate(b, {}, r.canonical) * Ai, Y = uu(D) ? N : 0, _e = n.get("text-anchor").evaluate(b, {}, r.canonical), ke = Cf(t, b, r.canonical); if (!ke) { const Re = n.get("text-radial-offset").evaluate(b, {}, r.canonical); W = Re ? If(_e, [Re * Ai, ad]) : n.get("text-offset").evaluate(b, {}, r.canonical).map(Ne => Ne * Ai) } let ve = p ? "center" : n.get("text-justify").evaluate(b, {}, r.canonical); const Te = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(b, {}, r.canonical) * Ai : 1 / 0, je = () => { r.bucket.allowVerticalPlacement && na(D) && (L.vertical = Cu(O, r.glyphMap, r.glyphPositions, r.imagePositions, T, Te, d, _e, "left", Y, W, P.ag.vertical, !0, k, M)) }; if (!p && ke) { const Re = new Set; if (ve === "auto") for (let Ce = 0; Ce < ke.values.length; Ce += 2)Re.add(ld(ke.values[Ce])); else Re.add(ve); let Ne = !1; for (const Ce of Re) if (!L.horizontal[Ce]) if (Ne) L.horizontal[Ce] = L.horizontal[0]; else { const Ye = Cu(O, r.glyphMap, r.glyphPositions, r.imagePositions, T, Te, d, "center", Ce, Y, W, P.ag.horizontal, !1, k, M); Ye && (L.horizontal[Ce] = Ye, Ne = Ye.positionedLines.length === 1) } je() } else { ve === "auto" && (ve = ld(_e)); const Re = Cu(O, r.glyphMap, r.glyphPositions, r.imagePositions, T, Te, d, _e, ve, Y, W, P.ag.horizontal, !1, k, M); Re && (L.horizontal[ve] = Re), je(), na(D) && p && _ && (L.vertical = Cu(O, r.glyphMap, r.glyphPositions, r.imagePositions, T, Te, d, _e, ve, Y, W, P.ag.vertical, !1, k, M)) } } let se = !1; if (b.icon && b.icon.name) { const D = r.imageMap[b.icon.name]; D && (U = Tg(r.imagePositions[b.icon.name], n.get("icon-offset").evaluate(b, {}, r.canonical), n.get("icon-anchor").evaluate(b, {}, r.canonical)), se = !!D.sdf, r.bucket.sdfIcons === void 0 ? r.bucket.sdfIcons = se : r.bucket.sdfIcons !== se && Ui("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (D.pixelRatio !== r.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (r.bucket.iconsNeedLinear = !0)) } const J = Af(L.horizontal) || L.vertical; r.bucket.iconsInText = !!J && J.iconsInText, (J || U) && Vg(r.bucket, b, L, U, r.imageMap, l, k, R, W, se, r.canonical, r.subdivisionGranularity) } r.showCollisionBoxes && r.bucket.generateCollisionDebugBuffers() }, P.cr = Gh, P.cs = jh, P.ct = $h, P.cu = Jl, P.cv = Wh, P.cw = class { constructor(r) { this._marks = { start: [r.url, "start"].join("#"), end: [r.url, "end"].join("#"), measure: r.url.toString() }, performance.mark(this._marks.start) } finish() { performance.mark(this._marks.end); let r = performance.getEntriesByName(this._marks.measure); return r.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), r = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), r } }, P.cx = function (r, t, n, s, l) { return c(this, void 0, void 0, function* () { if (ot()) try { return yield Oe(r, t, n, s, l) } catch { } return function (d, p, _, y, b) { const T = d.width, M = d.height; Xe && We || (Xe = new OffscreenCanvas(T, M), We = Xe.getContext("2d", { willReadFrequently: !0 })), Xe.width = T, Xe.height = M, We.drawImage(d, 0, 0, T, M); const k = We.getImageData(p, _, y, b); return We.clearRect(0, 0, T, M), k.data }(r, t, n, s, l) }) }, P.cy = pf, P.cz = de, P.d = ui, P.e = Si, P.f = r => c(void 0, void 0, void 0, function* () { if (r.byteLength === 0) return createImageBitmap(new ImageData(1, 1)); const t = new Blob([new Uint8Array(r)], { type: "image/png" }); try { return createImageBitmap(t) } catch (n) { throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`) } }), P.g = mt, P.h = r => new Promise((t, n) => { const s = new Image; s.onload = () => { t(s), URL.revokeObjectURL(s.src), s.onload = null, window.requestAnimationFrame(() => { s.src = Be }) }, s.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")); const l = new Blob([new Uint8Array(r)], { type: "image/png" }); s.src = r.byteLength ? URL.createObjectURL(l) : Be }), P.i = le, P.j = (r, t) => mi(Si(r, { type: "json" }), t), P.k = Rr, P.l = Hr, P.m = mi, P.n = (r, t) => mi(Si(r, { type: "arrayBuffer" }), t), P.o = function (r) { return new Wh(r).readFields(hg, []) }, P.p = Up, P.q = $l, P.r = mr, P.s = qe, P.t = so, P.u = wt, P.v = C, P.w = Ui, P.x = ia, P.y = As, P.z = function ([r, t, n]) { return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, { x: r * Math.cos(t) * Math.sin(n), y: r * Math.sin(t) * Math.sin(n), z: r * Math.cos(n) } }
      }), F("worker", ["./shared"], function (P) { class c { constructor(C) { this.keyCache = {}, C && this.replace(C) } replace(C) { this._layerConfigs = {}, this._layers = {}, this.update(C, []) } update(C, V) { for (const X of C) { this._layerConfigs[X.id] = X; const ie = this._layers[X.id] = P.bx(X); ie._featureFilter = P.a6(ie.filter), this.keyCache[X.id] && delete this.keyCache[X.id] } for (const X of V) delete this.keyCache[X], delete this._layerConfigs[X], delete this._layers[X]; this.familiesBySource = {}; const $ = P.cl(Object.values(this._layerConfigs), this.keyCache); for (const X of $) { const ie = X.map(pe => this._layers[pe.id]), he = ie[0]; if (he.visibility === "none") continue; const ye = he.source || ""; let ce = this.familiesBySource[ye]; ce || (ce = this.familiesBySource[ye] = {}); const Me = he.sourceLayer || "_geojsonTileLayer"; let be = ce[Me]; be || (be = ce[Me] = []), be.push(ie) } } } class de { constructor(C) { const V = {}, $ = []; for (const ye in C) { const ce = C[ye], Me = V[ye] = {}; for (const be in ce) { const pe = ce[+be]; if (!pe || pe.bitmap.width === 0 || pe.bitmap.height === 0) continue; const Ae = { x: 0, y: 0, w: pe.bitmap.width + 2, h: pe.bitmap.height + 2 }; $.push(Ae), Me[be] = { rect: Ae, metrics: pe.metrics } } } const { w: X, h: ie } = P.p($), he = new P.q({ width: X || 1, height: ie || 1 }); for (const ye in C) { const ce = C[ye]; for (const Me in ce) { const be = ce[+Me]; if (!be || be.bitmap.width === 0 || be.bitmap.height === 0) continue; const pe = V[ye][Me].rect; P.q.copy(be.bitmap, he, { x: 0, y: 0 }, { x: pe.x + 1, y: pe.y + 1 }, be.bitmap) } } this.image = he, this.positions = V } } P.cm("GlyphAtlas", de); class ze { constructor(C) { this.tileID = new P.Y(C.tileID.overscaledZ, C.tileID.wrap, C.tileID.canonical.z, C.tileID.canonical.x, C.tileID.canonical.y), this.uid = C.uid, this.zoom = C.zoom, this.pixelRatio = C.pixelRatio, this.tileSize = C.tileSize, this.source = C.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = C.showCollisionBoxes, this.collectResourceTiming = !!C.collectResourceTiming, this.returnDependencies = !!C.returnDependencies, this.promoteId = C.promoteId, this.inFlightDependencies = [] } parse(C, V, $, X, ie) { return P._(this, void 0, void 0, function* () { this.status = "parsing", this.data = C, this.collisionBoxArray = new P.a4; const he = new P.cn(Object.keys(C.layers).sort()), ye = new P.co(this.tileID, this.promoteId); ye.bucketLayerIDs = []; const ce = {}, Me = { featureIndex: ye, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: $, subdivisionGranularity: ie }, be = V.familiesBySource[this.source]; for (const ft in be) { const bt = C.layers[ft]; if (!bt) continue; bt.version === 1 && P.w(`Vector tile source "${this.source}" layer "${ft}" does not use vector tile spec v2 and therefore may have some rendering errors.`); const at = he.encode(ft), Zn = []; for (let wi = 0; wi < bt.length; wi++) { const Mi = bt.feature(wi), Qt = ye.getId(Mi, ft); Zn.push({ feature: Mi, id: Qt, index: wi, sourceLayerIndex: at }) } for (const wi of be[ft]) { const Mi = wi[0]; Mi.source !== this.source && P.w(`layer.source = ${Mi.source} does not equal this.source = ${this.source}`), Mi.minzoom && this.zoom < Math.floor(Mi.minzoom) || Mi.maxzoom && this.zoom >= Mi.maxzoom || Mi.visibility !== "none" && (xe(wi, this.zoom, $), (ce[Mi.id] = Mi.createBucket({ index: ye.bucketLayerIDs.length, layers: wi, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: at, sourceID: this.source })).populate(Zn, Me, this.tileID.canonical), ye.bucketLayerIDs.push(wi.map(Qt => Qt.id))) } } const pe = P.bC(Me.glyphDependencies, ft => Object.keys(ft).map(Number)); this.inFlightDependencies.forEach(ft => ft == null ? void 0 : ft.abort()), this.inFlightDependencies = []; let Ae = Promise.resolve({}); if (Object.keys(pe).length) { const ft = new AbortController; this.inFlightDependencies.push(ft), Ae = X.sendAsync({ type: "GG", data: { stacks: pe, source: this.source, tileID: this.tileID, type: "glyphs" } }, ft) } const fe = Object.keys(Me.iconDependencies); let He = Promise.resolve({}); if (fe.length) { const ft = new AbortController; this.inFlightDependencies.push(ft), He = X.sendAsync({ type: "GI", data: { icons: fe, source: this.source, tileID: this.tileID, type: "icons" } }, ft) } const rt = Object.keys(Me.patternDependencies); let _t = Promise.resolve({}); if (rt.length) { const ft = new AbortController; this.inFlightDependencies.push(ft), _t = X.sendAsync({ type: "GI", data: { icons: rt, source: this.source, tileID: this.tileID, type: "patterns" } }, ft) } const [pt, Ee, et] = yield Promise.all([Ae, He, _t]), Qe = new de(pt), xt = new P.cp(Ee, et); for (const ft in ce) { const bt = ce[ft]; bt instanceof P.a5 ? (xe(bt.layers, this.zoom, $), P.cq({ bucket: bt, glyphMap: pt, glyphPositions: Qe.positions, imageMap: Ee, imagePositions: xt.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: Me.subdivisionGranularity })) : bt.hasPattern && (bt instanceof P.cr || bt instanceof P.cs || bt instanceof P.ct) && (xe(bt.layers, this.zoom, $), bt.addFeatures(Me, this.tileID.canonical, xt.patternPositions)) } return this.status = "done", { buckets: Object.values(ce).filter(ft => !ft.isEmpty()), featureIndex: ye, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Qe.image, imageAtlas: xt, glyphMap: this.returnDependencies ? pt : null, iconMap: this.returnDependencies ? Ee : null, glyphPositions: this.returnDependencies ? Qe.positions : null } }) } } function xe(ue, C, V) { const $ = new P.C(C); for (const X of ue) X.recalculate($, V) } class Fe { constructor(C, V, $) { this.actor = C, this.layerIndex = V, this.availableImages = $, this.fetching = {}, this.loading = {}, this.loaded = {} } loadVectorTile(C, V) { return P._(this, void 0, void 0, function* () { const $ = yield P.n(C.request, V); try { return { vectorTile: new P.cu.VectorTile(new P.cv($.data)), rawData: $.data, cacheControl: $.cacheControl, expires: $.expires } } catch (X) { const ie = new Uint8Array($.data); let he = `Unable to parse the tile at ${C.request.url}, `; throw he += ie[0] === 31 && ie[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${X.message}`, new Error(he) } }) } loadTile(C) { return P._(this, void 0, void 0, function* () { const V = C.uid, $ = !!(C && C.request && C.request.collectResourceTiming) && new P.cw(C.request), X = new ze(C); this.loading[V] = X; const ie = new AbortController; X.abort = ie; try { const he = yield this.loadVectorTile(C, ie); if (delete this.loading[V], !he) return null; const ye = he.rawData, ce = {}; he.expires && (ce.expires = he.expires), he.cacheControl && (ce.cacheControl = he.cacheControl); const Me = {}; if ($) { const pe = $.finish(); pe && (Me.resourceTiming = JSON.parse(JSON.stringify(pe))) } X.vectorTile = he.vectorTile; const be = X.parse(he.vectorTile, this.layerIndex, this.availableImages, this.actor, C.subdivisionGranularity); this.loaded[V] = X, this.fetching[V] = { rawTileData: ye, cacheControl: ce, resourceTiming: Me }; try { const pe = yield be; return P.e({ rawTileData: ye.slice(0) }, pe, ce, Me) } finally { delete this.fetching[V] } } catch (he) { throw delete this.loading[V], X.status = "done", this.loaded[V] = X, he } }) } reloadTile(C) { return P._(this, void 0, void 0, function* () { const V = C.uid; if (!this.loaded || !this.loaded[V]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed"); const $ = this.loaded[V]; if ($.showCollisionBoxes = C.showCollisionBoxes, $.status === "parsing") { const X = yield $.parse($.vectorTile, this.layerIndex, this.availableImages, this.actor, C.subdivisionGranularity); let ie; if (this.fetching[V]) { const { rawTileData: he, cacheControl: ye, resourceTiming: ce } = this.fetching[V]; delete this.fetching[V], ie = P.e({ rawTileData: he.slice(0) }, X, ye, ce) } else ie = X; return ie } if ($.status === "done" && $.vectorTile) return $.parse($.vectorTile, this.layerIndex, this.availableImages, this.actor, C.subdivisionGranularity) }) } abortTile(C) { return P._(this, void 0, void 0, function* () { const V = this.loading, $ = C.uid; V && V[$] && V[$].abort && (V[$].abort.abort(), delete V[$]) }) } removeTile(C) { return P._(this, void 0, void 0, function* () { this.loaded && this.loaded[C.uid] && delete this.loaded[C.uid] }) } } class Le { constructor() { this.loaded = {} } loadTile(C) { return P._(this, void 0, void 0, function* () { const { uid: V, encoding: $, rawImageData: X, redFactor: ie, greenFactor: he, blueFactor: ye, baseShift: ce } = C, Me = X.width + 2, be = X.height + 2, pe = P.b(X) ? new P.R({ width: Me, height: be }, yield P.cx(X, -1, -1, Me, be)) : X, Ae = new P.cy(V, pe, $, ie, he, ye, ce); return this.loaded = this.loaded || {}, this.loaded[V] = Ae, Ae }) } removeTile(C) { const V = this.loaded, $ = C.uid; V && V[$] && delete V[$] } } var ae, Ge, Tt = function () { if (Ge) return ae; function ue(V, $) { if (V.length !== 0) { C(V[0], $); for (var X = 1; X < V.length; X++)C(V[X], !$) } } function C(V, $) { for (var X = 0, ie = 0, he = 0, ye = V.length, ce = ye - 1; he < ye; ce = he++) { var Me = (V[he][0] - V[ce][0]) * (V[ce][1] + V[he][1]), be = X + Me; ie += Math.abs(X) >= Math.abs(Me) ? X - be + Me : Me - be + X, X = be } X + ie >= 0 != !!$ && V.reverse() } return Ge = 1, ae = function V($, X) { var ie, he = $ && $.type; if (he === "FeatureCollection") for (ie = 0; ie < $.features.length; ie++)V($.features[ie], X); else if (he === "GeometryCollection") for (ie = 0; ie < $.geometries.length; ie++)V($.geometries[ie], X); else if (he === "Feature") V($.geometry, X); else if (he === "Polygon") ue($.coordinates, X); else if (he === "MultiPolygon") for (ie = 0; ie < $.coordinates.length; ie++)ue($.coordinates[ie], X); return $ } }(), ri = P.cz(Tt); const kt = P.cu.VectorTileFeature.prototype.toGeoJSON; class Zt { constructor(C) { this._feature = C, this.extent = P.Z, this.type = C.type, this.properties = C.tags, "id" in C && !isNaN(C.id) && (this.id = parseInt(C.id, 10)) } loadGeometry() { if (this._feature.type === 1) { const C = []; for (const V of this._feature.geometry) C.push([new P.P(V[0], V[1])]); return C } { const C = []; for (const V of this._feature.geometry) { const $ = []; for (const X of V) $.push(new P.P(X[0], X[1])); C.push($) } return C } } toGeoJSON(C, V, $) { return kt.call(this, C, V, $) } } class qt { constructor(C) { this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = P.Z, this.length = C.length, this._features = C } feature(C) { return new Zt(this._features[C]) } } var ot, Ht, Vt, Et = { exports: {} }, Nt = function () { if (Vt) return Et.exports; Vt = 1; var ue = P.cC(), C = function () { if (Ht) return ot; Ht = 1; var be = P.cA(), pe = P.cB().VectorTileFeature; function Ae(He, rt) { this.options = rt || {}, this.features = He, this.length = He.length } function fe(He, rt) { this.id = typeof He.id == "number" ? He.id : void 0, this.type = He.type, this.rawGeometry = He.type === 1 ? [He.geometry] : He.geometry, this.properties = He.tags, this.extent = rt || 4096 } return ot = Ae, Ae.prototype.feature = function (He) { return new fe(this.features[He], this.options.extent) }, fe.prototype.loadGeometry = function () { var He = this.rawGeometry; this.geometry = []; for (var rt = 0; rt < He.length; rt++) { for (var _t = He[rt], pt = [], Ee = 0; Ee < _t.length; Ee++)pt.push(new be(_t[Ee][0], _t[Ee][1])); this.geometry.push(pt) } return this.geometry }, fe.prototype.bbox = function () { this.geometry || this.loadGeometry(); for (var He = this.geometry, rt = 1 / 0, _t = -1 / 0, pt = 1 / 0, Ee = -1 / 0, et = 0; et < He.length; et++)for (var Qe = He[et], xt = 0; xt < Qe.length; xt++) { var ft = Qe[xt]; rt = Math.min(rt, ft.x), _t = Math.max(_t, ft.x), pt = Math.min(pt, ft.y), Ee = Math.max(Ee, ft.y) } return [rt, pt, _t, Ee] }, fe.prototype.toGeoJSON = pe.prototype.toGeoJSON, ot }(); function V(be) { var pe = new ue; return function (Ae, fe) { for (var He in Ae.layers) fe.writeMessage(3, $, Ae.layers[He]) }(be, pe), pe.finish() } function $(be, pe) { var Ae; pe.writeVarintField(15, be.version || 1), pe.writeStringField(1, be.name || ""), pe.writeVarintField(5, be.extent || 4096); var fe = { keys: [], values: [], keycache: {}, valuecache: {} }; for (Ae = 0; Ae < be.length; Ae++)fe.feature = be.feature(Ae), pe.writeMessage(2, X, fe); var He = fe.keys; for (Ae = 0; Ae < He.length; Ae++)pe.writeStringField(3, He[Ae]); var rt = fe.values; for (Ae = 0; Ae < rt.length; Ae++)pe.writeMessage(4, Me, rt[Ae]) } function X(be, pe) { var Ae = be.feature; Ae.id !== void 0 && pe.writeVarintField(1, Ae.id), pe.writeMessage(2, ie, be), pe.writeVarintField(3, Ae.type), pe.writeMessage(4, ce, Ae) } function ie(be, pe) { var Ae = be.feature, fe = be.keys, He = be.values, rt = be.keycache, _t = be.valuecache; for (var pt in Ae.properties) { var Ee = Ae.properties[pt], et = rt[pt]; if (Ee !== null) { et === void 0 && (fe.push(pt), rt[pt] = et = fe.length - 1), pe.writeVarint(et); var Qe = typeof Ee; Qe !== "string" && Qe !== "boolean" && Qe !== "number" && (Ee = JSON.stringify(Ee)); var xt = Qe + ":" + Ee, ft = _t[xt]; ft === void 0 && (He.push(Ee), _t[xt] = ft = He.length - 1), pe.writeVarint(ft) } } } function he(be, pe) { return (pe << 3) + (7 & be) } function ye(be) { return be << 1 ^ be >> 31 } function ce(be, pe) { for (var Ae = be.loadGeometry(), fe = be.type, He = 0, rt = 0, _t = Ae.length, pt = 0; pt < _t; pt++) { var Ee = Ae[pt], et = 1; fe === 1 && (et = Ee.length), pe.writeVarint(he(1, et)); for (var Qe = fe === 3 ? Ee.length - 1 : Ee.length, xt = 0; xt < Qe; xt++) { xt === 1 && fe !== 1 && pe.writeVarint(he(2, Qe - 1)); var ft = Ee[xt].x - He, bt = Ee[xt].y - rt; pe.writeVarint(ye(ft)), pe.writeVarint(ye(bt)), He += ft, rt += bt } fe === 3 && pe.writeVarint(he(7, 1)) } } function Me(be, pe) { var Ae = typeof be; Ae === "string" ? pe.writeStringField(1, be) : Ae === "boolean" ? pe.writeBooleanField(7, be) : Ae === "number" && (be % 1 != 0 ? pe.writeDoubleField(3, be) : be < 0 ? pe.writeSVarintField(6, be) : pe.writeVarintField(5, be)) } return Et.exports = V, Et.exports.fromVectorTileJs = V, Et.exports.fromGeojsonVt = function (be, pe) { pe = pe || {}; var Ae = {}; for (var fe in be) Ae[fe] = new C(be[fe].features, pe), Ae[fe].name = fe, Ae[fe].version = pe.version, Ae[fe].extent = pe.extent; return V({ layers: Ae }) }, Et.exports.GeoJSONWrapper = C, Et.exports }(), ln = P.cz(Nt); const zr = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: ue => ue }, or = Math.fround || (ar = new Float32Array(1), ue => (ar[0] = +ue, ar[0])); var ar; const Zi = 3, bi = 5, Pn = 6; class gt { constructor(C) { this.options = Object.assign(Object.create(zr), C), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [] } load(C) { const { log: V, minZoom: $, maxZoom: X } = this.options; V && console.time("total time"); const ie = `prepare ${C.length} points`; V && console.time(ie), this.points = C; const he = []; for (let ce = 0; ce < C.length; ce++) { const Me = C[ce]; if (!Me.geometry) continue; const [be, pe] = Me.geometry.coordinates, Ae = or(rr(be)), fe = or(kr(pe)); he.push(Ae, fe, 1 / 0, ce, -1, 1), this.options.reduce && he.push(0) } let ye = this.trees[X + 1] = this._createTree(he); V && console.timeEnd(ie); for (let ce = X; ce >= $; ce--) { const Me = +Date.now(); ye = this.trees[ce] = this._createTree(this._cluster(ye, ce)), V && console.log("z%d: %d clusters in %dms", ce, ye.numItems, +Date.now() - Me) } return V && console.timeEnd("total time"), this } getClusters(C, V) { let $ = ((C[0] + 180) % 360 + 360) % 360 - 180; const X = Math.max(-90, Math.min(90, C[1])); let ie = C[2] === 180 ? 180 : ((C[2] + 180) % 360 + 360) % 360 - 180; const he = Math.max(-90, Math.min(90, C[3])); if (C[2] - C[0] >= 360) $ = -180, ie = 180; else if ($ > ie) { const pe = this.getClusters([$, X, 180, he], V), Ae = this.getClusters([-180, X, ie, he], V); return pe.concat(Ae) } const ye = this.trees[this._limitZoom(V)], ce = ye.range(rr($), kr(he), rr(ie), kr(X)), Me = ye.data, be = []; for (const pe of ce) { const Ae = this.stride * pe; be.push(Me[Ae + bi] > 1 ? Ut(Me, Ae, this.clusterProps) : this.points[Me[Ae + Zi]]) } return be } getChildren(C) { const V = this._getOriginId(C), $ = this._getOriginZoom(C), X = "No cluster with the specified id.", ie = this.trees[$]; if (!ie) throw new Error(X); const he = ie.data; if (V * this.stride >= he.length) throw new Error(X); const ye = this.options.radius / (this.options.extent * Math.pow(2, $ - 1)), ce = ie.within(he[V * this.stride], he[V * this.stride + 1], ye), Me = []; for (const be of ce) { const pe = be * this.stride; he[pe + 4] === C && Me.push(he[pe + bi] > 1 ? Ut(he, pe, this.clusterProps) : this.points[he[pe + Zi]]) } if (Me.length === 0) throw new Error(X); return Me } getLeaves(C, V, $) { const X = []; return this._appendLeaves(X, C, V = V || 10, $ = $ || 0, 0), X } getTile(C, V, $) { const X = this.trees[this._limitZoom(C)], ie = Math.pow(2, C), { extent: he, radius: ye } = this.options, ce = ye / he, Me = ($ - ce) / ie, be = ($ + 1 + ce) / ie, pe = { features: [] }; return this._addTileFeatures(X.range((V - ce) / ie, Me, (V + 1 + ce) / ie, be), X.data, V, $, ie, pe), V === 0 && this._addTileFeatures(X.range(1 - ce / ie, Me, 1, be), X.data, ie, $, ie, pe), V === ie - 1 && this._addTileFeatures(X.range(0, Me, ce / ie, be), X.data, -1, $, ie, pe), pe.features.length ? pe : null } getClusterExpansionZoom(C) { let V = this._getOriginZoom(C) - 1; for (; V <= this.options.maxZoom;) { const $ = this.getChildren(C); if (V++, $.length !== 1) break; C = $[0].properties.cluster_id } return V } _appendLeaves(C, V, $, X, ie) { const he = this.getChildren(V); for (const ye of he) { const ce = ye.properties; if (ce && ce.cluster ? ie + ce.point_count <= X ? ie += ce.point_count : ie = this._appendLeaves(C, ce.cluster_id, $, X, ie) : ie < X ? ie++ : C.push(ye), C.length === $) break } return ie } _createTree(C) { const V = new P.aB(C.length / this.stride | 0, this.options.nodeSize, Float32Array); for (let $ = 0; $ < C.length; $ += this.stride)V.add(C[$], C[$ + 1]); return V.finish(), V.data = C, V } _addTileFeatures(C, V, $, X, ie, he) { for (const ye of C) { const ce = ye * this.stride, Me = V[ce + bi] > 1; let be, pe, Ae; if (Me) be = Dt(V, ce, this.clusterProps), pe = V[ce], Ae = V[ce + 1]; else { const rt = this.points[V[ce + Zi]]; be = rt.properties; const [_t, pt] = rt.geometry.coordinates; pe = rr(_t), Ae = kr(pt) } const fe = { type: 1, geometry: [[Math.round(this.options.extent * (pe * ie - $)), Math.round(this.options.extent * (Ae * ie - X))]], tags: be }; let He; He = Me || this.options.generateId ? V[ce + Zi] : this.points[V[ce + Zi]].id, He !== void 0 && (fe.id = He), he.features.push(fe) } } _limitZoom(C) { return Math.max(this.options.minZoom, Math.min(Math.floor(+C), this.options.maxZoom + 1)) } _cluster(C, V) { const { radius: $, extent: X, reduce: ie, minPoints: he } = this.options, ye = $ / (X * Math.pow(2, V)), ce = C.data, Me = [], be = this.stride; for (let pe = 0; pe < ce.length; pe += be) { if (ce[pe + 2] <= V) continue; ce[pe + 2] = V; const Ae = ce[pe], fe = ce[pe + 1], He = C.within(ce[pe], ce[pe + 1], ye), rt = ce[pe + bi]; let _t = rt; for (const pt of He) { const Ee = pt * be; ce[Ee + 2] > V && (_t += ce[Ee + bi]) } if (_t > rt && _t >= he) { let pt, Ee = Ae * rt, et = fe * rt, Qe = -1; const xt = ((pe / be | 0) << 5) + (V + 1) + this.points.length; for (const ft of He) { const bt = ft * be; if (ce[bt + 2] <= V) continue; ce[bt + 2] = V; const at = ce[bt + bi]; Ee += ce[bt] * at, et += ce[bt + 1] * at, ce[bt + 4] = xt, ie && (pt || (pt = this._map(ce, pe, !0), Qe = this.clusterProps.length, this.clusterProps.push(pt)), ie(pt, this._map(ce, bt))) } ce[pe + 4] = xt, Me.push(Ee / _t, et / _t, 1 / 0, xt, -1, _t), ie && Me.push(Qe) } else { for (let pt = 0; pt < be; pt++)Me.push(ce[pe + pt]); if (_t > 1) for (const pt of He) { const Ee = pt * be; if (!(ce[Ee + 2] <= V)) { ce[Ee + 2] = V; for (let et = 0; et < be; et++)Me.push(ce[Ee + et]) } } } } return Me } _getOriginId(C) { return C - this.points.length >> 5 } _getOriginZoom(C) { return (C - this.points.length) % 32 } _map(C, V, $) { if (C[V + bi] > 1) { const he = this.clusterProps[C[V + Pn]]; return $ ? Object.assign({}, he) : he } const X = this.points[C[V + Zi]].properties, ie = this.options.map(X); return $ && ie === X ? Object.assign({}, ie) : ie } } function Ut(ue, C, V) { return { type: "Feature", id: ue[C + Zi], properties: Dt(ue, C, V), geometry: { type: "Point", coordinates: [($ = ue[C], 360 * ($ - .5)), lr(ue[C + 1])] } }; var $ } function Dt(ue, C, V) { const $ = ue[C + bi], X = $ >= 1e4 ? `${Math.round($ / 1e3)}k` : $ >= 1e3 ? Math.round($ / 100) / 10 + "k" : $, ie = ue[C + Pn], he = ie === -1 ? {} : Object.assign({}, V[ie]); return Object.assign(he, { cluster: !0, cluster_id: ue[C + Zi], point_count: $, point_count_abbreviated: X }) } function rr(ue) { return ue / 360 + .5 } function kr(ue) { const C = Math.sin(ue * Math.PI / 180), V = .5 - .25 * Math.log((1 + C) / (1 - C)) / Math.PI; return V < 0 ? 0 : V > 1 ? 1 : V } function lr(ue) { const C = (180 - 360 * ue) * Math.PI / 180; return 360 * Math.atan(Math.exp(C)) / Math.PI - 90 } function gi(ue, C, V, $) { let X = $; const ie = C + (V - C >> 1); let he, ye = V - C; const ce = ue[C], Me = ue[C + 1], be = ue[V], pe = ue[V + 1]; for (let Ae = C + 3; Ae < V; Ae += 3) { const fe = cr(ue[Ae], ue[Ae + 1], ce, Me, be, pe); if (fe > X) he = Ae, X = fe; else if (fe === X) { const He = Math.abs(Ae - ie); He < ye && (he = Ae, ye = He) } } X > $ && (he - C > 3 && gi(ue, C, he, $), ue[he + 2] = X, V - he > 3 && gi(ue, he, V, $)) } function cr(ue, C, V, $, X, ie) { let he = X - V, ye = ie - $; if (he !== 0 || ye !== 0) { const ce = ((ue - V) * he + (C - $) * ye) / (he * he + ye * ye); ce > 1 ? (V = X, $ = ie) : ce > 0 && (V += he * ce, $ += ye * ce) } return he = ue - V, ye = C - $, he * he + ye * ye } function ur(ue, C, V, $) { const X = { id: ue ?? null, type: C, geometry: V, tags: $, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }; if (C === "Point" || C === "MultiPoint" || C === "LineString") Si(X, V); else if (C === "Polygon") Si(X, V[0]); else if (C === "MultiLineString") for (const ie of V) Si(X, ie); else if (C === "MultiPolygon") for (const ie of V) Si(X, ie[0]); return X } function Si(ue, C) { for (let V = 0; V < C.length; V += 3)ue.minX = Math.min(ue.minX, C[V]), ue.minY = Math.min(ue.minY, C[V + 1]), ue.maxX = Math.max(ue.maxX, C[V]), ue.maxY = Math.max(ue.maxY, C[V + 1]) } function xr(ue, C, V, $) { if (!C.geometry) return; const X = C.geometry.coordinates; if (X && X.length === 0) return; const ie = C.geometry.type, he = Math.pow(V.tolerance / ((1 << V.maxZoom) * V.extent), 2); let ye = [], ce = C.id; if (V.promoteId ? ce = C.properties[V.promoteId] : V.generateId && (ce = $ || 0), ie === "Point") Dr(X, ye); else if (ie === "MultiPoint") for (const Me of X) Dr(Me, ye); else if (ie === "LineString") Gr(X, ye, he, !1); else if (ie === "MultiLineString") { if (V.lineMetrics) { for (const Me of X) ye = [], Gr(Me, ye, he, !1), ue.push(ur(ce, "LineString", ye, C.properties)); return } Ki(X, ye, he, !1) } else if (ie === "Polygon") Ki(X, ye, he, !0); else { if (ie !== "MultiPolygon") { if (ie === "GeometryCollection") { for (const Me of C.geometry.geometries) xr(ue, { id: ce, geometry: Me, properties: C.properties }, V, $); return } throw new Error("Input data is not a valid GeoJSON object.") } for (const Me of X) { const be = []; Ki(Me, be, he, !0), ye.push(be) } } ue.push(ur(ce, ie, ye, C.properties)) } function Dr(ue, C) { C.push(qr(ue[0]), Ui(ue[1]), 0) } function Gr(ue, C, V, $) { let X, ie, he = 0; for (let ce = 0; ce < ue.length; ce++) { const Me = qr(ue[ce][0]), be = Ui(ue[ce][1]); C.push(Me, be, 0), ce > 0 && (he += $ ? (X * be - Me * ie) / 2 : Math.sqrt(Math.pow(Me - X, 2) + Math.pow(be - ie, 2))), X = Me, ie = be } const ye = C.length - 3; C[2] = 1, gi(C, 0, ye, V), C[ye + 2] = 1, C.size = Math.abs(he), C.start = 0, C.end = C.size } function Ki(ue, C, V, $) { for (let X = 0; X < ue.length; X++) { const ie = []; Gr(ue[X], ie, V, $), C.push(ie) } } function qr(ue) { return ue / 360 + .5 } function Ui(ue) { const C = Math.sin(ue * Math.PI / 180), V = .5 - .25 * Math.log((1 + C) / (1 - C)) / Math.PI; return V < 0 ? 0 : V > 1 ? 1 : V } function te(ue, C, V, $, X, ie, he, ye) { if ($ /= C, ie >= (V /= C) && he < $) return ue; if (he < V || ie >= $) return null; const ce = []; for (const Me of ue) { const be = Me.geometry; let pe = Me.type; const Ae = X === 0 ? Me.minX : Me.minY, fe = X === 0 ? Me.maxX : Me.maxY; if (Ae >= V && fe < $) { ce.push(Me); continue } if (fe < V || Ae >= $) continue; let He = []; if (pe === "Point" || pe === "MultiPoint") le(be, He, V, $, X); else if (pe === "LineString") we(be, He, V, $, X, !1, ye.lineMetrics); else if (pe === "MultiLineString") Be(be, He, V, $, X, !1); else if (pe === "Polygon") Be(be, He, V, $, X, !0); else if (pe === "MultiPolygon") for (const rt of be) { const _t = []; Be(rt, _t, V, $, X, !0), _t.length && He.push(_t) } if (He.length) { if (ye.lineMetrics && pe === "LineString") { for (const rt of He) ce.push(ur(Me.id, pe, rt, Me.tags)); continue } pe !== "LineString" && pe !== "MultiLineString" || (He.length === 1 ? (pe = "LineString", He = He[0]) : pe = "MultiLineString"), pe !== "Point" && pe !== "MultiPoint" || (pe = He.length === 3 ? "Point" : "MultiPoint"), ce.push(ur(Me.id, pe, He, Me.tags)) } } return ce.length ? ce : null } function le(ue, C, V, $, X) { for (let ie = 0; ie < ue.length; ie += 3) { const he = ue[ie + X]; he >= V && he <= $ && Oe(C, ue[ie], ue[ie + 1], ue[ie + 2]) } } function we(ue, C, V, $, X, ie, he) { let ye = Ze(ue); const ce = X === 0 ? Xe : We; let Me, be, pe = ue.start; for (let _t = 0; _t < ue.length - 3; _t += 3) { const pt = ue[_t], Ee = ue[_t + 1], et = ue[_t + 2], Qe = ue[_t + 3], xt = ue[_t + 4], ft = X === 0 ? pt : Ee, bt = X === 0 ? Qe : xt; let at = !1; he && (Me = Math.sqrt(Math.pow(pt - Qe, 2) + Math.pow(Ee - xt, 2))), ft < V ? bt > V && (be = ce(ye, pt, Ee, Qe, xt, V), he && (ye.start = pe + Me * be)) : ft > $ ? bt < $ && (be = ce(ye, pt, Ee, Qe, xt, $), he && (ye.start = pe + Me * be)) : Oe(ye, pt, Ee, et), bt < V && ft >= V && (be = ce(ye, pt, Ee, Qe, xt, V), at = !0), bt > $ && ft <= $ && (be = ce(ye, pt, Ee, Qe, xt, $), at = !0), !ie && at && (he && (ye.end = pe + Me * be), C.push(ye), ye = Ze(ue)), he && (pe += Me) } let Ae = ue.length - 3; const fe = ue[Ae], He = ue[Ae + 1], rt = X === 0 ? fe : He; rt >= V && rt <= $ && Oe(ye, fe, He, ue[Ae + 2]), Ae = ye.length - 3, ie && Ae >= 3 && (ye[Ae] !== ye[0] || ye[Ae + 1] !== ye[1]) && Oe(ye, ye[0], ye[1], ye[2]), ye.length && C.push(ye) } function Ze(ue) { const C = []; return C.size = ue.size, C.start = ue.start, C.end = ue.end, C } function Be(ue, C, V, $, X, ie) { for (const he of ue) we(he, C, V, $, X, ie, !1) } function Oe(ue, C, V, $) { ue.push(C, V, $) } function Xe(ue, C, V, $, X, ie) { const he = (ie - C) / ($ - C); return Oe(ue, ie, V + (X - V) * he, 1), he } function We(ue, C, V, $, X, ie) { const he = (ie - V) / (X - V); return Oe(ue, C + ($ - C) * he, ie, 1), he } function qe(ue, C) { const V = []; for (let $ = 0; $ < ue.length; $++) { const X = ue[$], ie = X.type; let he; if (ie === "Point" || ie === "MultiPoint" || ie === "LineString") he = Ve(X.geometry, C); else if (ie === "MultiLineString" || ie === "Polygon") { he = []; for (const ye of X.geometry) he.push(Ve(ye, C)) } else if (ie === "MultiPolygon") { he = []; for (const ye of X.geometry) { const ce = []; for (const Me of ye) ce.push(Ve(Me, C)); he.push(ce) } } V.push(ur(X.id, ie, he, X.tags)) } return V } function Ve(ue, C) { const V = []; V.size = ue.size, ue.start !== void 0 && (V.start = ue.start, V.end = ue.end); for (let $ = 0; $ < ue.length; $ += 3)V.push(ue[$] + C, ue[$ + 1], ue[$ + 2]); return V } function dt(ue, C) { if (ue.transformed) return ue; const V = 1 << ue.z, $ = ue.x, X = ue.y; for (const ie of ue.features) { const he = ie.geometry, ye = ie.type; if (ie.geometry = [], ye === 1) for (let ce = 0; ce < he.length; ce += 2)ie.geometry.push(Ke(he[ce], he[ce + 1], C, V, $, X)); else for (let ce = 0; ce < he.length; ce++) { const Me = []; for (let be = 0; be < he[ce].length; be += 2)Me.push(Ke(he[ce][be], he[ce][be + 1], C, V, $, X)); ie.geometry.push(Me) } } return ue.transformed = !0, ue } function Ke(ue, C, V, $, X, ie) { return [Math.round(V * (ue * $ - X)), Math.round(V * (C * $ - ie))] } function ct(ue, C, V, $, X) { const ie = C === X.maxZoom ? 0 : X.tolerance / ((1 << C) * X.extent), he = { features: [], numPoints: 0, numSimplified: 0, numFeatures: ue.length, source: null, x: V, y: $, z: C, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }; for (const ye of ue) mt(he, ye, ie, X); return he } function mt(ue, C, V, $) { const X = C.geometry, ie = C.type, he = []; if (ue.minX = Math.min(ue.minX, C.minX), ue.minY = Math.min(ue.minY, C.minY), ue.maxX = Math.max(ue.maxX, C.maxX), ue.maxY = Math.max(ue.maxY, C.maxY), ie === "Point" || ie === "MultiPoint") for (let ye = 0; ye < X.length; ye += 3)he.push(X[ye], X[ye + 1]), ue.numPoints++, ue.numSimplified++; else if (ie === "LineString") vt(he, X, ue, V, !1, !1); else if (ie === "MultiLineString" || ie === "Polygon") for (let ye = 0; ye < X.length; ye++)vt(he, X[ye], ue, V, ie === "Polygon", ye === 0); else if (ie === "MultiPolygon") for (let ye = 0; ye < X.length; ye++) { const ce = X[ye]; for (let Me = 0; Me < ce.length; Me++)vt(he, ce[Me], ue, V, !0, Me === 0) } if (he.length) { let ye = C.tags || null; if (ie === "LineString" && $.lineMetrics) { ye = {}; for (const Me in C.tags) ye[Me] = C.tags[Me]; ye.mapbox_clip_start = X.start / X.size, ye.mapbox_clip_end = X.end / X.size } const ce = { geometry: he, type: ie === "Polygon" || ie === "MultiPolygon" ? 3 : ie === "LineString" || ie === "MultiLineString" ? 2 : 1, tags: ye }; C.id !== null && (ce.id = C.id), ue.features.push(ce) } } function vt(ue, C, V, $, X, ie) { const he = $ * $; if ($ > 0 && C.size < (X ? he : $)) return void (V.numPoints += C.length / 3); const ye = []; for (let ce = 0; ce < C.length; ce += 3)($ === 0 || C[ce + 2] > he) && (V.numSimplified++, ye.push(C[ce], C[ce + 1])), V.numPoints++; X && function (ce, Me) { let be = 0; for (let pe = 0, Ae = ce.length, fe = Ae - 2; pe < Ae; fe = pe, pe += 2)be += (ce[pe] - ce[fe]) * (ce[pe + 1] + ce[fe + 1]); if (be > 0 === Me) for (let pe = 0, Ae = ce.length; pe < Ae / 2; pe += 2) { const fe = ce[pe], He = ce[pe + 1]; ce[pe] = ce[Ae - 2 - pe], ce[pe + 1] = ce[Ae - 1 - pe], ce[Ae - 2 - pe] = fe, ce[Ae - 1 - pe] = He } }(ye, ie), ue.push(ye) } const At = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }; class Pt { constructor(C, V) { const $ = (V = this.options = function (ie, he) { for (const ye in he) ie[ye] = he[ye]; return ie }(Object.create(At), V)).debug; if ($ && console.time("preprocess data"), V.maxZoom < 0 || V.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range"); if (V.promoteId && V.generateId) throw new Error("promoteId and generateId cannot be used together."); let X = function (ie, he) { const ye = []; if (ie.type === "FeatureCollection") for (let ce = 0; ce < ie.features.length; ce++)xr(ye, ie.features[ce], he, ce); else xr(ye, ie.type === "Feature" ? ie : { geometry: ie }, he); return ye }(C, V); this.tiles = {}, this.tileCoords = [], $ && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", V.indexMaxZoom, V.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), X = function (ie, he) { const ye = he.buffer / he.extent; let ce = ie; const Me = te(ie, 1, -1 - ye, ye, 0, -1, 2, he), be = te(ie, 1, 1 - ye, 2 + ye, 0, -1, 2, he); return (Me || be) && (ce = te(ie, 1, -ye, 1 + ye, 0, -1, 2, he) || [], Me && (ce = qe(Me, 1).concat(ce)), be && (ce = ce.concat(qe(be, -1)))), ce }(X, V), X.length && this.splitTile(X, 0, 0, 0), $ && (X.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats))) } splitTile(C, V, $, X, ie, he, ye) { const ce = [C, V, $, X], Me = this.options, be = Me.debug; for (; ce.length;) { X = ce.pop(), $ = ce.pop(), V = ce.pop(), C = ce.pop(); const pe = 1 << V, Ae = mi(V, $, X); let fe = this.tiles[Ae]; if (!fe && (be > 1 && console.time("creation"), fe = this.tiles[Ae] = ct(C, V, $, X, Me), this.tileCoords.push({ z: V, x: $, y: X }), be)) { be > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", V, $, X, fe.numFeatures, fe.numPoints, fe.numSimplified), console.timeEnd("creation")); const at = `z${V}`; this.stats[at] = (this.stats[at] || 0) + 1, this.total++ } if (fe.source = C, ie == null) { if (V === Me.indexMaxZoom || fe.numPoints <= Me.indexMaxPoints) continue } else { if (V === Me.maxZoom || V === ie) continue; if (ie != null) { const at = ie - V; if ($ !== he >> at || X !== ye >> at) continue } } if (fe.source = null, C.length === 0) continue; be > 1 && console.time("clipping"); const He = .5 * Me.buffer / Me.extent, rt = .5 - He, _t = .5 + He, pt = 1 + He; let Ee = null, et = null, Qe = null, xt = null, ft = te(C, pe, $ - He, $ + _t, 0, fe.minX, fe.maxX, Me), bt = te(C, pe, $ + rt, $ + pt, 0, fe.minX, fe.maxX, Me); C = null, ft && (Ee = te(ft, pe, X - He, X + _t, 1, fe.minY, fe.maxY, Me), et = te(ft, pe, X + rt, X + pt, 1, fe.minY, fe.maxY, Me), ft = null), bt && (Qe = te(bt, pe, X - He, X + _t, 1, fe.minY, fe.maxY, Me), xt = te(bt, pe, X + rt, X + pt, 1, fe.minY, fe.maxY, Me), bt = null), be > 1 && console.timeEnd("clipping"), ce.push(Ee || [], V + 1, 2 * $, 2 * X), ce.push(et || [], V + 1, 2 * $, 2 * X + 1), ce.push(Qe || [], V + 1, 2 * $ + 1, 2 * X), ce.push(xt || [], V + 1, 2 * $ + 1, 2 * X + 1) } } getTile(C, V, $) { C = +C, V = +V, $ = +$; const X = this.options, { extent: ie, debug: he } = X; if (C < 0 || C > 24) return null; const ye = 1 << C, ce = mi(C, V = V + ye & ye - 1, $); if (this.tiles[ce]) return dt(this.tiles[ce], ie); he > 1 && console.log("drilling down to z%d-%d-%d", C, V, $); let Me, be = C, pe = V, Ae = $; for (; !Me && be > 0;)be--, pe >>= 1, Ae >>= 1, Me = this.tiles[mi(be, pe, Ae)]; return Me && Me.source ? (he > 1 && (console.log("found parent tile z%d-%d-%d", be, pe, Ae), console.time("drilling down")), this.splitTile(Me.source, be, pe, Ae, C, V, $), he > 1 && console.timeEnd("drilling down"), this.tiles[ce] ? dt(this.tiles[ce], ie) : null) : null } } function mi(ue, C, V) { return 32 * ((1 << ue) * V + C) + ue } function ui(ue, C) { return C ? ue.properties[C] : ue.id } function Ji(ue, C) { if (ue == null) return !0; if (ue.type === "Feature") return ui(ue, C) != null; if (ue.type === "FeatureCollection") { const V = new Set; for (const $ of ue.features) { const X = ui($, C); if (X == null || V.has(X)) return !1; V.add(X) } return !0 } return !1 } function $i(ue, C) { const V = new Map; if (ue != null) if (ue.type === "Feature") V.set(ui(ue, C), ue); else for (const $ of ue.features) V.set(ui($, C), $); return V } class Hr extends Fe { constructor() { super(...arguments), this._dataUpdateable = new Map } loadVectorTile(C, V) { return P._(this, void 0, void 0, function* () { const $ = C.tileID.canonical; if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson"); const X = this._geoJSONIndex.getTile($.z, $.x, $.y); if (!X) return null; const ie = new qt(X.features); let he = ln(ie); return he.byteOffset === 0 && he.byteLength === he.buffer.byteLength || (he = new Uint8Array(he)), { vectorTile: ie, rawData: he.buffer } }) } loadData(C) { return P._(this, void 0, void 0, function* () { var V; (V = this._pendingRequest) === null || V === void 0 || V.abort(); const $ = !!(C && C.request && C.request.collectResourceTiming) && new P.cw(C.request); this._pendingRequest = new AbortController; try { this._pendingData = this.loadAndProcessGeoJSON(C, this._pendingRequest), this._geoJSONIndex = C.cluster ? new gt(function ({ superclusterOptions: he, clusterProperties: ye }) { if (!ye || !he) return he; const ce = {}, Me = {}, be = { accumulated: null, zoom: 0 }, pe = { properties: null }, Ae = Object.keys(ye); for (const fe of Ae) { const [He, rt] = ye[fe], _t = P.cD(rt), pt = P.cD(typeof He == "string" ? [He, ["accumulated"], ["get", fe]] : He); ce[fe] = _t.value, Me[fe] = pt.value } return he.map = fe => { pe.properties = fe; const He = {}; for (const rt of Ae) He[rt] = ce[rt].evaluate(be, pe); return He }, he.reduce = (fe, He) => { pe.properties = He; for (const rt of Ae) be.accumulated = fe[rt], fe[rt] = Me[rt].evaluate(be, pe) }, he }(C)).load((yield this._pendingData).features) : (X = yield this._pendingData, new Pt(X, C.geojsonVtOptions)), this.loaded = {}; const ie = {}; if ($) { const he = $.finish(); he && (ie.resourceTiming = {}, ie.resourceTiming[C.source] = JSON.parse(JSON.stringify(he))) } return ie } catch (ie) { if (delete this._pendingRequest, P.ch(ie)) return { abandoned: !0 }; throw ie } var X }) } getData() { return P._(this, void 0, void 0, function* () { return this._pendingData }) } reloadTile(C) { const V = this.loaded; return V && V[C.uid] ? super.reloadTile(C) : this.loadTile(C) } loadAndProcessGeoJSON(C, V) { return P._(this, void 0, void 0, function* () { let $ = yield this.loadGeoJSON(C, V); if (delete this._pendingRequest, typeof $ != "object") throw new Error(`Input data given to '${C.source}' is not a valid GeoJSON object.`); if (ri($, !0), C.filter) { const X = P.cD(C.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 }); if (X.result === "error") throw new Error(X.value.map(he => `${he.key}: ${he.message}`).join(", ")); $ = { type: "FeatureCollection", features: $.features.filter(he => X.value.evaluate({ zoom: 0 }, he)) } } return $ }) } loadGeoJSON(C, V) { return P._(this, void 0, void 0, function* () { const { promoteId: $ } = C; if (C.request) { const X = yield P.j(C.request, V); return this._dataUpdateable = Ji(X.data, $) ? $i(X.data, $) : void 0, X.data } if (typeof C.data == "string") try { const X = JSON.parse(C.data); return this._dataUpdateable = Ji(X, $) ? $i(X, $) : void 0, X } catch { throw new Error(`Input data given to '${C.source}' is not a valid GeoJSON object.`) } if (!C.dataDiff) throw new Error(`Input data given to '${C.source}' is not a valid GeoJSON object.`); if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${C.source}`); return function (X, ie, he) { var ye, ce, Me, be; if (ie.removeAll && X.clear(), ie.remove) for (const pe of ie.remove) X.delete(pe); if (ie.add) for (const pe of ie.add) { const Ae = ui(pe, he); Ae != null && X.set(Ae, pe) } if (ie.update) for (const pe of ie.update) { let Ae = X.get(pe.id); if (Ae == null) continue; const fe = !pe.removeAllProperties && (((ye = pe.removeProperties) === null || ye === void 0 ? void 0 : ye.length) > 0 || ((ce = pe.addOrUpdateProperties) === null || ce === void 0 ? void 0 : ce.length) > 0); if ((pe.newGeometry || pe.removeAllProperties || fe) && (Ae = Object.assign({}, Ae), X.set(pe.id, Ae), fe && (Ae.properties = Object.assign({}, Ae.properties))), pe.newGeometry && (Ae.geometry = pe.newGeometry), pe.removeAllProperties) Ae.properties = {}; else if (((Me = pe.removeProperties) === null || Me === void 0 ? void 0 : Me.length) > 0) for (const He of pe.removeProperties) Object.prototype.hasOwnProperty.call(Ae.properties, He) && delete Ae.properties[He]; if (((be = pe.addOrUpdateProperties) === null || be === void 0 ? void 0 : be.length) > 0) for (const { key: He, value: rt } of pe.addOrUpdateProperties) Ae.properties[He] = rt } }(this._dataUpdateable, C.dataDiff, $), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) } }) } removeSource(C) { return P._(this, void 0, void 0, function* () { this._pendingRequest && this._pendingRequest.abort() }) } getClusterExpansionZoom(C) { return this._geoJSONIndex.getClusterExpansionZoom(C.clusterId) } getClusterChildren(C) { return this._geoJSONIndex.getChildren(C.clusterId) } getClusterLeaves(C) { return this._geoJSONIndex.getLeaves(C.clusterId, C.limit, C.offset) } } class Rr { constructor(C) { this.self = C, this.actor = new P.H(C), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (V, $) => { if (this.externalWorkerSourceTypes[V]) throw new Error(`Worker source with name "${V}" already registered.`); this.externalWorkerSourceTypes[V] = $ }, this.self.addProtocol = P.cj, this.self.removeProtocol = P.ck, this.self.registerRTLTextPlugin = V => { P.cE.setMethods(V) }, this.actor.registerMessageHandler("LDT", (V, $) => this._getDEMWorkerSource(V, $.source).loadTile($)), this.actor.registerMessageHandler("RDT", (V, $) => P._(this, void 0, void 0, function* () { this._getDEMWorkerSource(V, $.source).removeTile($) })), this.actor.registerMessageHandler("GCEZ", (V, $) => P._(this, void 0, void 0, function* () { return this._getWorkerSource(V, $.type, $.source).getClusterExpansionZoom($) })), this.actor.registerMessageHandler("GCC", (V, $) => P._(this, void 0, void 0, function* () { return this._getWorkerSource(V, $.type, $.source).getClusterChildren($) })), this.actor.registerMessageHandler("GCL", (V, $) => P._(this, void 0, void 0, function* () { return this._getWorkerSource(V, $.type, $.source).getClusterLeaves($) })), this.actor.registerMessageHandler("LD", (V, $) => this._getWorkerSource(V, $.type, $.source).loadData($)), this.actor.registerMessageHandler("GD", (V, $) => this._getWorkerSource(V, $.type, $.source).getData()), this.actor.registerMessageHandler("LT", (V, $) => this._getWorkerSource(V, $.type, $.source).loadTile($)), this.actor.registerMessageHandler("RT", (V, $) => this._getWorkerSource(V, $.type, $.source).reloadTile($)), this.actor.registerMessageHandler("AT", (V, $) => this._getWorkerSource(V, $.type, $.source).abortTile($)), this.actor.registerMessageHandler("RMT", (V, $) => this._getWorkerSource(V, $.type, $.source).removeTile($)), this.actor.registerMessageHandler("RS", (V, $) => P._(this, void 0, void 0, function* () { if (!this.workerSources[V] || !this.workerSources[V][$.type] || !this.workerSources[V][$.type][$.source]) return; const X = this.workerSources[V][$.type][$.source]; delete this.workerSources[V][$.type][$.source], X.removeSource !== void 0 && X.removeSource($) })), this.actor.registerMessageHandler("RM", V => P._(this, void 0, void 0, function* () { delete this.layerIndexes[V], delete this.availableImages[V], delete this.workerSources[V], delete this.demWorkerSources[V] })), this.actor.registerMessageHandler("SR", (V, $) => P._(this, void 0, void 0, function* () { this.referrer = $ })), this.actor.registerMessageHandler("SRPS", (V, $) => this._syncRTLPluginState(V, $)), this.actor.registerMessageHandler("IS", (V, $) => P._(this, void 0, void 0, function* () { this.self.importScripts($) })), this.actor.registerMessageHandler("SI", (V, $) => this._setImages(V, $)), this.actor.registerMessageHandler("UL", (V, $) => P._(this, void 0, void 0, function* () { this._getLayerIndex(V).update($.layers, $.removedIds) })), this.actor.registerMessageHandler("SL", (V, $) => P._(this, void 0, void 0, function* () { this._getLayerIndex(V).replace($) })) } _setImages(C, V) { return P._(this, void 0, void 0, function* () { this.availableImages[C] = V; for (const $ in this.workerSources[C]) { const X = this.workerSources[C][$]; for (const ie in X) X[ie].availableImages = V } }) } _syncRTLPluginState(C, V) { return P._(this, void 0, void 0, function* () { return yield P.cE.syncState(V, this.self.importScripts) }) } _getAvailableImages(C) { let V = this.availableImages[C]; return V || (V = []), V } _getLayerIndex(C) { let V = this.layerIndexes[C]; return V || (V = this.layerIndexes[C] = new c), V } _getWorkerSource(C, V, $) { if (this.workerSources[C] || (this.workerSources[C] = {}), this.workerSources[C][V] || (this.workerSources[C][V] = {}), !this.workerSources[C][V][$]) { const X = { sendAsync: (ie, he) => (ie.targetMapId = C, this.actor.sendAsync(ie, he)) }; switch (V) { case "vector": this.workerSources[C][V][$] = new Fe(X, this._getLayerIndex(C), this._getAvailableImages(C)); break; case "geojson": this.workerSources[C][V][$] = new Hr(X, this._getLayerIndex(C), this._getAvailableImages(C)); break; default: this.workerSources[C][V][$] = new this.externalWorkerSourceTypes[V](X, this._getLayerIndex(C), this._getAvailableImages(C)) } } return this.workerSources[C][V][$] } _getDEMWorkerSource(C, V) { return this.demWorkerSources[C] || (this.demWorkerSources[C] = {}), this.demWorkerSources[C][V] || (this.demWorkerSources[C][V] = new Le), this.demWorkerSources[C][V] } } return P.i(self) && (self.worker = new Rr(self)), Rr }), F("index", ["exports", "./shared"], function (P, c) {
        var de = "5.2.0"; function ze() { var u = new c.A(4); return c.A != Float32Array && (u[1] = 0, u[2] = 0), u[0] = 1, u[3] = 1, u } let xe, Fe; const Le = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(u, e, i) { const o = requestAnimationFrame(h => { a(), e(h) }), { unsubscribe: a } = c.s(u.signal, "abort", () => { a(), cancelAnimationFrame(o), i(c.c()) }, !1) }, frameAsync(u) { return new Promise((e, i) => { this.frame(u, e, i) }) }, getImageData(u, e = 0) { return this.getImageCanvasContext(u).getImageData(-e, -e, u.width + 2 * e, u.height + 2 * e) }, getImageCanvasContext(u) { const e = window.document.createElement("canvas"), i = e.getContext("2d", { willReadFrequently: !0 }); if (!i) throw new Error("failed to create canvas 2d context"); return e.width = u.width, e.height = u.height, i.drawImage(u, 0, 0, u.width, u.height), i }, resolveURL: u => (xe || (xe = document.createElement("a")), xe.href = u, xe.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() { return !!matchMedia && (Fe == null && (Fe = matchMedia("(prefers-reduced-motion: reduce)")), Fe.matches) } }; class ae { static testProp(e) { if (!ae.docStyle) return e[0]; for (let i = 0; i < e.length; i++)if (e[i] in ae.docStyle) return e[i]; return e[0] } static create(e, i, o) { const a = window.document.createElement(e); return i !== void 0 && (a.className = i), o && o.appendChild(a), a } static createNS(e, i) { return window.document.createElementNS(e, i) } static disableDrag() { ae.docStyle && ae.selectProp && (ae.userSelect = ae.docStyle[ae.selectProp], ae.docStyle[ae.selectProp] = "none") } static enableDrag() { ae.docStyle && ae.selectProp && (ae.docStyle[ae.selectProp] = ae.userSelect) } static setTransform(e, i) { e.style[ae.transformProp] = i } static addEventListener(e, i, o, a = {}) { e.addEventListener(i, o, "passive" in a ? a : a.capture) } static removeEventListener(e, i, o, a = {}) { e.removeEventListener(i, o, "passive" in a ? a : a.capture) } static suppressClickInternal(e) { e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", ae.suppressClickInternal, !0) } static suppressClick() { window.addEventListener("click", ae.suppressClickInternal, !0), window.setTimeout(() => { window.removeEventListener("click", ae.suppressClickInternal, !0) }, 0) } static getScale(e) { const i = e.getBoundingClientRect(); return { x: i.width / e.offsetWidth || 1, y: i.height / e.offsetHeight || 1, boundingClientRect: i } } static getPoint(e, i, o) { const a = i.boundingClientRect; return new c.P((o.clientX - a.left) / i.x - e.clientLeft, (o.clientY - a.top) / i.y - e.clientTop) } static mousePos(e, i) { const o = ae.getScale(e); return ae.getPoint(e, o, i) } static touchPos(e, i) { const o = [], a = ae.getScale(e); for (let h = 0; h < i.length; h++)o.push(ae.getPoint(e, a, i[h])); return o } static mouseButton(e) { return e.button } static remove(e) { e.parentNode && e.parentNode.removeChild(e) } static sanitize(e) { const i = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), o = i.querySelectorAll("script"); for (const a of o) a.remove(); return ae.clean(i), i.innerHTML } static isPossiblyDangerous(e, i) { const o = i.replace(/\s+/g, "").toLowerCase(); return !(!["src", "href", "xlink:href"].includes(e) || !o.includes("javascript:") && !o.includes("data:")) || !!e.startsWith("on") || void 0 } static clean(e) { const i = e.children; for (const o of i) ae.removeAttributes(o), ae.clean(o) } static removeAttributes(e) { for (const { name: i, value: o } of e.attributes) ae.isPossiblyDangerous(i, o) && e.removeAttribute(i) } } ae.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, ae.selectProp = ae.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), ae.transformProp = ae.testProp(["transform", "WebkitTransform"]); const Ge = { supported: !1, testSupport: function (u) { !kt && ri && (Zt ? qt(u) : Tt = u) } }; let Tt, ri, kt = !1, Zt = !1; function qt(u) { const e = u.createTexture(); u.bindTexture(u.TEXTURE_2D, e); try { if (u.texImage2D(u.TEXTURE_2D, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, ri), u.isContextLost()) return; Ge.supported = !0 } catch { } u.deleteTexture(e), kt = !0 } var ot; typeof document < "u" && (ri = document.createElement("img"), ri.onload = () => { Tt && qt(Tt), Tt = null, Zt = !0 }, ri.onerror = () => { kt = !0, Tt = null }, ri.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function (u) { let e, i, o, a; u.resetRequestQueue = () => { e = [], i = 0, o = 0, a = {} }, u.addThrottleControl = v => { const w = o++; return a[w] = v, w }, u.removeThrottleControl = v => { delete a[v], f() }, u.getImage = (v, w, I = !0) => new Promise((E, A) => { Ge.supported && (v.headers || (v.headers = {}), v.headers.accept = "image/webp,*/*"), c.e(v, { type: "image" }), e.push({ abortController: w, requestParameters: v, supportImageRefresh: I, state: "queued", onError: B => { A(B) }, onSuccess: B => { E(B) } }), f() }); const h = v => c._(this, void 0, void 0, function* () { v.state = "running"; const { requestParameters: w, supportImageRefresh: I, onError: E, onSuccess: A, abortController: B } = v, j = I === !1 && !c.i(self) && !c.g(w.url) && (!w.headers || Object.keys(w.headers).reduce((H, K) => H && K === "accept", !0)); i++; const q = j ? g(w, B) : c.m(w, B); try { const H = yield q; delete v.abortController, v.state = "completed", H.data instanceof HTMLImageElement || c.b(H.data) ? A(H) : H.data && A({ data: yield (G = H.data, typeof createImageBitmap == "function" ? c.f(G) : c.h(G)), cacheControl: H.cacheControl, expires: H.expires }) } catch (H) { delete v.abortController, E(H) } finally { i--, f() } var G }), f = () => { const v = (() => { for (const w of Object.keys(a)) if (a[w]()) return !0; return !1 })() ? c.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : c.a.MAX_PARALLEL_IMAGE_REQUESTS; for (let w = i; w < v && e.length > 0; w++) { const I = e.shift(); I.abortController.signal.aborted ? w-- : h(I) } }, g = (v, w) => new Promise((I, E) => { const A = new Image, B = v.url, j = v.credentials; j && j === "include" ? A.crossOrigin = "use-credentials" : (j && j === "same-origin" || !c.d(B)) && (A.crossOrigin = "anonymous"), w.signal.addEventListener("abort", () => { A.src = "", E(c.c()) }), A.fetchPriority = "high", A.onload = () => { A.onerror = A.onload = null, I({ data: A }) }, A.onerror = () => { A.onerror = A.onload = null, w.signal.aborted || E(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")) }, A.src = B }) }(ot || (ot = {})), ot.resetRequestQueue(); class Ht { constructor(e) { this._transformRequestFn = e } transformRequest(e, i) { return this._transformRequestFn && this._transformRequestFn(e, i) || { url: e } } setTransformRequest(e) { this._transformRequestFn = e } } function Vt(u) { const e = []; if (typeof u == "string") e.push({ id: "default", url: u }); else if (u && u.length > 0) { const i = []; for (const { id: o, url: a } of u) { const h = `${o}${a}`; i.indexOf(h) === -1 && (i.push(h), e.push({ id: o, url: a })) } } return e } function Et(u, e, i) { try { const o = new URL(u); return o.pathname += `${e}${i}`, o.toString() } catch { throw new Error(`Invalid sprite URL "${u}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`) } } class Nt { constructor(e, i, o, a) { this.context = e, this.format = o, this.texture = e.gl.createTexture(), this.update(i, a) } update(e, i, o) { const { width: a, height: h } = e, f = !(this.size && this.size[0] === a && this.size[1] === h || o), { context: g } = this, { gl: v } = g; if (this.useMipmap = !!(i && i.useMipmap), v.bindTexture(v.TEXTURE_2D, this.texture), g.pixelStoreUnpackFlipY.set(!1), g.pixelStoreUnpack.set(1), g.pixelStoreUnpackPremultiplyAlpha.set(this.format === v.RGBA && (!i || i.premultiply !== !1)), f) this.size = [a, h], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || c.b(e) ? v.texImage2D(v.TEXTURE_2D, 0, this.format, this.format, v.UNSIGNED_BYTE, e) : v.texImage2D(v.TEXTURE_2D, 0, this.format, a, h, 0, this.format, v.UNSIGNED_BYTE, e.data); else { const { x: w, y: I } = o || { x: 0, y: 0 }; e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || c.b(e) ? v.texSubImage2D(v.TEXTURE_2D, 0, w, I, v.RGBA, v.UNSIGNED_BYTE, e) : v.texSubImage2D(v.TEXTURE_2D, 0, w, I, a, h, v.RGBA, v.UNSIGNED_BYTE, e.data) } this.useMipmap && this.isSizePowerOfTwo() && v.generateMipmap(v.TEXTURE_2D) } bind(e, i, o) { const { context: a } = this, { gl: h } = a; h.bindTexture(h.TEXTURE_2D, this.texture), o !== h.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (o = h.LINEAR), e !== this.filter && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, e), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, o || e), this.filter = e), i !== this.wrap && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, i), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, i), this.wrap = i) } isSizePowerOfTwo() { return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0 } destroy() { const { gl: e } = this.context; e.deleteTexture(this.texture), this.texture = null } } function ln(u) { const { userImage: e } = u; return !!(e && e.render && e.render()) && (u.data.replace(new Uint8Array(e.data.buffer)), !0) } class zr extends c.E { constructor() { super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new c.R({ width: 1, height: 1 }), this.dirty = !0 } isLoaded() { return this.loaded } setLoaded(e) { if (this.loaded !== e && (this.loaded = e, e)) { for (const { ids: i, promiseResolve: o } of this.requestors) o(this._getImagesForIds(i)); this.requestors = [] } } getImage(e) { const i = this.images[e]; if (i && !i.data && i.spriteData) { const o = i.spriteData; i.data = new c.R({ width: o.width, height: o.height }, o.context.getImageData(o.x, o.y, o.width, o.height).data), i.spriteData = null } return i } addImage(e, i) { if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`); this._validate(e, i) && (this.images[e] = i) } _validate(e, i) { let o = !0; const a = i.data || i.spriteData; return this._validateStretch(i.stretchX, a && a.width) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "stretchX" value`))), o = !1), this._validateStretch(i.stretchY, a && a.height) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "stretchY" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new c.k(new Error(`Image "${e}" has invalid "content" value`))), o = !1), o } _validateStretch(e, i) { if (!e) return !0; let o = 0; for (const a of e) { if (a[0] < o || a[1] < a[0] || i < a[1]) return !1; o = a[1] } return !0 } _validateContent(e, i) { if (!e) return !0; if (e.length !== 4) return !1; const o = i.spriteData, a = o && o.width || i.data.width, h = o && o.height || i.data.height; return !(e[0] < 0 || a < e[0] || e[1] < 0 || h < e[1] || e[2] < 0 || a < e[2] || e[3] < 0 || h < e[3] || e[2] < e[0] || e[3] < e[1]) } updateImage(e, i, o = !0) { const a = this.getImage(e); if (o && (a.data.width !== i.data.width || a.data.height !== i.data.height)) throw new Error(`size mismatch between old image (${a.data.width}x${a.data.height}) and new image (${i.data.width}x${i.data.height}).`); i.version = a.version + 1, this.images[e] = i, this.updatedImages[e] = !0 } removeImage(e) { const i = this.images[e]; delete this.images[e], delete this.patterns[e], i.userImage && i.userImage.onRemove && i.userImage.onRemove() } listImages() { return Object.keys(this.images) } getImages(e) { return new Promise((i, o) => { let a = !0; if (!this.isLoaded()) for (const h of e) this.images[h] || (a = !1); this.isLoaded() || a ? i(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: i }) }) } _getImagesForIds(e) { const i = {}; for (const o of e) { let a = this.getImage(o); a || (this.fire(new c.l("styleimagemissing", { id: o })), a = this.getImage(o)), a ? i[o] = { data: a.data.clone(), pixelRatio: a.pixelRatio, sdf: a.sdf, version: a.version, stretchX: a.stretchX, stretchY: a.stretchY, content: a.content, textFitWidth: a.textFitWidth, textFitHeight: a.textFitHeight, hasRenderCallback: !!(a.userImage && a.userImage.render) } : c.w(`Image "${o}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`) } return i } getPixelSize() { const { width: e, height: i } = this.atlasImage; return { width: e, height: i } } getPattern(e) { const i = this.patterns[e], o = this.getImage(e); if (!o) return null; if (i && i.position.version === o.version) return i.position; if (i) i.position.version = o.version; else { const a = { w: o.data.width + 2, h: o.data.height + 2, x: 0, y: 0 }, h = new c.I(a, o); this.patterns[e] = { bin: a, position: h } } return this._updatePatternAtlas(), this.patterns[e].position } bind(e) { const i = e.gl; this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new Nt(e, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE) } _updatePatternAtlas() { const e = []; for (const h in this.patterns) e.push(this.patterns[h].bin); const { w: i, h: o } = c.p(e), a = this.atlasImage; a.resize({ width: i || 1, height: o || 1 }); for (const h in this.patterns) { const { bin: f } = this.patterns[h], g = f.x + 1, v = f.y + 1, w = this.getImage(h).data, I = w.width, E = w.height; c.R.copy(w, a, { x: 0, y: 0 }, { x: g, y: v }, { width: I, height: E }), c.R.copy(w, a, { x: 0, y: E - 1 }, { x: g, y: v - 1 }, { width: I, height: 1 }), c.R.copy(w, a, { x: 0, y: 0 }, { x: g, y: v + E }, { width: I, height: 1 }), c.R.copy(w, a, { x: I - 1, y: 0 }, { x: g - 1, y: v }, { width: 1, height: E }), c.R.copy(w, a, { x: 0, y: 0 }, { x: g + I, y: v }, { width: 1, height: E }) } this.dirty = !0 } beginFrame() { this.callbackDispatchedThisFrame = {} } dispatchRenderCallbacks(e) { for (const i of e) { if (this.callbackDispatchedThisFrame[i]) continue; this.callbackDispatchedThisFrame[i] = !0; const o = this.getImage(i); o || c.w(`Image with ID: "${i}" was not found`), ln(o) && this.updateImage(i, o) } } } const or = 1e20; function ar(u, e, i, o, a, h, f, g, v) { for (let w = e; w < e + o; w++)Zi(u, i * h + w, h, a, f, g, v); for (let w = i; w < i + a; w++)Zi(u, w * h + e, 1, o, f, g, v) } function Zi(u, e, i, o, a, h, f) { h[0] = 0, f[0] = -1e20, f[1] = or, a[0] = u[e]; for (let g = 1, v = 0, w = 0; g < o; g++) { a[g] = u[e + g * i]; const I = g * g; do { const E = h[v]; w = (a[g] - a[E] + I - E * E) / (g - E) / 2 } while (w <= f[v] && --v > -1); v++, h[v] = g, f[v] = w, f[v + 1] = or } for (let g = 0, v = 0; g < o; g++) { for (; f[v + 1] < g;)v++; const w = h[v], I = g - w; u[e + g * i] = a[w] + I * I } } class bi { constructor(e, i) { this.requestManager = e, this.localIdeographFontFamily = i, this.entries = {} } setURL(e) { this.url = e } getGlyphs(e) { return c._(this, void 0, void 0, function* () { const i = []; for (const h in e) for (const f of e[h]) i.push(this._getAndCacheGlyphsPromise(h, f)); const o = yield Promise.all(i), a = {}; for (const { stack: h, id: f, glyph: g } of o) a[h] || (a[h] = {}), a[h][f] = g && { id: g.id, bitmap: g.bitmap.clone(), metrics: g.metrics }; return a }) } _getAndCacheGlyphsPromise(e, i) { return c._(this, void 0, void 0, function* () { let o = this.entries[e]; o || (o = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} }); let a = o.glyphs[i]; if (a !== void 0) return { stack: e, id: i, glyph: a }; if (a = this._tinySDF(o, e, i), a) return o.glyphs[i] = a, { stack: e, id: i, glyph: a }; const h = Math.floor(i / 256); if (256 * h > 65535) throw new Error("glyphs > 65535 not supported"); if (o.ranges[h]) return { stack: e, id: i, glyph: a }; if (!this.url) throw new Error("glyphsUrl is not set"); if (!o.requests[h]) { const g = bi.loadGlyphRange(e, h, this.url, this.requestManager); o.requests[h] = g } const f = yield o.requests[h]; for (const g in f) this._doesCharSupportLocalGlyph(+g) || (o.glyphs[+g] = f[+g]); return o.ranges[h] = !0, { stack: e, id: i, glyph: f[i] || null } }) } _doesCharSupportLocalGlyph(e) { return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(e)) || c.u["CJK Unified Ideographs"](e) || c.u["Hangul Syllables"](e) || c.u.Hiragana(e) || c.u.Katakana(e) || c.u["CJK Symbols and Punctuation"](e) || c.u["Halfwidth and Fullwidth Forms"](e)) } _tinySDF(e, i, o) { const a = this.localIdeographFontFamily; if (!a || !this._doesCharSupportLocalGlyph(o)) return; let h = e.tinySDF; if (!h) { let g = "400"; /bold/i.test(i) ? g = "900" : /medium/i.test(i) ? g = "500" : /light/i.test(i) && (g = "200"), h = e.tinySDF = new bi.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: .25, fontFamily: a, fontWeight: g }) } const f = h.draw(String.fromCharCode(o)); return { id: o, bitmap: new c.q({ width: f.width || 60, height: f.height || 60 }, f.data), metrics: { width: f.glyphWidth / 2 || 24, height: f.glyphHeight / 2 || 24, left: f.glyphLeft / 2 + .5 || 0, top: f.glyphTop / 2 - 27.5 || -8, advance: f.glyphAdvance / 2 || 24, isDoubleResolution: !0 } } } } bi.loadGlyphRange = function (u, e, i, o) { return c._(this, void 0, void 0, function* () { const a = 256 * e, h = a + 255, f = o.transformRequest(i.replace("{fontstack}", u).replace("{range}", `${a}-${h}`), "Glyphs"), g = yield c.n(f, new AbortController); if (!g || !g.data) throw new Error(`Could not load glyph range. range: ${e}, ${a}-${h}`); const v = {}; for (const w of c.o(g.data)) v[w.id] = w; return v }) }, bi.TinySDF = class { constructor({ fontSize: u = 24, buffer: e = 3, radius: i = 8, cutoff: o = .25, fontFamily: a = "sans-serif", fontWeight: h = "normal", fontStyle: f = "normal" } = {}) { this.buffer = e, this.cutoff = o, this.radius = i; const g = this.size = u + 4 * e, v = this._createCanvas(g), w = this.ctx = v.getContext("2d", { willReadFrequently: !0 }); w.font = `${f} ${h} ${u}px ${a}`, w.textBaseline = "alphabetic", w.textAlign = "left", w.fillStyle = "black", this.gridOuter = new Float64Array(g * g), this.gridInner = new Float64Array(g * g), this.f = new Float64Array(g), this.z = new Float64Array(g + 1), this.v = new Uint16Array(g) } _createCanvas(u) { const e = document.createElement("canvas"); return e.width = e.height = u, e } draw(u) { const { width: e, actualBoundingBoxAscent: i, actualBoundingBoxDescent: o, actualBoundingBoxLeft: a, actualBoundingBoxRight: h } = this.ctx.measureText(u), f = Math.ceil(i), g = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(h - a))), v = Math.min(this.size - this.buffer, f + Math.ceil(o)), w = g + 2 * this.buffer, I = v + 2 * this.buffer, E = Math.max(w * I, 0), A = new Uint8ClampedArray(E), B = { data: A, width: w, height: I, glyphWidth: g, glyphHeight: v, glyphTop: f, glyphLeft: 0, glyphAdvance: e }; if (g === 0 || v === 0) return B; const { ctx: j, buffer: q, gridInner: G, gridOuter: H } = this; j.clearRect(q, q, g, v), j.fillText(u, q, q + f); const K = j.getImageData(q, q, g, v); H.fill(or, 0, E), G.fill(0, 0, E); for (let Q = 0; Q < v; Q++)for (let ee = 0; ee < g; ee++) { const re = K.data[4 * (Q * g + ee) + 3] / 255; if (re === 0) continue; const oe = (Q + q) * w + ee + q; if (re === 1) H[oe] = 0, G[oe] = or; else { const ne = .5 - re; H[oe] = ne > 0 ? ne * ne : 0, G[oe] = ne < 0 ? ne * ne : 0 } } ar(H, 0, 0, w, I, w, this.f, this.v, this.z), ar(G, q, q, g, v, w, this.f, this.v, this.z); for (let Q = 0; Q < E; Q++) { const ee = Math.sqrt(H[Q]) - Math.sqrt(G[Q]); A[Q] = Math.round(255 - 255 * (ee / this.radius + this.cutoff)) } return B } }; class Pn { constructor() { this.specification = c.v.light.position } possiblyEvaluate(e, i) { return c.z(e.expression.evaluate(i)) } interpolate(e, i, o) { return { x: c.B.number(e.x, i.x, o), y: c.B.number(e.y, i.y, o), z: c.B.number(e.z, i.z, o) } } } let gt; class Ut extends c.E { constructor(e) { super(), gt = gt || new c.r({ anchor: new c.D(c.v.light.anchor), position: new Pn, color: new c.D(c.v.light.color), intensity: new c.D(c.v.light.intensity) }), this._transitionable = new c.T(gt), this.setLight(e), this._transitioning = this._transitionable.untransitioned() } getLight() { return this._transitionable.serialize() } setLight(e, i = {}) { if (!this._validate(c.t, e, i)) for (const o in e) { const a = e[o]; o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), a) : this._transitionable.setValue(o, a) } } updateTransitions(e) { this._transitioning = this._transitionable.transitioned(e, this._transitioning) } hasTransition() { return this._transitioning.hasTransition() } recalculate(e) { this.properties = this._transitioning.possiblyEvaluate(e) } _validate(e, i, o) { return (!o || o.validate !== !1) && c.x(this, e.call(c.y, { value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v })) } } const Dt = new c.r({ "sky-color": new c.D(c.v.sky["sky-color"]), "horizon-color": new c.D(c.v.sky["horizon-color"]), "fog-color": new c.D(c.v.sky["fog-color"]), "fog-ground-blend": new c.D(c.v.sky["fog-ground-blend"]), "horizon-fog-blend": new c.D(c.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new c.D(c.v.sky["sky-horizon-blend"]), "atmosphere-blend": new c.D(c.v.sky["atmosphere-blend"]) }); class rr extends c.E { constructor(e) { super(), this._transitionable = new c.T(Dt), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.C(0)) } setSky(e, i = {}) { if (!this._validate(c.F, e, i)) { e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 }); for (const o in e) { const a = e[o]; o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), a) : this._transitionable.setValue(o, a) } } } getSky() { return this._transitionable.serialize() } updateTransitions(e) { this._transitioning = this._transitionable.transitioned(e, this._transitioning) } hasTransition() { return this._transitioning.hasTransition() } recalculate(e) { this.properties = this._transitioning.possiblyEvaluate(e) } _validate(e, i, o = {}) { return (o == null ? void 0 : o.validate) !== !1 && c.x(this, e.call(c.y, c.e({ value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: c.v }))) } calculateFogBlendOpacity(e) { return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1 } } class kr { constructor(e, i) { this.width = e, this.height = i, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {} } getDash(e, i) { const o = e.join(",") + String(i); return this.dashEntry[o] || (this.dashEntry[o] = this.addDash(e, i)), this.dashEntry[o] } getDashRanges(e, i, o) { const a = []; let h = e.length % 2 == 1 ? -e[e.length - 1] * o : 0, f = e[0] * o, g = !0; a.push({ left: h, right: f, isDash: g, zeroLength: e[0] === 0 }); let v = e[0]; for (let w = 1; w < e.length; w++) { g = !g; const I = e[w]; h = v * o, v += I, f = v * o, a.push({ left: h, right: f, isDash: g, zeroLength: I === 0 }) } return a } addRoundDash(e, i, o) { const a = i / 2; for (let h = -o; h <= o; h++) { const f = this.width * (this.nextRow + o + h); let g = 0, v = e[g]; for (let w = 0; w < this.width; w++) { w / v.right > 1 && (v = e[++g]); const I = Math.abs(w - v.left), E = Math.abs(w - v.right), A = Math.min(I, E); let B; const j = h / o * (a + 1); if (v.isDash) { const q = a - Math.abs(j); B = Math.sqrt(A * A + q * q) } else B = a - Math.sqrt(A * A + j * j); this.data[f + w] = Math.max(0, Math.min(255, B + 128)) } } } addRegularDash(e) { for (let g = e.length - 1; g >= 0; --g) { const v = e[g], w = e[g + 1]; v.zeroLength ? e.splice(g, 1) : w && w.isDash === v.isDash && (w.left = v.left, e.splice(g, 1)) } const i = e[0], o = e[e.length - 1]; i.isDash === o.isDash && (i.left = o.left - this.width, o.right = i.right + this.width); const a = this.width * this.nextRow; let h = 0, f = e[h]; for (let g = 0; g < this.width; g++) { g / f.right > 1 && (f = e[++h]); const v = Math.abs(g - f.left), w = Math.abs(g - f.right), I = Math.min(v, w); this.data[a + g] = Math.max(0, Math.min(255, (f.isDash ? I : -I) + 128)) } } addDash(e, i) { const o = i ? 7 : 0, a = 2 * o + 1; if (this.nextRow + a > this.height) return c.w("LineAtlas out of space"), null; let h = 0; for (let g = 0; g < e.length; g++)h += e[g]; if (h !== 0) { const g = this.width / h, v = this.getDashRanges(e, this.width, g); i ? this.addRoundDash(v, g, o) : this.addRegularDash(v) } const f = { y: (this.nextRow + o + .5) / this.height, height: 2 * o / this.height, width: h }; return this.nextRow += a, this.dirty = !0, f } bind(e) { const i = e.gl; this.texture ? (i.bindTexture(i.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, this.width, this.height, i.ALPHA, i.UNSIGNED_BYTE, this.data))) : (this.texture = i.createTexture(), i.bindTexture(i.TEXTURE_2D, this.texture), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), i.texImage2D(i.TEXTURE_2D, 0, i.ALPHA, this.width, this.height, 0, i.ALPHA, i.UNSIGNED_BYTE, this.data)) } } const lr = "maplibre_preloaded_worker_pool"; class gi { constructor() { this.active = {} } acquire(e) { if (!this.workers) for (this.workers = []; this.workers.length < gi.workerCount;)this.workers.push(new Worker(c.a.WORKER_URL)); return this.active[e] = !0, this.workers.slice() } release(e) { delete this.active[e], this.numActive() === 0 && (this.workers.forEach(i => { i.terminate() }), this.workers = null) } isPreloaded() { return !!this.active[lr] } numActive() { return Object.keys(this.active).length } } const cr = Math.floor(Le.hardwareConcurrency / 2); let ur, Si; function xr() { return ur || (ur = new gi), ur } gi.workerCount = c.G(globalThis) ? Math.max(Math.min(cr, 3), 1) : 1; class Dr { constructor(e, i) { this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = i; const o = this.workerPool.acquire(i); for (let a = 0; a < o.length; a++) { const h = new c.H(o[a], i); h.name = `Worker ${a}`, this.actors.push(h) } if (!this.actors.length) throw new Error("No actors found") } broadcast(e, i) { const o = []; for (const a of this.actors) o.push(a.sendAsync({ type: e, data: i })); return Promise.all(o) } getActor() { return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor] } remove(e = !0) { this.actors.forEach(i => { i.remove() }), this.actors = [], e && this.workerPool.release(this.id) } registerMessageHandler(e, i) { for (const o of this.actors) o.registerMessageHandler(e, i) } } function Gr() { return Si || (Si = new Dr(xr(), c.J), Si.registerMessageHandler("GR", (u, e, i) => c.m(e, i))), Si } function Ki(u, e) { const i = c.K(); return c.L(i, i, [1, 1, 0]), c.M(i, i, [.5 * u.width, .5 * u.height, 1]), u.calculatePosMatrix ? c.N(i, i, u.calculatePosMatrix(e.toUnwrapped())) : i } function qr(u, e, i, o, a, h) { var f; const g = function (E, A, B) { if (E) for (const j of E) { const q = A[j]; if (q && q.source === B && q.type === "fill-extrusion") return !0 } else for (const j in A) { const q = A[j]; if (q.source === B && q.type === "fill-extrusion") return !0 } return !1 }((f = a == null ? void 0 : a.layers) !== null && f !== void 0 ? f : null, e, u.id), v = h.maxPitchScaleFactor(), w = u.tilesIn(o, v, g); w.sort(Ui); const I = []; for (const E of w) I.push({ wrappedTileID: E.tileID.wrapped().key, queryResults: E.tile.queryRenderedFeatures(e, i, u._state, E.queryGeometry, E.cameraQueryGeometry, E.scale, a, h, v, Ki(u.transform, E.tileID)) }); return function (E, A) { for (const B in E) for (const j of E[B]) te(j, A); return E }(function (E) { const A = {}, B = {}; for (const j of E) { const q = j.queryResults, G = j.wrappedTileID, H = B[G] = B[G] || {}; for (const K in q) { const Q = q[K], ee = H[K] = H[K] || {}, re = A[K] = A[K] || []; for (const oe of Q) ee[oe.featureIndex] || (ee[oe.featureIndex] = !0, re.push(oe)) } } return A }(I), u) } function Ui(u, e) { const i = u.tileID, o = e.tileID; return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x } function te(u, e) { const i = u.feature, o = e.getFeatureState(i.layer["source-layer"], i.id); i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = o } function le(u, e, i) { return c._(this, void 0, void 0, function* () { let o = u; if (u.url ? o = (yield c.j(e.transformRequest(u.url, "Source"), i)).data : yield Le.frameAsync(i), !o) return null; const a = c.O(c.e(o, u), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]); return "vector_layers" in o && o.vector_layers && (a.vectorLayerIds = o.vector_layers.map(h => h.id)), a }) } class we { constructor(e, i) { e && (i ? this.setSouthWest(e).setNorthEast(i) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1]))) } setNorthEast(e) { return this._ne = e instanceof c.Q ? new c.Q(e.lng, e.lat) : c.Q.convert(e), this } setSouthWest(e) { return this._sw = e instanceof c.Q ? new c.Q(e.lng, e.lat) : c.Q.convert(e), this } extend(e) { const i = this._sw, o = this._ne; let a, h; if (e instanceof c.Q) a = e, h = e; else { if (!(e instanceof we)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(we.convert(e)) : this.extend(c.Q.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(c.Q.convert(e)) : this; if (a = e._sw, h = e._ne, !a || !h) return this } return i || o ? (i.lng = Math.min(a.lng, i.lng), i.lat = Math.min(a.lat, i.lat), o.lng = Math.max(h.lng, o.lng), o.lat = Math.max(h.lat, o.lat)) : (this._sw = new c.Q(a.lng, a.lat), this._ne = new c.Q(h.lng, h.lat)), this } getCenter() { return new c.Q((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2) } getSouthWest() { return this._sw } getNorthEast() { return this._ne } getNorthWest() { return new c.Q(this.getWest(), this.getNorth()) } getSouthEast() { return new c.Q(this.getEast(), this.getSouth()) } getWest() { return this._sw.lng } getSouth() { return this._sw.lat } getEast() { return this._ne.lng } getNorth() { return this._ne.lat } toArray() { return [this._sw.toArray(), this._ne.toArray()] } toString() { return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})` } isEmpty() { return !(this._sw && this._ne) } contains(e) { const { lng: i, lat: o } = c.Q.convert(e); let a = this._sw.lng <= i && i <= this._ne.lng; return this._sw.lng > this._ne.lng && (a = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= o && o <= this._ne.lat && a } static convert(e) { return e instanceof we ? e : e && new we(e) } static fromLngLat(e, i = 0) { const o = 360 * i / 40075017, a = o / Math.cos(Math.PI / 180 * e.lat); return new we(new c.Q(e.lng - a, e.lat - o), new c.Q(e.lng + a, e.lat + o)) } adjustAntiMeridian() { const e = new c.Q(this._sw.lng, this._sw.lat), i = new c.Q(this._ne.lng, this._ne.lat); return new we(e, e.lng > i.lng ? new c.Q(i.lng + 360, i.lat) : i) } } class Ze { constructor(e, i, o) { this.bounds = we.convert(this.validateBounds(e)), this.minzoom = i || 0, this.maxzoom = o || 24 } validateBounds(e) { return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90] } contains(e) { const i = Math.pow(2, e.z), o = Math.floor(c.U(this.bounds.getWest()) * i), a = Math.floor(c.S(this.bounds.getNorth()) * i), h = Math.ceil(c.U(this.bounds.getEast()) * i), f = Math.ceil(c.S(this.bounds.getSouth()) * i); return e.x >= o && e.x < h && e.y >= a && e.y < f } } class Be extends c.E { constructor(e, i, o, a) { if (super(), this.id = e, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, c.e(this, c.O(i, ["url", "scheme", "tileSize", "promoteId"])), this._options = c.e({ type: "vector" }, i), this._collectResourceTiming = i.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512"); this.setEventedParent(a) } load() { return c._(this, void 0, void 0, function* () { this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController; try { const e = yield le(this._options, this.map._requestManager, this._tileJSONRequest); this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (c.e(this, e), e.bounds && (this.tileBounds = new Ze(e.bounds, this.minzoom, this.maxzoom)), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.l("data", { dataType: "source", sourceDataType: "content" }))) } catch (e) { this._tileJSONRequest = null, this.fire(new c.k(e)) } }) } loaded() { return this._loaded } hasTile(e) { return !this.tileBounds || this.tileBounds.contains(e.canonical) } onAdd(e) { this.map = e, this.load() } setSourceProperty(e) { this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load() } setTiles(e) { return this.setSourceProperty(() => { this._options.tiles = e }), this } setUrl(e) { return this.setSourceProperty(() => { this.url = e, this._options.url = e }), this } onRemove() { this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null) } serialize() { return c.e({}, this._options) } loadTile(e) { return c._(this, void 0, void 0, function* () { const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), o = { request: this.map._requestManager.transformRequest(i, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity }; o.request.collectResourceTiming = this._collectResourceTiming; let a = "RT"; if (e.actor && e.state !== "expired") { if (e.state === "loading") return new Promise((h, f) => { e.reloadPromise = { resolve: h, reject: f } }) } else e.actor = this.dispatcher.getActor(), a = "LT"; e.abortController = new AbortController; try { const h = yield e.actor.sendAsync({ type: a, data: o }, e.abortController); if (delete e.abortController, e.aborted) return; this._afterTileLoadWorkerResponse(e, h) } catch (h) { if (delete e.abortController, e.aborted) return; if (h && h.status !== 404) throw h; this._afterTileLoadWorkerResponse(e, null) } }) } _afterTileLoadWorkerResponse(e, i) { if (i && i.resourceTiming && (e.resourceTiming = i.resourceTiming), i && this.map._refreshExpiredTiles && e.setExpiryData(i), e.loadVectorData(i, this.map.painter), e.reloadPromise) { const o = e.reloadPromise; e.reloadPromise = null, this.loadTile(e).then(o.resolve).catch(o.reject) } } abortTile(e) { return c._(this, void 0, void 0, function* () { e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } })) }) } unloadTile(e) { return c._(this, void 0, void 0, function* () { e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } })) }) } hasTransition() { return !1 } } class Oe extends c.E { constructor(e, i, o, a) { super(), this.id = e, this.dispatcher = o, this.setEventedParent(a), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = c.e({ type: "raster" }, i), c.e(this, c.O(i, ["url", "scheme", "tileSize"])) } load() { return c._(this, arguments, void 0, function* (e = !1) { this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController; try { const i = yield le(this._options, this.map._requestManager, this._tileJSONRequest); this._tileJSONRequest = null, this._loaded = !0, i && (c.e(this, i), i.bounds && (this.tileBounds = new Ze(i.bounds, this.minzoom, this.maxzoom)), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new c.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e }))) } catch (i) { this._tileJSONRequest = null, this.fire(new c.k(i)) } }) } loaded() { return this._loaded } onAdd(e) { this.map = e, this.load() } onRemove() { this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null) } setSourceProperty(e) { this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0) } setTiles(e) { return this.setSourceProperty(() => { this._options.tiles = e }), this } setUrl(e) { return this.setSourceProperty(() => { this.url = e, this._options.url = e }), this } serialize() { return c.e({}, this._options) } hasTile(e) { return !this.tileBounds || this.tileBounds.contains(e.canonical) } loadTile(e) { return c._(this, void 0, void 0, function* () { const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme); e.abortController = new AbortController; try { const o = yield ot.getImage(this.map._requestManager.transformRequest(i, "Tile"), e.abortController, this.map._refreshExpiredTiles); if (delete e.abortController, e.aborted) return void (e.state = "unloaded"); if (o && o.data) { this.map._refreshExpiredTiles && o.cacheControl && o.expires && e.setExpiryData({ cacheControl: o.cacheControl, expires: o.expires }); const a = this.map.painter.context, h = a.gl, f = o.data; e.texture = this.map.painter.getTileTexture(f.width), e.texture ? e.texture.update(f, { useMipmap: !0 }) : (e.texture = new Nt(a, f, h.RGBA, { useMipmap: !0 }), e.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE, h.LINEAR_MIPMAP_NEAREST)), e.state = "loaded" } } catch (o) { if (delete e.abortController, e.aborted) e.state = "unloaded"; else if (o) throw e.state = "errored", o } }) } abortTile(e) { return c._(this, void 0, void 0, function* () { e.abortController && (e.abortController.abort(), delete e.abortController) }) } unloadTile(e) { return c._(this, void 0, void 0, function* () { e.texture && this.map.painter.saveTileTexture(e.texture) }) } hasTransition() { return !1 } } class Xe extends Oe { constructor(e, i, o, a) { super(e, i, o, a), this.type = "raster-dem", this.maxzoom = 22, this._options = c.e({ type: "raster-dem" }, i), this.encoding = i.encoding || "mapbox", this.redFactor = i.redFactor, this.greenFactor = i.greenFactor, this.blueFactor = i.blueFactor, this.baseShift = i.baseShift } loadTile(e) { return c._(this, void 0, void 0, function* () { const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), o = this.map._requestManager.transformRequest(i, "Tile"); e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController; try { const a = yield ot.getImage(o, e.abortController, this.map._refreshExpiredTiles); if (delete e.abortController, e.aborted) return void (e.state = "unloaded"); if (a && a.data) { const h = a.data; this.map._refreshExpiredTiles && a.cacheControl && a.expires && e.setExpiryData({ cacheControl: a.cacheControl, expires: a.expires }); const f = c.b(h) && c.V() ? h : yield this.readImageNow(h), g = { type: this.type, uid: e.uid, source: this.id, rawImageData: f, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift }; if (!e.actor || e.state === "expired") { e.actor = this.dispatcher.getActor(); const v = yield e.actor.sendAsync({ type: "LDT", data: g }); e.dem = v, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded" } } } catch (a) { if (delete e.abortController, e.aborted) e.state = "unloaded"; else if (a) throw e.state = "errored", a } }) } readImageNow(e) { return c._(this, void 0, void 0, function* () { if (typeof VideoFrame < "u" && c.W()) { const i = e.width + 2, o = e.height + 2; try { return new c.R({ width: i, height: o }, yield c.X(e, -1, -1, i, o)) } catch { } } return Le.getImageData(e, 1) }) } _getNeighboringTiles(e) { const i = e.canonical, o = Math.pow(2, i.z), a = (i.x - 1 + o) % o, h = i.x === 0 ? e.wrap - 1 : e.wrap, f = (i.x + 1 + o) % o, g = i.x + 1 === o ? e.wrap + 1 : e.wrap, v = {}; return v[new c.Y(e.overscaledZ, h, i.z, a, i.y).key] = { backfilled: !1 }, v[new c.Y(e.overscaledZ, g, i.z, f, i.y).key] = { backfilled: !1 }, i.y > 0 && (v[new c.Y(e.overscaledZ, h, i.z, a, i.y - 1).key] = { backfilled: !1 }, v[new c.Y(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = { backfilled: !1 }, v[new c.Y(e.overscaledZ, g, i.z, f, i.y - 1).key] = { backfilled: !1 }), i.y + 1 < o && (v[new c.Y(e.overscaledZ, h, i.z, a, i.y + 1).key] = { backfilled: !1 }, v[new c.Y(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = { backfilled: !1 }, v[new c.Y(e.overscaledZ, g, i.z, f, i.y + 1).key] = { backfilled: !1 }), v } unloadTile(e) { return c._(this, void 0, void 0, function* () { e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } })) }) } } class We extends c.E { constructor(e, i, o, a) { super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = o.getActor(), this.setEventedParent(a), this._data = i.data, this._options = c.e({}, i), this._collectResourceTiming = i.collectResourceTiming, i.maxzoom !== void 0 && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId, i.clusterMaxZoom !== void 0 && this.maxzoom <= i.clusterMaxZoom && c.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`), this.workerOptions = c.e({ source: this.id, cluster: i.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(i.buffer !== void 0 ? i.buffer : 128), tolerance: this._pixelsToTileUnits(i.tolerance !== void 0 ? i.tolerance : .375), extent: c.Z, maxZoom: this.maxzoom, lineMetrics: i.lineMetrics || !1, generateId: i.generateId || !1 }, superclusterOptions: { maxZoom: i.clusterMaxZoom !== void 0 ? i.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i.clusterMinPoints || 2), extent: c.Z, radius: this._pixelsToTileUnits(i.clusterRadius || 50), log: !1, generateId: i.generateId || !1 }, clusterProperties: i.clusterProperties, filter: i.filter }, i.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId) } _pixelsToTileUnits(e) { return e * (c.Z / this.tileSize) } load() { return c._(this, void 0, void 0, function* () { yield this._updateWorkerData() }) } onAdd(e) { this.map = e, this.load() } setData(e) { return this._data = e, this._updateWorkerData(), this } updateData(e) { return this._updateWorkerData(e), this } getData() { return c._(this, void 0, void 0, function* () { const e = c.e({ type: this.type }, this.workerOptions); return this.actor.sendAsync({ type: "GD", data: e }) }) } setClusterOptions(e) { return this.workerOptions.cluster = e.cluster, e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom)), this._updateWorkerData(), this } getClusterExpansionZoom(e) { return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } }) } getClusterChildren(e) { return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } }) } getClusterLeaves(e, i, o) { return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: i, offset: o } }) } _updateWorkerData(e) { return c._(this, void 0, void 0, function* () { const i = c.e({ type: this.type }, this.workerOptions); e ? i.dataDiff = e : typeof this._data == "string" ? (i.request = this.map._requestManager.transformRequest(Le.resolveURL(this._data), "Source"), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new c.l("dataloading", { dataType: "source" })); try { const o = yield this.actor.sendAsync({ type: "LD", data: i }); if (this._pendingLoads--, this._removed || o.abandoned) return void this.fire(new c.l("dataabort", { dataType: "source" })); let a = null; o.resourceTiming && o.resourceTiming[this.id] && (a = o.resourceTiming[this.id].slice(0)); const h = { dataType: "source" }; this._collectResourceTiming && a && a.length > 0 && c.e(h, { resourceTiming: a }), this.fire(new c.l("data", Object.assign(Object.assign({}, h), { sourceDataType: "metadata" }))), this.fire(new c.l("data", Object.assign(Object.assign({}, h), { sourceDataType: "content" }))) } catch (o) { if (this._pendingLoads--, this._removed) return void this.fire(new c.l("dataabort", { dataType: "source" })); this.fire(new c.k(o)) } }) } loaded() { return this._pendingLoads === 0 } loadTile(e) { return c._(this, void 0, void 0, function* () { const i = e.actor ? "RT" : "LT"; e.actor = this.actor; const o = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity }; e.abortController = new AbortController; const a = yield this.actor.sendAsync({ type: i, data: o }, e.abortController); delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(a, this.map.painter, i === "RT") }) } abortTile(e) { return c._(this, void 0, void 0, function* () { e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0 }) } unloadTile(e) { return c._(this, void 0, void 0, function* () { e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }) }) } onRemove() { this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } }) } serialize() { return c.e({}, this._options, { type: this.type, data: this._data }) } hasTransition() { return !1 } } class qe extends c.E { constructor(e, i, o, a) { super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = o, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(a), this.options = i } load(e) { return c._(this, void 0, void 0, function* () { this._loaded = !1, this.fire(new c.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController; try { const i = yield ot.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request); this._request = null, this._loaded = !0, i && i.data && (this.image = i.data, e && (this.coordinates = e), this._finishLoading()) } catch (i) { this._request = null, this._loaded = !0, this.fire(new c.k(i)) } }) } loaded() { return this._loaded } updateImage(e) { return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally(() => { this.texture = null }), this) : this } _finishLoading() { this.map && (this.setCoordinates(this.coordinates), this.fire(new c.l("data", { dataType: "source", sourceDataType: "metadata" }))) } onAdd(e) { this.map = e, this.load() } onRemove() { this._request && (this._request.abort(), this._request = null) } setCoordinates(e) { this.coordinates = e; const i = e.map(c.$.fromLngLat); var o; return this.tileID = function (a) { let h = 1 / 0, f = 1 / 0, g = -1 / 0, v = -1 / 0; for (const A of a) h = Math.min(h, A.x), f = Math.min(f, A.y), g = Math.max(g, A.x), v = Math.max(v, A.y); const w = Math.max(g - h, v - f), I = Math.max(0, Math.floor(-Math.log(w) / Math.LN2)), E = Math.pow(2, I); return new c.a0(I, Math.floor((h + g) / 2 * E), Math.floor((f + v) / 2 * E)) }(i), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i.map(a => this.tileID.getTilePoint(a)._round()), this.flippedWindingOrder = ((o = this.tileCoords)[1].x - o[0].x) * (o[2].y - o[0].y) - (o[1].y - o[0].y) * (o[2].x - o[0].x) < 0, this.fire(new c.l("data", { dataType: "source", sourceDataType: "content" })), this } prepare() { if (Object.keys(this.tiles).length === 0 || !this.image) return; const e = this.map.painter.context, i = e.gl; this.texture || (this.texture = new Nt(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)); let o = !1; for (const a in this.tiles) { const h = this.tiles[a]; h.state !== "loaded" && (h.state = "loaded", h.texture = this.texture, o = !0) } o && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id })) } loadTile(e) { return c._(this, void 0, void 0, function* () { this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored" }) } serialize() { return { type: "image", url: this.options.url, coordinates: this.coordinates } } hasTransition() { return !1 } } class Ve extends qe { constructor(e, i, o, a) { super(e, i, o, a), this.roundZoom = !0, this.type = "video", this.options = i } load() { return c._(this, void 0, void 0, function* () { this._loaded = !1; const e = this.options; this.urls = []; for (const i of e.urls) this.urls.push(this.map._requestManager.transformRequest(i, "Source").url); try { const i = yield c.a1(this.urls); if (this._loaded = !0, !i) return; this.video = i, this.video.loop = !0, this.video.addEventListener("playing", () => { this.map.triggerRepaint() }), this.map && this.video.play(), this._finishLoading() } catch (i) { this.fire(new c.k(i)) } }) } pause() { this.video && this.video.pause() } play() { this.video && this.video.play() } seek(e) { if (this.video) { const i = this.video.seekable; e < i.start(0) || e > i.end(0) ? this.fire(new c.k(new c.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e } } getVideo() { return this.video } onAdd(e) { this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates))) } prepare() { if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return; const e = this.map.painter.context, i = e.gl; this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new Nt(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)); let o = !1; for (const a in this.tiles) { const h = this.tiles[a]; h.state !== "loaded" && (h.state = "loaded", h.texture = this.texture, o = !0) } o && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id })) } serialize() { return { type: "video", urls: this.urls, coordinates: this.coordinates } } hasTransition() { return this.video && !this.video.paused } } class dt extends qe { constructor(e, i, o, a) { super(e, i, o, a), i.coordinates ? Array.isArray(i.coordinates) && i.coordinates.length === 4 && !i.coordinates.some(h => !Array.isArray(h) || h.length !== 2 || h.some(f => typeof f != "number")) || this.fire(new c.k(new c.a2(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new c.k(new c.a2(`sources.${e}`, null, 'missing required property "coordinates"'))), i.animate && typeof i.animate != "boolean" && this.fire(new c.k(new c.a2(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? typeof i.canvas == "string" || i.canvas instanceof HTMLCanvasElement || this.fire(new c.k(new c.a2(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new c.k(new c.a2(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = i.animate === void 0 || i.animate } load() { return c._(this, void 0, void 0, function* () { this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new c.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () { this._playing = !0, this.map.triggerRepaint() }, this.pause = function () { this._playing && (this.prepare(), this._playing = !1) }, this._finishLoading()) }) } getCanvas() { return this.canvas } onAdd(e) { this.map = e, this.load(), this.canvas && this.animate && this.play() } onRemove() { this.pause() } prepare() { let e = !1; if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return; const i = this.map.painter.context, o = i.gl; this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new Nt(i, this.canvas, o.RGBA, { premultiply: !0 }); let a = !1; for (const h in this.tiles) { const f = this.tiles[h]; f.state !== "loaded" && (f.state = "loaded", f.texture = this.texture, a = !0) } a && this.fire(new c.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id })) } serialize() { return { type: "canvas", coordinates: this.coordinates } } hasTransition() { return this._playing } _hasInvalidDimensions() { for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0; return !1 } } const Ke = {}, ct = u => { switch (u) { case "geojson": return We; case "image": return qe; case "raster": return Oe; case "raster-dem": return Xe; case "vector": return Be; case "video": return Ve; case "canvas": return dt }return Ke[u] }, mt = "RTLPluginLoaded"; class vt extends c.E { constructor() { super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = Gr() } _syncState(e) { return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch(i => { throw this.status = "error", i }) } getRTLTextPluginStatus() { return this.status } clearRTLTextPlugin() { this.status = "unavailable", this.url = null } setRTLTextPlugin(e) { return c._(this, arguments, void 0, function* (i, o = !1) { if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times."); if (this.url = Le.resolveURL(i), !this.url) throw new Error(`requested url ${i} is invalid`); if (this.status === "unavailable") { if (!o) return this._requestImport(); this.status = "deferred", this._syncState(this.status) } else if (this.status === "requested") return this._requestImport() }) } _requestImport() { return c._(this, void 0, void 0, function* () { yield this._syncState("loading"), this.status = "loaded", this.fire(new c.l(mt)) }) } lazyLoad() { this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport() } } let At = null; function Pt() { return At || (At = new vt), At } class mi { constructor(e, i) { this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = c.a3(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading" } registerFadeDuration(e) { const i = e + this.timeAdded; i < this.fadeEndTime || (this.fadeEndTime = i) } wasRequested() { return this.state === "errored" || this.state === "loaded" || this.state === "reloading" } clearTextures(e) { this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null } loadVectorData(e, i, o) { if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) { e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function (a, h) { const f = {}; if (!h) return f; for (const g of a) { const v = g.layerIds.map(w => h.getLayer(w)).filter(Boolean); if (v.length !== 0) { g.layers = v, g.stateDependentLayerIds && (g.stateDependentLayers = g.stateDependentLayerIds.map(w => v.filter(I => I.id === w)[0])); for (const w of v) f[w.id] = g } } return f }(e.buckets, i == null ? void 0 : i.style), this.hasSymbolBuckets = !1; for (const a in this.buckets) { const h = this.buckets[a]; if (h instanceof c.a5) { if (this.hasSymbolBuckets = !0, !o) break; h.justReloaded = !0 } } if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const a in this.buckets) { const h = this.buckets[a]; if (h instanceof c.a5 && h.hasRTLText) { this.hasRTLText = !0, Pt().lazyLoad(); break } } this.queryPadding = 0; for (const a in this.buckets) { const h = this.buckets[a]; this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(a).queryRadius(h)) } e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage) } else this.collisionBoxArray = new c.a4 } unloadVectorData() { for (const e in this.buckets) this.buckets[e].destroy(); this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded" } getBucket(e) { return this.buckets[e.id] } upload(e) { for (const o in this.buckets) { const a = this.buckets[o]; a.uploadPending() && a.upload(e) } const i = e.gl; this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Nt(e, this.imageAtlas.image, i.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new Nt(e, this.glyphAtlasImage, i.ALPHA), this.glyphAtlasImage = null) } prepare(e) { this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture) } queryRenderedFeatures(e, i, o, a, h, f, g, v, w, I) { return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: a, cameraQueryGeometry: h, scale: f, tileSize: this.tileSize, pixelPosMatrix: I, transform: v, params: g, queryPadding: this.queryPadding * w }, e, i, o) : {} } querySourceFeatures(e, i) { const o = this.latestFeatureIndex; if (!o || !o.rawTileData) return; const a = o.loadVTLayers(), h = i && i.sourceLayer ? i.sourceLayer : "", f = a._geojsonTileLayer || a[h]; if (!f) return; const g = c.a6(i && i.filter), { z: v, x: w, y: I } = this.tileID.canonical, E = { z: v, x: w, y: I }; for (let A = 0; A < f.length; A++) { const B = f.feature(A); if (g.needGeometry) { const G = c.a7(B, !0); if (!g.filter(new c.C(this.tileID.overscaledZ), G, this.tileID.canonical)) continue } else if (!g.filter(new c.C(this.tileID.overscaledZ), B)) continue; const j = o.getId(B, h), q = new c.a8(B, v, w, I, j); q.tile = E, e.push(q) } } hasData() { return this.state === "loaded" || this.state === "reloading" || this.state === "expired" } patternsLoaded() { return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length } setExpiryData(e) { const i = this.expirationTime; if (e.cacheControl) { const o = c.a9(e.cacheControl); o["max-age"] && (this.expirationTime = Date.now() + 1e3 * o["max-age"]) } else e.expires && (this.expirationTime = new Date(e.expires).getTime()); if (this.expirationTime) { const o = Date.now(); let a = !1; if (this.expirationTime > o) a = !1; else if (i) if (this.expirationTime < i) a = !0; else { const h = this.expirationTime - i; h ? this.expirationTime = o + Math.max(h, 3e4) : a = !0 } else a = !0; a ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0 } } getExpiryTimeout() { if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1) } setFeatureState(e, i) { if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return; const o = this.latestFeatureIndex.loadVTLayers(); for (const a in this.buckets) { if (!i.style.hasLayer(a)) continue; const h = this.buckets[a], f = h.layers[0].sourceLayer || "_geojsonTileLayer", g = o[f], v = e[f]; if (!g || !v || Object.keys(v).length === 0) continue; h.update(v, g, this.imageAtlas && this.imageAtlas.patternPositions || {}); const w = i && i.style && i.style.getLayer(a); w && (this.queryPadding = Math.max(this.queryPadding, w.queryRadius(h))) } } holdingForFade() { return this.symbolFadeHoldUntil !== void 0 } symbolFadeFinished() { return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Le.now() } clearFadeHold() { this.symbolFadeHoldUntil = void 0 } setHoldDuration(e) { this.symbolFadeHoldUntil = Le.now() + e } setDependencies(e, i) { const o = {}; for (const a of i) o[a] = !0; this.dependencies[e] = o } hasDependency(e, i) { for (const o of e) { const a = this.dependencies[o]; if (a) { for (const h of i) if (a[h]) return !0 } } return !1 } } class ui { constructor(e, i) { this.max = e, this.onRemove = i, this.reset() } reset() { for (const e in this.data) for (const i of this.data[e]) i.timeout && clearTimeout(i.timeout), this.onRemove(i.value); return this.data = {}, this.order = [], this } add(e, i, o) { const a = e.wrapped().key; this.data[a] === void 0 && (this.data[a] = []); const h = { value: i, timeout: void 0 }; if (o !== void 0 && (h.timeout = setTimeout(() => { this.remove(e, h) }, o)), this.data[a].push(h), this.order.push(a), this.order.length > this.max) { const f = this._getAndRemoveByKey(this.order[0]); f && this.onRemove(f) } return this } has(e) { return e.wrapped().key in this.data } getAndRemove(e) { return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null } _getAndRemoveByKey(e) { const i = this.data[e].shift(); return i.timeout && clearTimeout(i.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), i.value } getByKey(e) { const i = this.data[e]; return i ? i[0].value : null } get(e) { return this.has(e) ? this.data[e.wrapped().key][0].value : null } remove(e, i) { if (!this.has(e)) return this; const o = e.wrapped().key, a = i === void 0 ? 0 : this.data[o].indexOf(i), h = this.data[o][a]; return this.data[o].splice(a, 1), h.timeout && clearTimeout(h.timeout), this.data[o].length === 0 && delete this.data[o], this.onRemove(h.value), this.order.splice(this.order.indexOf(o), 1), this } setMaxSize(e) { for (this.max = e; this.order.length > this.max;) { const i = this._getAndRemoveByKey(this.order[0]); i && this.onRemove(i) } return this } filter(e) { const i = []; for (const o in this.data) for (const a of this.data[o]) e(a.value) || i.push(a); for (const o of i) this.remove(o.value.tileID, o) } } class Ji { constructor() { this.state = {}, this.stateChanges = {}, this.deletedStates = {} } updateState(e, i, o) { const a = String(i); if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][a] = this.stateChanges[e][a] || {}, c.e(this.stateChanges[e][a], o), this.deletedStates[e] === null) { this.deletedStates[e] = {}; for (const h in this.state[e]) h !== a && (this.deletedStates[e][h] = null) } else if (this.deletedStates[e] && this.deletedStates[e][a] === null) { this.deletedStates[e][a] = {}; for (const h in this.state[e][a]) o[h] || (this.deletedStates[e][a][h] = null) } else for (const h in o) this.deletedStates[e] && this.deletedStates[e][a] && this.deletedStates[e][a][h] === null && delete this.deletedStates[e][a][h] } removeFeatureState(e, i, o) { if (this.deletedStates[e] === null) return; const a = String(i); if (this.deletedStates[e] = this.deletedStates[e] || {}, o && i !== void 0) this.deletedStates[e][a] !== null && (this.deletedStates[e][a] = this.deletedStates[e][a] || {}, this.deletedStates[e][a][o] = null); else if (i !== void 0) if (this.stateChanges[e] && this.stateChanges[e][a]) for (o in this.deletedStates[e][a] = {}, this.stateChanges[e][a]) this.deletedStates[e][a][o] = null; else this.deletedStates[e][a] = null; else this.deletedStates[e] = null } getState(e, i) { const o = String(i), a = c.e({}, (this.state[e] || {})[o], (this.stateChanges[e] || {})[o]); if (this.deletedStates[e] === null) return {}; if (this.deletedStates[e]) { const h = this.deletedStates[e][i]; if (h === null) return {}; for (const f in h) delete a[f] } return a } initializeTileState(e, i) { e.setFeatureState(this.state, i) } coalesceChanges(e, i) { const o = {}; for (const a in this.stateChanges) { this.state[a] = this.state[a] || {}; const h = {}; for (const f in this.stateChanges[a]) this.state[a][f] || (this.state[a][f] = {}), c.e(this.state[a][f], this.stateChanges[a][f]), h[f] = this.state[a][f]; o[a] = h } for (const a in this.deletedStates) { this.state[a] = this.state[a] || {}; const h = {}; if (this.deletedStates[a] === null) for (const f in this.state[a]) h[f] = {}, this.state[a][f] = {}; else for (const f in this.deletedStates[a]) { if (this.deletedStates[a][f] === null) this.state[a][f] = {}; else for (const g of Object.keys(this.deletedStates[a][f])) delete this.state[a][f][g]; h[f] = this.state[a][f] } o[a] = o[a] || {}, c.e(o[a], h) } if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(o).length !== 0) for (const a in e) e[a].setFeatureState(o, i) } } function $i(u, e, i) { const o = e.intersectsFrustum(u); if (!i) return o; const a = e.intersectsPlane(i); return o === 0 || a === 0 ? 0 : o === 2 && a === 2 ? 2 : 1 } function Hr(u, e, i, o, a) { let h = u; const f = Math.atan(e / i), g = Math.hypot(e, i); return h = u + c.aa(o / g / Math.max(.5, Math.cos(c.ac(a / 2)))), h += 1 * c.aa(Math.cos(f)) / 2, h += c.ad(u - h, -0, 0), h } function Rr(u, e) { const i = (e.roundZoom ? Math.round : Math.floor)(u.zoom + c.aa(u.tileSize / e.tileSize)); return Math.max(0, i) } function ue(u, e) { const i = u.getCameraFrustum(), o = u.getClippingPlane(), a = u.screenPointToMercatorCoordinate(u.getCameraPoint()), h = c.$.fromLngLat(u.center, u.elevation); a.z = h.z + Math.cos(u.pitchInRadians) * u.cameraToCenterDistance / u.worldSize; const f = u.getCoveringTilesDetailsProvider(), g = f.allowVariableZoom(u, e), v = Rr(u, e), w = e.minzoom || 0, I = e.maxzoom !== void 0 ? e.maxzoom : u.maxZoom, E = Math.min(Math.max(0, v), I), A = Math.pow(2, E), B = [A * a.x, A * a.y, 0], j = [A * h.x, A * h.y, 0], q = Math.hypot(h.x - a.x, h.y - a.y), G = Math.abs(h.z - a.z), H = Math.hypot(q, G), K = re => ({ zoom: 0, x: 0, y: 0, wrap: re, fullyVisible: !1 }), Q = [], ee = []; if (u.renderWorldCopies && f.allowWorldCopies()) for (let re = 1; re <= 3; re++)Q.push(K(-re)), Q.push(K(re)); for (Q.push(K(0)); Q.length > 0;) { const re = Q.pop(), oe = re.x, ne = re.y; let me = re.fullyVisible; const ge = { x: oe, y: ne, z: re.zoom }, Se = f.getTileAABB(ge, re.wrap, u.elevation, e); if (!me) { const Ue = $i(i, Se, o); if (Ue === 0) continue; me = Ue === 2 } const Ie = f.distanceToTile2d(a.x, a.y, ge, Se); let Pe = v; g && (Pe = (e.calculateTileZoom || Hr)(u.zoom + c.aa(u.tileSize / e.tileSize), Ie, G, H, u.fov)), Pe = (e.roundZoom ? Math.round : Math.floor)(Pe), Pe = Math.max(0, Pe); const $e = Math.min(Pe, I); if (re.wrap = f.getWrap(h, ge, re.wrap), re.zoom >= $e) { if (re.zoom < w) continue; const Ue = E - re.zoom, De = B[0] - .5 - (oe << Ue), tt = B[1] - .5 - (ne << Ue), st = e.reparseOverscaled ? Math.max(re.zoom, Pe) : re.zoom; ee.push({ tileID: new c.Y(re.zoom === I ? st : re.zoom, re.wrap, re.zoom, oe, ne), distanceSq: c.ab([j[0] - .5 - oe, j[1] - .5 - ne]), tileDistanceToCamera: Math.sqrt(De * De + tt * tt) }) } else for (let Ue = 0; Ue < 4; Ue++)Q.push({ zoom: re.zoom + 1, x: (oe << 1) + Ue % 2, y: (ne << 1) + (Ue >> 1), wrap: re.wrap, fullyVisible: me }) } return ee.sort((re, oe) => re.distanceSq - oe.distanceSq).map(re => re.tileID) } class C extends c.E { constructor(e, i, o) { super(), this.id = e, this.dispatcher = o, this.on("data", a => this._dataHandler(a)), this.on("dataloading", () => { this._sourceErrored = !1 }), this.on("error", () => { this._sourceErrored = this._source.loaded() }), this._source = ((a, h, f, g) => { const v = new (ct(h.type))(a, h, f, g); if (v.id !== a) throw new Error(`Expected Source id to be ${a} instead of ${v.id}`); return v })(e, i, o, this), this._tiles = {}, this._cache = new ui(0, a => this._unloadTile(a)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Ji, this._didEmitContent = !1, this._updated = !1 } onAdd(e) { this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e) } onRemove(e) { this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e) } loaded() { if (this._sourceErrored) return !0; if (!this._sourceLoaded || !this._source.loaded()) return !1; if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0; if (!this._updated) return !1; for (const e in this._tiles) { const i = this._tiles[e]; if (i.state !== "loaded" && i.state !== "errored") return !1 } return !0 } getSource() { return this._source } pause() { this._paused = !0 } resume() { if (!this._paused) return; const e = this._shouldReloadOnResume; this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain) } _loadTile(e, i, o) { return c._(this, void 0, void 0, function* () { try { yield this._source.loadTile(e), this._tileLoaded(e, i, o) } catch (a) { e.state = "errored", a.status !== 404 ? this._source.fire(new c.k(a, { tile: e })) : this.update(this.transform, this.terrain) } }) } _unloadTile(e) { this._source.unloadTile && this._source.unloadTile(e) } _abortTile(e) { this._source.abortTile && this._source.abortTile(e), this._source.fire(new c.l("dataabort", { tile: e, coord: e.tileID, dataType: "source" })) } serialize() { return this._source.serialize() } prepare(e) { this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null); for (const i in this._tiles) { const o = this._tiles[i]; o.upload(e), o.prepare(this.map.style.imageManager) } } getIds() { return Object.values(this._tiles).map(e => e.tileID).sort(V).map(e => e.key) } getRenderableIds(e) { const i = []; for (const o in this._tiles) this._isIdRenderable(o, e) && i.push(this._tiles[o]); return e ? i.sort((o, a) => { const h = o.tileID, f = a.tileID, g = new c.P(h.canonical.x, h.canonical.y)._rotate(-this.transform.bearingInRadians), v = new c.P(f.canonical.x, f.canonical.y)._rotate(-this.transform.bearingInRadians); return h.overscaledZ - f.overscaledZ || v.y - g.y || v.x - g.x }).map(o => o.tileID.key) : i.map(o => o.tileID).sort(V).map(o => o.key) } hasRenderableParent(e) { const i = this.findLoadedParent(e, 0); return !!i && this._isIdRenderable(i.tileID.key) } _isIdRenderable(e, i) { return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (i || !this._tiles[e].holdingForFade()) } reload(e) { if (this._paused) this._shouldReloadOnResume = !0; else { this._cache.reset(); for (const i in this._tiles) (e || this._tiles[i].state !== "errored") && this._reloadTile(i, "reloading") } } _reloadTile(e, i) { return c._(this, void 0, void 0, function* () { const o = this._tiles[e]; o && (o.state !== "loading" && (o.state = i), yield this._loadTile(o, e, i)) }) } _tileLoaded(e, i, o) { e.timeAdded = Le.now(), o === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new c.l("data", { dataType: "source", tile: e, coord: e.tileID })) } _backfillDEM(e) { const i = this.getRenderableIds(); for (let a = 0; a < i.length; a++) { const h = i[a]; if (e.neighboringTiles && e.neighboringTiles[h]) { const f = this.getTileByID(h); o(e, f), o(f, e) } } function o(a, h) { a.needsHillshadePrepare = !0, a.needsTerrainPrepare = !0; let f = h.tileID.canonical.x - a.tileID.canonical.x; const g = h.tileID.canonical.y - a.tileID.canonical.y, v = Math.pow(2, a.tileID.canonical.z), w = h.tileID.key; f === 0 && g === 0 || Math.abs(g) > 1 || (Math.abs(f) > 1 && (Math.abs(f + v) === 1 ? f += v : Math.abs(f - v) === 1 && (f -= v)), h.dem && a.dem && (a.dem.backfillBorder(h.dem, f, g), a.neighboringTiles && a.neighboringTiles[w] && (a.neighboringTiles[w].backfilled = !0))) } } getTile(e) { return this.getTileByID(e.key) } getTileByID(e) { return this._tiles[e] } _retainLoadedChildren(e, i, o, a) { for (const h in this._tiles) { let f = this._tiles[h]; if (a[h] || !f.hasData() || f.tileID.overscaledZ <= i || f.tileID.overscaledZ > o) continue; let g = f.tileID; for (; f && f.tileID.overscaledZ > i + 1;) { const w = f.tileID.scaledTo(f.tileID.overscaledZ - 1); f = this._tiles[w.key], f && f.hasData() && (g = w) } let v = g; for (; v.overscaledZ > i;)if (v = v.scaledTo(v.overscaledZ - 1), e[v.key] || e[v.canonical.key]) { a[g.key] = g; break } } } findLoadedParent(e, i) { if (e.key in this._loadedParentTiles) { const o = this._loadedParentTiles[e.key]; return o && o.tileID.overscaledZ >= i ? o : null } for (let o = e.overscaledZ - 1; o >= i; o--) { const a = e.scaledTo(o), h = this._getLoadedTile(a); if (h) return h } } findLoadedSibling(e) { return this._getLoadedTile(e) } _getLoadedTile(e) { const i = this._tiles[e.key]; return i && i.hasData() ? i : this._cache.getByKey(e.wrapped().key) } updateCacheSize(e) { const i = Math.ceil(e.width / this._source.tileSize) + 1, o = Math.ceil(e.height / this._source.tileSize) + 1, a = Math.floor(i * o * (this._maxTileCacheZoomLevels === null ? c.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), h = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, a) : a; this._cache.setMaxSize(h) } handleWrapJump(e) { const i = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360); if (this._prevLng = e, i) { const o = {}; for (const a in this._tiles) { const h = this._tiles[a]; h.tileID = h.tileID.unwrapTo(h.tileID.wrap + i), o[h.tileID.key] = h } this._tiles = o; for (const a in this._timers) clearTimeout(this._timers[a]), delete this._timers[a]; for (const a in this._tiles) this._setTileReloadTimer(a, this._tiles[a]) } } _updateCoveredAndRetainedTiles(e, i, o, a, h, f) { const g = {}, v = {}, w = Object.keys(e), I = Le.now(); for (const E of w) { const A = e[E], B = this._tiles[E]; if (!B || B.fadeEndTime !== 0 && B.fadeEndTime <= I) continue; const j = this.findLoadedParent(A, i), q = this.findLoadedSibling(A), G = j || q || null; G && (this._addTile(G.tileID), g[G.tileID.key] = G.tileID), v[E] = A } this._retainLoadedChildren(v, a, o, e); for (const E in g) e[E] || (this._coveredTiles[E] = !0, e[E] = g[E]); if (f) { const E = {}, A = {}; for (const B of h) this._tiles[B.key].hasData() ? E[B.key] = B : A[B.key] = B; for (const B in A) { const j = A[B].children(this._source.maxzoom); this._tiles[j[0].key] && this._tiles[j[1].key] && this._tiles[j[2].key] && this._tiles[j[3].key] && (E[j[0].key] = e[j[0].key] = j[0], E[j[1].key] = e[j[1].key] = j[1], E[j[2].key] = e[j[2].key] = j[2], E[j[3].key] = e[j[3].key] = j[3], delete A[B]) } for (const B in A) { const j = A[B], q = this.findLoadedParent(j, this._source.minzoom), G = this.findLoadedSibling(j), H = q || G || null; if (H) { E[H.tileID.key] = e[H.tileID.key] = H.tileID; for (const K in E) E[K].isChildOf(H.tileID) && delete E[K] } } for (const B in this._tiles) E[B] || (this._coveredTiles[B] = !0) } } update(e, i) { if (!this._sourceLoaded || this._paused) return; let o; this.transform = e, this.terrain = i, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? o = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(I => new c.Y(I.canonical.z, I.wrap, I.canonical.z, I.canonical.x, I.canonical.y)) : (o = ue(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (o = o.filter(I => this._source.hasTile(I)))) : o = []; const a = Rr(e, this._source), h = Math.max(a - C.maxOverzooming, this._source.minzoom), f = Math.max(a + C.maxUnderzooming, this._source.minzoom); if (this.usedForTerrain) { const I = {}; for (const E of o) if (E.canonical.z > this._source.minzoom) { const A = E.scaledTo(E.canonical.z - 1); I[A.key] = A; const B = E.scaledTo(Math.max(this._source.minzoom, Math.min(E.canonical.z, 5))); I[B.key] = B } o = o.concat(Object.values(I)) } const g = o.length === 0 && !this._updated && this._didEmitContent; this._updated = !0, g && this.fire(new c.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id })); const v = this._updateRetainedTiles(o, a); $(this._source.type) && this._updateCoveredAndRetainedTiles(v, h, f, a, o, i); for (const I in v) this._tiles[I].clearFadeHold(); const w = c.ae(this._tiles, v); for (const I of w) { const E = this._tiles[I]; E.hasSymbolBuckets && !E.holdingForFade() ? E.setHoldDuration(this.map._fadeDuration) : E.hasSymbolBuckets && !E.symbolFadeFinished() || this._removeTile(I) } this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache() } releaseSymbolFadeTiles() { for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e) } _updateRetainedTiles(e, i) { var o; const a = {}, h = {}, f = Math.max(i - C.maxOverzooming, this._source.minzoom), g = Math.max(i + C.maxUnderzooming, this._source.minzoom), v = {}; for (const w of e) { const I = this._addTile(w); a[w.key] = w, I.hasData() || i < this._source.maxzoom && (v[w.key] = w) } this._retainLoadedChildren(v, i, g, a); for (const w of e) { let I = this._tiles[w.key]; if (I.hasData()) continue; if (i + 1 > this._source.maxzoom) { const A = w.children(this._source.maxzoom)[0], B = this.getTile(A); if (B && B.hasData()) { a[A.key] = A; continue } } else { const A = w.children(this._source.maxzoom); if (a[A[0].key] && a[A[1].key] && a[A[2].key] && a[A[3].key]) continue } let E = I.wasRequested(); for (let A = w.overscaledZ - 1; A >= f; --A) { const B = w.scaledTo(A); if (h[B.key]) break; if (h[B.key] = !0, I = this.getTile(B), !I && E && (I = this._addTile(B)), I) { const j = I.hasData(); if ((j || !(!((o = this.map) === null || o === void 0) && o.cancelPendingTileRequestsWhileZooming) || E) && (a[B.key] = B), E = I.wasRequested(), j) break } } } return a } _updateLoadedParentTileCache() { this._loadedParentTiles = {}; for (const e in this._tiles) { const i = []; let o, a = this._tiles[e].tileID; for (; a.overscaledZ > 0;) { if (a.key in this._loadedParentTiles) { o = this._loadedParentTiles[a.key]; break } i.push(a.key); const h = a.scaledTo(a.overscaledZ - 1); if (o = this._getLoadedTile(h), o) break; a = h } for (const h of i) this._loadedParentTiles[h] = o } } _updateLoadedSiblingTileCache() { this._loadedSiblingTiles = {}; for (const e in this._tiles) { const i = this._tiles[e].tileID, o = this._getLoadedTile(i); this._loadedSiblingTiles[i.key] = o } } _addTile(e) { let i = this._tiles[e.key]; if (i) return i; i = this._cache.getAndRemove(e), i && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i))); const o = i; return i || (i = new mi(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, e.key, i.state)), i.uses++, this._tiles[e.key] = i, o || this._source.fire(new c.l("dataloading", { tile: i, coord: i.tileID, dataType: "source" })), i } _setTileReloadTimer(e, i) { e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]); const o = i.getExpiryTimeout(); o && (this._timers[e] = setTimeout(() => { this._reloadTile(e, "expired"), delete this._timers[e] }, o)) } _removeTile(e) { const i = this._tiles[e]; i && (i.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), i.uses > 0 || (i.hasData() && i.state !== "reloading" ? this._cache.add(i.tileID, i, i.getExpiryTimeout()) : (i.aborted = !0, this._abortTile(i), this._unloadTile(i)))) } _dataHandler(e) { const i = e.sourceDataType; e.dataType === "source" && i === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && e.dataType === "source" && i === "content" && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0) } clearTiles() { this._shouldReloadOnResume = !1, this._paused = !1; for (const e in this._tiles) this._removeTile(e); this._cache.reset() } tilesIn(e, i, o) { const a = [], h = this.transform; if (!h) return a; const f = o ? h.getCameraQueryGeometry(e) : e, g = e.map(j => h.screenPointToMercatorCoordinate(j, this.terrain)), v = f.map(j => h.screenPointToMercatorCoordinate(j, this.terrain)), w = this.getIds(); let I = 1 / 0, E = 1 / 0, A = -1 / 0, B = -1 / 0; for (const j of v) I = Math.min(I, j.x), E = Math.min(E, j.y), A = Math.max(A, j.x), B = Math.max(B, j.y); for (let j = 0; j < w.length; j++) { const q = this._tiles[w[j]]; if (q.holdingForFade()) continue; const G = q.tileID, H = Math.pow(2, h.zoom - q.tileID.overscaledZ), K = i * q.queryPadding * c.Z / q.tileSize / H, Q = [G.getTilePoint(new c.$(I, E)), G.getTilePoint(new c.$(A, B))]; if (Q[0].x - K < c.Z && Q[0].y - K < c.Z && Q[1].x + K >= 0 && Q[1].y + K >= 0) { const ee = g.map(oe => G.getTilePoint(oe)), re = v.map(oe => G.getTilePoint(oe)); a.push({ tile: q, tileID: G, queryGeometry: ee, cameraQueryGeometry: re, scale: H }) } } return a } getVisibleCoordinates(e) { const i = this.getRenderableIds(e).map(o => this._tiles[o].tileID); return this.transform && this.transform.populateCache(i), i } hasTransition() { if (this._source.hasTransition()) return !0; if ($(this._source.type)) { const e = Le.now(); for (const i in this._tiles) if (this._tiles[i].fadeEndTime >= e) return !0 } return !1 } setFeatureState(e, i, o) { this._state.updateState(e = e || "_geojsonTileLayer", i, o) } removeFeatureState(e, i, o) { this._state.removeFeatureState(e = e || "_geojsonTileLayer", i, o) } getFeatureState(e, i) { return this._state.getState(e = e || "_geojsonTileLayer", i) } setDependencies(e, i, o) { const a = this._tiles[e]; a && a.setDependencies(i, o) } reloadTilesForDependencies(e, i) { for (const o in this._tiles) this._tiles[o].hasDependency(e, i) && this._reloadTile(o, "reloading"); this._cache.filter(o => !o.hasDependency(e, i)) } } function V(u, e) { const i = Math.abs(2 * u.wrap) - +(u.wrap < 0), o = Math.abs(2 * e.wrap) - +(e.wrap < 0); return u.overscaledZ - e.overscaledZ || o - i || e.canonical.y - u.canonical.y || e.canonical.x - u.canonical.x } function $(u) { return u === "raster" || u === "image" || u === "video" } C.maxOverzooming = 10, C.maxUnderzooming = 3; class X { constructor(e, i) { this.reset(e, i) } reset(e, i) { this.points = e || [], this._distances = [0]; for (let o = 1; o < this.points.length; o++)this._distances[o] = this._distances[o - 1] + this.points[o].dist(this.points[o - 1]); this.length = this._distances[this._distances.length - 1], this.padding = Math.min(i || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding } lerp(e) { if (this.points.length === 1) return this.points[0]; e = c.ad(e, 0, 1); let i = 1, o = this._distances[i]; const a = e * this.paddedLength + this.padding; for (; o < a && i < this._distances.length;)o = this._distances[++i]; const h = i - 1, f = this._distances[h], g = o - f, v = g > 0 ? (a - f) / g : 0; return this.points[h].mult(1 - v).add(this.points[i].mult(v)) } } function ie(u, e) { let i = !0; return u === "always" || u !== "never" && e !== "never" || (i = !1), i } class he { constructor(e, i, o) { const a = this.boxCells = [], h = this.circleCells = []; this.xCellCount = Math.ceil(e / o), this.yCellCount = Math.ceil(i / o); for (let f = 0; f < this.xCellCount * this.yCellCount; f++)a.push([]), h.push([]); this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = i, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / i, this.boxUid = 0, this.circleUid = 0 } keysLength() { return this.boxKeys.length + this.circleKeys.length } insert(e, i, o, a, h) { this._forEachCell(i, o, a, h, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(a), this.bboxes.push(h) } insertCircle(e, i, o, a) { this._forEachCell(i - a, o - a, i + a, o + a, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(i), this.circles.push(o), this.circles.push(a) } _insertBoxCell(e, i, o, a, h, f) { this.boxCells[h].push(f) } _insertCircleCell(e, i, o, a, h, f) { this.circleCells[h].push(f) } _query(e, i, o, a, h, f, g) { if (o < 0 || e > this.width || a < 0 || i > this.height) return []; const v = []; if (e <= 0 && i <= 0 && this.width <= o && this.height <= a) { if (h) return [{ key: null, x1: e, y1: i, x2: o, y2: a }]; for (let w = 0; w < this.boxKeys.length; w++)v.push({ key: this.boxKeys[w], x1: this.bboxes[4 * w], y1: this.bboxes[4 * w + 1], x2: this.bboxes[4 * w + 2], y2: this.bboxes[4 * w + 3] }); for (let w = 0; w < this.circleKeys.length; w++) { const I = this.circles[3 * w], E = this.circles[3 * w + 1], A = this.circles[3 * w + 2]; v.push({ key: this.circleKeys[w], x1: I - A, y1: E - A, x2: I + A, y2: E + A }) } } else this._forEachCell(e, i, o, a, this._queryCell, v, { hitTest: h, overlapMode: f, seenUids: { box: {}, circle: {} } }, g); return v } query(e, i, o, a) { return this._query(e, i, o, a, !1, null) } hitTest(e, i, o, a, h, f) { return this._query(e, i, o, a, !0, h, f).length > 0 } hitTestCircle(e, i, o, a, h) { const f = e - o, g = e + o, v = i - o, w = i + o; if (g < 0 || f > this.width || w < 0 || v > this.height) return !1; const I = []; return this._forEachCell(f, v, g, w, this._queryCellCircle, I, { hitTest: !0, overlapMode: a, circle: { x: e, y: i, radius: o }, seenUids: { box: {}, circle: {} } }, h), I.length > 0 } _queryCell(e, i, o, a, h, f, g, v) { const { seenUids: w, hitTest: I, overlapMode: E } = g, A = this.boxCells[h]; if (A !== null) { const j = this.bboxes; for (const q of A) if (!w.box[q]) { w.box[q] = !0; const G = 4 * q, H = this.boxKeys[q]; if (e <= j[G + 2] && i <= j[G + 3] && o >= j[G + 0] && a >= j[G + 1] && (!v || v(H)) && (!I || !ie(E, H.overlapMode)) && (f.push({ key: H, x1: j[G], y1: j[G + 1], x2: j[G + 2], y2: j[G + 3] }), I)) return !0 } } const B = this.circleCells[h]; if (B !== null) { const j = this.circles; for (const q of B) if (!w.circle[q]) { w.circle[q] = !0; const G = 3 * q, H = this.circleKeys[q]; if (this._circleAndRectCollide(j[G], j[G + 1], j[G + 2], e, i, o, a) && (!v || v(H)) && (!I || !ie(E, H.overlapMode))) { const K = j[G], Q = j[G + 1], ee = j[G + 2]; if (f.push({ key: H, x1: K - ee, y1: Q - ee, x2: K + ee, y2: Q + ee }), I) return !0 } } } return !1 } _queryCellCircle(e, i, o, a, h, f, g, v) { const { circle: w, seenUids: I, overlapMode: E } = g, A = this.boxCells[h]; if (A !== null) { const j = this.bboxes; for (const q of A) if (!I.box[q]) { I.box[q] = !0; const G = 4 * q, H = this.boxKeys[q]; if (this._circleAndRectCollide(w.x, w.y, w.radius, j[G + 0], j[G + 1], j[G + 2], j[G + 3]) && (!v || v(H)) && !ie(E, H.overlapMode)) return f.push(!0), !0 } } const B = this.circleCells[h]; if (B !== null) { const j = this.circles; for (const q of B) if (!I.circle[q]) { I.circle[q] = !0; const G = 3 * q, H = this.circleKeys[q]; if (this._circlesCollide(j[G], j[G + 1], j[G + 2], w.x, w.y, w.radius) && (!v || v(H)) && !ie(E, H.overlapMode)) return f.push(!0), !0 } } } _forEachCell(e, i, o, a, h, f, g, v) { const w = this._convertToXCellCoord(e), I = this._convertToYCellCoord(i), E = this._convertToXCellCoord(o), A = this._convertToYCellCoord(a); for (let B = w; B <= E; B++)for (let j = I; j <= A; j++)if (h.call(this, e, i, o, a, this.xCellCount * j + B, f, g, v)) return } _convertToXCellCoord(e) { return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale))) } _convertToYCellCoord(e) { return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale))) } _circlesCollide(e, i, o, a, h, f) { const g = a - e, v = h - i, w = o + f; return w * w > g * g + v * v } _circleAndRectCollide(e, i, o, a, h, f, g) { const v = (f - a) / 2, w = Math.abs(e - (a + v)); if (w > v + o) return !1; const I = (g - h) / 2, E = Math.abs(i - (h + I)); if (E > I + o) return !1; if (w <= v || E <= I) return !0; const A = w - v, B = E - I; return A * A + B * B <= o * o } } function ye(u, e, i) { const o = c.K(); if (!u) { const { vecSouth: E, vecEast: A } = Me(e), B = ze(); B[0] = A[0], B[1] = A[1], B[2] = E[0], B[3] = E[1], a = B, (I = (f = (h = B)[0]) * (w = h[3]) - (v = h[2]) * (g = h[1])) && (a[0] = w * (I = 1 / I), a[1] = -g * I, a[2] = -v * I, a[3] = f * I), o[0] = B[0], o[1] = B[1], o[4] = B[2], o[5] = B[3] } var a, h, f, g, v, w, I; return c.M(o, o, [1 / i, 1 / i, 1]), o } function ce(u, e, i, o) { if (u) { const a = c.K(); if (!e) { const { vecSouth: h, vecEast: f } = Me(i); a[0] = f[0], a[1] = f[1], a[4] = h[0], a[5] = h[1] } return c.M(a, a, [o, o, 1]), a } return i.pixelsToClipSpaceMatrix } function Me(u) { const e = Math.cos(u.rollInRadians), i = Math.sin(u.rollInRadians), o = Math.cos(u.pitchInRadians), a = Math.cos(u.bearingInRadians), h = Math.sin(u.bearingInRadians), f = c.aj(); f[0] = -a * o * i - h * e, f[1] = -h * o * i + a * e; const g = c.ak(f); g < 1e-9 ? c.al(f) : c.am(f, f, 1 / g); const v = c.aj(); v[0] = a * o * e - h * i, v[1] = h * o * e + a * i; const w = c.ak(v); return w < 1e-9 ? c.al(v) : c.am(v, v, 1 / w), { vecEast: v, vecSouth: f } } function be(u, e, i, o) { let a; o ? (a = [u, e, o(u, e), 1], c.ao(a, a, i)) : (a = [u, e, 0, 1], Mi(a, a, i)); const h = a[3]; return { point: new c.P(a[0] / h, a[1] / h), signedDistanceFromCamera: h, isOccluded: !1 } } function pe(u, e) { return .5 + u / e * .5 } function Ae(u, e) { return u.x >= -e[0] && u.x <= e[0] && u.y >= -e[1] && u.y <= e[1] } function fe(u, e, i, o, a, h, f, g, v, w, I, E, A) { const B = i ? u.textSizeData : u.iconSizeData, j = c.af(B, e.transform.zoom), q = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1], G = i ? u.text.dynamicLayoutVertexArray : u.icon.dynamicLayoutVertexArray; G.clear(); const H = u.lineVertexArray, K = i ? u.text.placedSymbolArray : u.icon.placedSymbolArray, Q = e.transform.width / e.transform.height; let ee = !1; for (let re = 0; re < K.length; re++) { const oe = K.get(re); if (oe.hidden || oe.writingMode === c.ag.vertical && !ee) { wi(oe.numGlyphs, G); continue } ee = !1; const ne = new c.P(oe.anchorX, oe.anchorY), me = { getElevation: A, pitchedLabelPlaneMatrix: o, lineVertexArray: H, pitchWithMap: h, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: e.transform, tileAnchorPoint: ne, unwrappedTileID: v, width: w, height: I, translation: E }, ge = xt(oe.anchorX, oe.anchorY, me); if (!Ae(ge.point, q)) { wi(oe.numGlyphs, G); continue } const Se = pe(e.transform.cameraToCenterDistance, ge.signedDistanceFromCamera), Ie = c.ah(B, j, oe), Pe = h ? Ie * e.transform.getPitchedTextCorrection(oe.anchorX, oe.anchorY, v) / Se : Ie * Se, $e = _t({ projectionContext: me, pitchedLabelPlaneMatrixInverse: a, symbol: oe, fontSize: Pe, flip: !1, keepUpright: f, glyphOffsetArray: u.glyphOffsetArray, dynamicLayoutVertexArray: G, aspectRatio: Q, rotateToLine: g }); ee = $e.useVertical, ($e.notEnoughRoom || ee || $e.needsFlipping && _t({ projectionContext: me, pitchedLabelPlaneMatrixInverse: a, symbol: oe, fontSize: Pe, flip: !0, keepUpright: f, glyphOffsetArray: u.glyphOffsetArray, dynamicLayoutVertexArray: G, aspectRatio: Q, rotateToLine: g }).notEnoughRoom) && wi(oe.numGlyphs, G) } i ? u.text.dynamicLayoutVertexBuffer.updateData(G) : u.icon.dynamicLayoutVertexBuffer.updateData(G) } function He(u, e, i, o, a, h, f, g) { const v = h.glyphStartIndex + h.numGlyphs, w = h.lineStartIndex, I = h.lineStartIndex + h.lineLength, E = e.getoffsetX(h.glyphStartIndex), A = e.getoffsetX(v - 1), B = at(u * E, i, o, a, h.segment, w, I, g, f); if (!B) return null; const j = at(u * A, i, o, a, h.segment, w, I, g, f); return j ? g.projectionCache.anyProjectionOccluded ? null : { first: B, last: j } : null } function rt(u, e, i, o) { return u === c.ag.horizontal && Math.abs(i.y - e.y) > Math.abs(i.x - e.x) * o ? { useVertical: !0 } : (u === c.ag.vertical ? e.y < i.y : e.x > i.x) ? { needsFlipping: !0 } : null } function _t(u) { const { projectionContext: e, pitchedLabelPlaneMatrixInverse: i, symbol: o, fontSize: a, flip: h, keepUpright: f, glyphOffsetArray: g, dynamicLayoutVertexArray: v, aspectRatio: w, rotateToLine: I } = u, E = a / 24, A = o.lineOffsetX * E, B = o.lineOffsetY * E; let j; if (o.numGlyphs > 1) { const q = o.glyphStartIndex + o.numGlyphs, G = o.lineStartIndex, H = o.lineStartIndex + o.lineLength, K = He(E, g, A, B, h, o, I, e); if (!K) return { notEnoughRoom: !0 }; const Q = Qe(K.first.point.x, K.first.point.y, e, i), ee = Qe(K.last.point.x, K.last.point.y, e, i); if (f && !h) { const re = rt(o.writingMode, Q, ee, w); if (re) return re } j = [K.first]; for (let re = o.glyphStartIndex + 1; re < q - 1; re++)j.push(at(E * g.getoffsetX(re), A, B, h, o.segment, G, H, e, I)); j.push(K.last) } else { if (f && !h) { const G = et(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point, H = o.lineStartIndex + o.segment + 1, K = new c.P(e.lineVertexArray.getx(H), e.lineVertexArray.gety(H)), Q = et(K.x, K.y, e), ee = Q.signedDistanceFromCamera > 0 ? Q.point : pt(e.tileAnchorPoint, K, G, 1, e), re = Qe(G.x, G.y, e, i), oe = Qe(ee.x, ee.y, e, i), ne = rt(o.writingMode, re, oe, w); if (ne) return ne } const q = at(E * g.getoffsetX(o.glyphStartIndex), A, B, h, o.segment, o.lineStartIndex, o.lineStartIndex + o.lineLength, e, I); if (!q || e.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 }; j = [q] } for (const q of j) c.an(v, q.point, q.angle); return {} } function pt(u, e, i, o, a) { const h = u.add(u.sub(e)._unit()), f = et(h.x, h.y, a).point, g = i.sub(f); return i.add(g._mult(o / g.mag())) } function Ee(u, e, i) { const o = e.projectionCache; if (o.projections[u]) return o.projections[u]; const a = new c.P(e.lineVertexArray.getx(u), e.lineVertexArray.gety(u)), h = et(a.x, a.y, e); if (h.signedDistanceFromCamera > 0) return o.projections[u] = h.point, o.anyProjectionOccluded = o.anyProjectionOccluded || h.isOccluded, h.point; const f = u - i.direction; return pt(i.distanceFromAnchor === 0 ? e.tileAnchorPoint : new c.P(e.lineVertexArray.getx(f), e.lineVertexArray.gety(f)), a, i.previousVertex, i.absOffsetX - i.distanceFromAnchor + 1, e) } function et(u, e, i) { const o = u + i.translation[0], a = e + i.translation[1]; let h; return i.pitchWithMap ? (h = be(o, a, i.pitchedLabelPlaneMatrix, i.getElevation), h.isOccluded = !1) : (h = i.transform.projectTileCoordinates(o, a, i.unwrappedTileID, i.getElevation), h.point.x = (.5 * h.point.x + .5) * i.width, h.point.y = (.5 * -h.point.y + .5) * i.height), h } function Qe(u, e, i, o) { if (i.pitchWithMap) { const a = [u, e, 0, 1]; return c.ao(a, a, o), i.transform.projectTileCoordinates(a[0] / a[3], a[1] / a[3], i.unwrappedTileID, i.getElevation).point } return { x: u / i.width * 2 - 1, y: e / i.height * 2 - 1 } } function xt(u, e, i) { return i.transform.projectTileCoordinates(u, e, i.unwrappedTileID, i.getElevation) } function ft(u, e, i) { return u._unit()._perp()._mult(e * i) } function bt(u, e, i, o, a, h, f, g, v) { if (g.projectionCache.offsets[u]) return g.projectionCache.offsets[u]; const w = i.add(e); if (u + v.direction < o || u + v.direction >= a) return g.projectionCache.offsets[u] = w, w; const I = Ee(u + v.direction, g, v), E = ft(I.sub(i), f, v.direction), A = i.add(E), B = I.add(E); return g.projectionCache.offsets[u] = c.ap(h, w, A, B) || w, g.projectionCache.offsets[u] } function at(u, e, i, o, a, h, f, g, v) { const w = o ? u - e : u + e; let I = w > 0 ? 1 : -1, E = 0; o && (I *= -1, E = Math.PI), I < 0 && (E += Math.PI); let A, B = I > 0 ? h + a : h + a + 1; g.projectionCache.cachedAnchorPoint ? A = g.projectionCache.cachedAnchorPoint : (A = et(g.tileAnchorPoint.x, g.tileAnchorPoint.y, g).point, g.projectionCache.cachedAnchorPoint = A); let j, q, G = A, H = A, K = 0, Q = 0; const ee = Math.abs(w), re = []; let oe; for (; K + Q <= ee;) { if (B += I, B < h || B >= f) return null; K += Q, H = G, q = j; const ge = { absOffsetX: ee, direction: I, distanceFromAnchor: K, previousVertex: H }; if (G = Ee(B, g, ge), i === 0) re.push(H), oe = G.sub(H); else { let Se; const Ie = G.sub(H); Se = Ie.mag() === 0 ? ft(Ee(B + I, g, ge).sub(G), i, I) : ft(Ie, i, I), q || (q = H.add(Se)), j = bt(B, Se, G, h, f, q, i, g, ge), re.push(q), oe = j.sub(q) } Q = oe.mag() } const ne = oe._mult((ee - K) / Q)._add(q || H), me = E + Math.atan2(G.y - H.y, G.x - H.x); return re.push(ne), { point: ne, angle: v ? me : 0, path: re } } const Zn = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]); function wi(u, e) { for (let i = 0; i < u; i++) { const o = e.length; e.resize(o + 4), e.float32.set(Zn, 3 * o) } } function Mi(u, e, i) { const o = e[0], a = e[1]; return u[0] = i[0] * o + i[4] * a + i[12], u[1] = i[1] * o + i[5] * a + i[13], u[3] = i[3] * o + i[7] * a + i[15], u } const Qt = 100; class Mo { constructor(e, i = new he(e.width + 200, e.height + 200, 25), o = new he(e.width + 200, e.height + 200, 25)) { this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Qt, this.screenBottomBoundary = e.height + Qt, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6 } placeCollisionBox(e, i, o, a, h, f, g, v, w, I, E, A) { const B = this.projectAndGetPerspectiveRatio(e.anchorPointX + v[0], e.anchorPointY + v[1], h, I, A), j = o * B.perspectiveRatio; let q; if (f || g) q = this._projectCollisionBox(e, j, a, h, f, g, v, B, I, E, A); else { const oe = B.x + (E ? E.x * j : 0), ne = B.y + (E ? E.y * j : 0); q = { allPointsOccluded: !1, box: [oe + e.x1 * j, ne + e.y1 * j, oe + e.x2 * j, ne + e.y2 * j] } } const [G, H, K, Q] = q.box, ee = f ? q.allPointsOccluded : B.isOccluded; let re = ee; return re || (re = B.perspectiveRatio < this.perspectiveRatioCutoff), re || (re = !this.isInsideGrid(G, H, K, Q)), re || i !== "always" && this.grid.hitTest(G, H, K, Q, i, w) ? { box: [G, H, K, Q], placeable: !1, offscreen: !1, occluded: ee } : { box: [G, H, K, Q], placeable: !0, offscreen: this.isOffscreen(G, H, K, Q), occluded: ee } } placeCollisionCircles(e, i, o, a, h, f, g, v, w, I, E, A, B, j) { const q = [], G = new c.P(i.anchorX, i.anchorY), H = this.getPerspectiveRatio(G.x, G.y, f, j), K = (w ? h * this.transform.getPitchedTextCorrection(i.anchorX, i.anchorY, f) / H : h * H) / c.au, Q = { getElevation: j, pitchedLabelPlaneMatrix: g, lineVertexArray: o, pitchWithMap: w, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: G, unwrappedTileID: f, width: this.transform.width, height: this.transform.height, translation: B }, ee = He(K, a, i.lineOffsetX * K, i.lineOffsetY * K, !1, i, !1, Q); let re = !1, oe = !1, ne = !0; if (ee) { const me = .5 * E * H + A, ge = new c.P(-100, -100), Se = new c.P(this.screenRightBoundary, this.screenBottomBoundary), Ie = new X, Pe = ee.first, $e = ee.last; let Ue = []; for (let st = Pe.path.length - 1; st >= 1; st--)Ue.push(Pe.path[st]); for (let st = 1; st < $e.path.length; st++)Ue.push($e.path[st]); const De = 2.5 * me; if (w) { const st = this.projectPathToScreenSpace(Ue, Q); Ue = st.some(Ot => Ot.signedDistanceFromCamera <= 0) ? [] : st.map(Ot => Ot.point) } let tt = []; if (Ue.length > 0) { const st = Ue[0].clone(), Ot = Ue[0].clone(); for (let Jt = 1; Jt < Ue.length; Jt++)st.x = Math.min(st.x, Ue[Jt].x), st.y = Math.min(st.y, Ue[Jt].y), Ot.x = Math.max(Ot.x, Ue[Jt].x), Ot.y = Math.max(Ot.y, Ue[Jt].y); tt = st.x >= ge.x && Ot.x <= Se.x && st.y >= ge.y && Ot.y <= Se.y ? [Ue] : Ot.x < ge.x || st.x > Se.x || Ot.y < ge.y || st.y > Se.y ? [] : c.aq([Ue], ge.x, ge.y, Se.x, Se.y) } for (const st of tt) { Ie.reset(st, .25 * me); let Ot = 0; Ot = Ie.length <= .5 * me ? 1 : Math.ceil(Ie.paddedLength / De) + 1; for (let Jt = 0; Jt < Ot; Jt++) { const $t = Jt / Math.max(Ot - 1, 1), oi = Ie.lerp($t), ei = oi.x + Qt, jt = oi.y + Qt; q.push(ei, jt, me, 0); const Gt = ei - me, Li = jt - me, Fi = ei + me, Ii = jt + me; if (ne = ne && this.isOffscreen(Gt, Li, Fi, Ii), oe = oe || this.isInsideGrid(Gt, Li, Fi, Ii), e !== "always" && this.grid.hitTestCircle(ei, jt, me, e, I) && (re = !0, !v)) return { circles: [], offscreen: !1, collisionDetected: re } } } } return { circles: !v && re || !oe || H < this.perspectiveRatioCutoff ? [] : q, offscreen: ne, collisionDetected: re } } projectPathToScreenSpace(e, i) { const o = function (a, h) { const f = c.K(); return c.ai(f, h.pitchedLabelPlaneMatrix), a.map(g => { const v = be(g.x, g.y, f, h.getElevation), w = h.transform.projectTileCoordinates(v.point.x, v.point.y, h.unwrappedTileID, h.getElevation); return w.point.x = (.5 * w.point.x + .5) * h.width, w.point.y = (.5 * -w.point.y + .5) * h.height, w }) }(e, i); return function (a) { let h = 0, f = 0, g = 0, v = 0; for (let w = 0; w < a.length; w++)a[w].isOccluded ? (g = w + 1, v = 0) : (v++, v > f && (f = v, h = g)); return a.slice(h, h + f) }(o) } queryRenderedSymbols(e) { if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {}; const i = []; let o = 1 / 0, a = 1 / 0, h = -1 / 0, f = -1 / 0; for (const I of e) { const E = new c.P(I.x + Qt, I.y + Qt); o = Math.min(o, E.x), a = Math.min(a, E.y), h = Math.max(h, E.x), f = Math.max(f, E.y), i.push(E) } const g = this.grid.query(o, a, h, f).concat(this.ignoredGrid.query(o, a, h, f)), v = {}, w = {}; for (const I of g) { const E = I.key; if (v[E.bucketInstanceId] === void 0 && (v[E.bucketInstanceId] = {}), v[E.bucketInstanceId][E.featureIndex]) continue; const A = [new c.P(I.x1, I.y1), new c.P(I.x2, I.y1), new c.P(I.x2, I.y2), new c.P(I.x1, I.y2)]; c.ar(i, A) && (v[E.bucketInstanceId][E.featureIndex] = !0, w[E.bucketInstanceId] === void 0 && (w[E.bucketInstanceId] = []), w[E.bucketInstanceId].push(E.featureIndex)) } return w } insertCollisionBox(e, i, o, a, h, f) { (o ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: a, featureIndex: h, collisionGroupID: f, overlapMode: i }, e[0], e[1], e[2], e[3]) } insertCollisionCircles(e, i, o, a, h, f) { const g = o ? this.ignoredGrid : this.grid, v = { bucketInstanceId: a, featureIndex: h, collisionGroupID: f, overlapMode: i }; for (let w = 0; w < e.length; w += 4)g.insertCircle(v, e[w], e[w + 1], e[w + 2]) } projectAndGetPerspectiveRatio(e, i, o, a, h) { if (h) { let f; a ? (f = [e, i, a(e, i), 1], c.ao(f, f, h)) : (f = [e, i, 0, 1], Mi(f, f, h)); const g = f[3]; return { x: (f[0] / g + 1) / 2 * this.transform.width + Qt, y: (-f[1] / g + 1) / 2 * this.transform.height + Qt, perspectiveRatio: .5 + this.transform.cameraToCenterDistance / g * .5, isOccluded: !1, signedDistanceFromCamera: g } } { const f = this.transform.projectTileCoordinates(e, i, o, a); return { x: (f.point.x + 1) / 2 * this.transform.width + Qt, y: (1 - f.point.y) / 2 * this.transform.height + Qt, perspectiveRatio: .5 + this.transform.cameraToCenterDistance / f.signedDistanceFromCamera * .5, isOccluded: f.isOccluded, signedDistanceFromCamera: f.signedDistanceFromCamera } } } getPerspectiveRatio(e, i, o, a) { const h = this.transform.projectTileCoordinates(e, i, o, a); return .5 + this.transform.cameraToCenterDistance / h.signedDistanceFromCamera * .5 } isOffscreen(e, i, o, a) { return o < Qt || e >= this.screenRightBoundary || a < Qt || i > this.screenBottomBoundary } isInsideGrid(e, i, o, a) { return o >= 0 && e < this.gridRightBoundary && a >= 0 && i < this.gridBottomBoundary } getViewportMatrix() { const e = c.as([]); return c.L(e, e, [-100, -100, 0]), e } _projectCollisionBox(e, i, o, a, h, f, g, v, w, I, E) { let A = 1, B = 0, j = 0, q = 1; const G = e.anchorPointX + g[0], H = e.anchorPointY + g[1]; if (f && !h) { const Ue = this.projectAndGetPerspectiveRatio(G + 1, H, a, w, E), De = Ue.x - v.x, tt = Math.atan((Ue.y - v.y) / De) + (De < 0 ? Math.PI : 0), st = Math.sin(tt), Ot = Math.cos(tt); A = Ot, B = st, j = -st, q = Ot } else if (!f && h) { const Ue = Me(this.transform); A = Ue.vecEast[0], B = Ue.vecEast[1], j = Ue.vecSouth[0], q = Ue.vecSouth[1] } let K = v.x, Q = v.y, ee = i; h && (K = G, Q = H, ee = Math.pow(2, -(this.transform.zoom - o.overscaledZ)), ee *= this.transform.getPitchedTextCorrection(G, H, a), I || (ee *= c.ad(.5 + v.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), I && (K += A * I.x * ee + j * I.y * ee, Q += B * I.x * ee + q * I.y * ee); const re = e.x1 * ee, oe = e.x2 * ee, ne = (re + oe) / 2, me = e.y1 * ee, ge = e.y2 * ee, Se = (me + ge) / 2, Ie = [{ offsetX: re, offsetY: me }, { offsetX: ne, offsetY: me }, { offsetX: oe, offsetY: me }, { offsetX: oe, offsetY: Se }, { offsetX: oe, offsetY: ge }, { offsetX: ne, offsetY: ge }, { offsetX: re, offsetY: ge }, { offsetX: re, offsetY: Se }]; let Pe = []; for (const { offsetX: Ue, offsetY: De } of Ie) Pe.push(new c.P(K + A * Ue + j * De, Q + B * Ue + q * De)); let $e = !1; if (h) { const Ue = Pe.map(De => this.projectAndGetPerspectiveRatio(De.x, De.y, a, w, E)); $e = Ue.some(De => !De.isOccluded), Pe = Ue.map(De => new c.P(De.x, De.y)) } else $e = !0; return { box: c.at(Pe), allPointsOccluded: !$e } } } class hr { constructor(e, i, o, a) { this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? i : -i))) : a && o ? 1 : 0, this.placed = o } isHidden() { return this.opacity === 0 && !this.placed } } class Wt { constructor(e, i, o, a, h) { this.text = new hr(e ? e.text : null, i, o, h), this.icon = new hr(e ? e.icon : null, i, a, h) } isHidden() { return this.text.isHidden() && this.icon.isHidden() } } class Mc { constructor(e, i, o) { this.text = e, this.icon = i, this.skipFade = o } } class qs { constructor(e, i, o, a, h) { this.bucketInstanceId = e, this.featureIndex = i, this.sourceLayerIndex = o, this.bucketIndex = a, this.tileID = h } } class Na { constructor(e) { this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {} } get(e) { if (this.crossSourceCollisions) return { ID: 0, predicate: null }; if (!this.collisionGroups[e]) { const i = ++this.maxGroupID; this.collisionGroups[e] = { ID: i, predicate: o => o.collisionGroupID === i } } return this.collisionGroups[e] } } function Sn(u, e, i, o, a) { const { horizontalAlign: h, verticalAlign: f } = c.aA(u); return new c.P(-(h - .5) * e + o[0] * a, -(f - .5) * i + o[1] * a) } class fs { constructor(e, i, o, a, h) { this.transform = e.clone(), this.terrain = i, this.collisionIndex = new Mo(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = o, this.retainedQueryData = {}, this.collisionGroups = new Na(a), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = h, h && (h.prevPlacement = void 0), this.placedOrientations = {} } _getTerrainElevationFunc(e) { const i = this.terrain; return i ? (o, a) => i.getElevation(e, o, a) : null } getBucketParts(e, i, o, a) { const h = o.getBucket(i), f = o.latestFeatureIndex; if (!h || !f || i.id !== h.layerIds[0]) return; const g = o.collisionBoxArray, v = h.layers[0].layout, w = h.layers[0].paint, I = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), E = o.tileSize / c.Z, A = o.tileID.toUnwrapped(), B = v.get("text-rotation-alignment") === "map", j = c.av(o, 1, this.transform.zoom), q = c.aw(this.collisionIndex.transform, o, w.get("text-translate"), w.get("text-translate-anchor")), G = c.aw(this.collisionIndex.transform, o, w.get("icon-translate"), w.get("icon-translate-anchor")), H = ye(B, this.transform, j); this.retainedQueryData[h.bucketInstanceId] = new qs(h.bucketInstanceId, f, h.sourceLayerIndex, h.index, o.tileID); const K = { bucket: h, layout: v, translationText: q, translationIcon: G, unwrappedTileID: A, pitchedLabelPlaneMatrix: H, scale: I, textPixelRatio: E, holdingForFade: o.holdingForFade(), collisionBoxArray: g, partiallyEvaluatedTextSize: c.af(h.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(h.sourceID) }; if (a) for (const Q of h.sortKeyRanges) { const { sortKey: ee, symbolInstanceStart: re, symbolInstanceEnd: oe } = Q; e.push({ sortKey: ee, symbolInstanceStart: re, symbolInstanceEnd: oe, parameters: K }) } else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: h.symbolInstances.length, parameters: K }) } attemptAnchorPlacement(e, i, o, a, h, f, g, v, w, I, E, A, B, j, q, G, H, K, Q, ee) { const re = c.ax[e.textAnchor], oe = [e.textOffset0, e.textOffset1], ne = Sn(re, o, a, oe, h), me = this.collisionIndex.placeCollisionBox(i, A, v, w, I, g, f, G, E.predicate, Q, ne, ee); if ((!K || this.collisionIndex.placeCollisionBox(K, A, v, w, I, g, f, H, E.predicate, Q, ne, ee).placeable) && me.placeable) { let ge; if (this.prevPlacement && this.prevPlacement.variableOffsets[B.crossTileID] && this.prevPlacement.placements[B.crossTileID] && this.prevPlacement.placements[B.crossTileID].text && (ge = this.prevPlacement.variableOffsets[B.crossTileID].anchor), B.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0"); return this.variableOffsets[B.crossTileID] = { textOffset: oe, width: o, height: a, anchor: re, textBoxScale: h, prevAnchor: ge }, this.markUsedJustification(j, re, B, q), j.allowVerticalPlacement && (this.markUsedOrientation(j, q, B), this.placedOrientations[B.crossTileID] = q), { shift: ne, placedGlyphBoxes: me } } } placeLayerBucketPart(e, i, o) { const { bucket: a, layout: h, translationText: f, translationIcon: g, unwrappedTileID: v, pitchedLabelPlaneMatrix: w, textPixelRatio: I, holdingForFade: E, collisionBoxArray: A, partiallyEvaluatedTextSize: B, collisionGroup: j } = e.parameters, q = h.get("text-optional"), G = h.get("icon-optional"), H = c.ay(h, "text-overlap", "text-allow-overlap"), K = H === "always", Q = c.ay(h, "icon-overlap", "icon-allow-overlap"), ee = Q === "always", re = h.get("text-rotation-alignment") === "map", oe = h.get("text-pitch-alignment") === "map", ne = h.get("icon-text-fit") !== "none", me = h.get("symbol-z-order") === "viewport-y", ge = K && (ee || !a.hasIconData() || G), Se = ee && (K || !a.hasTextData() || q); !a.collisionArrays && A && a.deserializeCollisionBoxes(A); const Ie = this.retainedQueryData[a.bucketInstanceId].tileID, Pe = this._getTerrainElevationFunc(Ie), $e = this.transform.getFastPathSimpleProjectionMatrix(Ie), Ue = (De, tt, st) => { var Ot, Jt; if (i[De.crossTileID]) return; if (E) return void (this.placements[De.crossTileID] = new Mc(!1, !1, !1)); let $t = !1, oi = !1, ei = !0, jt = null, Gt = { box: null, placeable: !1, offscreen: null, occluded: !1 }, Li = { placeable: !1 }, Fi = null, Ii = null, qi = null, kn = 0, yn = 0, pn = 0; tt.textFeatureIndex ? kn = tt.textFeatureIndex : De.useRuntimeCollisionCircles && (kn = De.featureIndex), tt.verticalTextFeatureIndex && (yn = tt.verticalTextFeatureIndex); const Ur = tt.textBox; if (Ur) { const $r = Yt => { let Xt = c.ag.horizontal; if (a.allowVerticalPlacement && !Yt && this.prevPlacement) { const Ci = this.prevPlacement.placedOrientations[De.crossTileID]; Ci && (this.placedOrientations[De.crossTileID] = Ci, Xt = Ci, this.markUsedOrientation(a, Xt, De)) } return Xt }, fn = (Yt, Xt) => { if (a.allowVerticalPlacement && De.numVerticalGlyphVertices > 0 && tt.verticalTextBox) { for (const Ci of a.writingModes) if (Ci === c.ag.vertical ? (Gt = Xt(), Li = Gt) : Gt = Yt(), Gt && Gt.placeable) break } else Gt = Yt() }, Jr = De.textAnchorOffsetStartIndex, mn = De.textAnchorOffsetEndIndex; if (mn === Jr) { const Yt = (Xt, Ci) => { const Ei = this.collisionIndex.placeCollisionBox(Xt, H, I, Ie, v, oe, re, f, j.predicate, Pe, void 0, $e); return Ei && Ei.placeable && (this.markUsedOrientation(a, Ci, De), this.placedOrientations[De.crossTileID] = Ci), Ei }; fn(() => Yt(Ur, c.ag.horizontal), () => { const Xt = tt.verticalTextBox; return a.allowVerticalPlacement && De.numVerticalGlyphVertices > 0 && Xt ? Yt(Xt, c.ag.vertical) : { box: null, offscreen: null } }), $r(Gt && Gt.placeable) } else { let Yt = c.ax[(Jt = (Ot = this.prevPlacement) === null || Ot === void 0 ? void 0 : Ot.variableOffsets[De.crossTileID]) === null || Jt === void 0 ? void 0 : Jt.anchor]; const Xt = (Ei, os, Eh) => { const _u = Ei.x2 - Ei.x1, Nl = Ei.y2 - Ei.y1, gu = De.textBoxScale, as = ne && Q === "never" ? os : null; let Tr = null, Zl = H === "never" ? 1 : 2, yu = "never"; Yt && Zl++; for (let _a = 0; _a < Zl; _a++) { for (let ga = Jr; ga < mn; ga++) { const xu = a.textAnchorOffsets.get(ga); if (Yt && xu.textAnchor !== Yt) continue; const ya = this.attemptAnchorPlacement(xu, Ei, _u, Nl, gu, re, oe, I, Ie, v, j, yu, De, a, Eh, f, g, as, Pe); if (ya && (Tr = ya.placedGlyphBoxes, Tr && Tr.placeable)) return $t = !0, jt = ya.shift, Tr } Yt ? Yt = null : yu = H } return o && !Tr && (Tr = { box: this.collisionIndex.placeCollisionBox(Ur, "always", I, Ie, v, oe, re, f, j.predicate, Pe, void 0, $e).box, offscreen: !1, placeable: !1, occluded: !1 }), Tr }; fn(() => Xt(Ur, tt.iconBox, c.ag.horizontal), () => { const Ei = tt.verticalTextBox; return a.allowVerticalPlacement && (!Gt || !Gt.placeable) && De.numVerticalGlyphVertices > 0 && Ei ? Xt(Ei, tt.verticalIconBox, c.ag.vertical) : { box: null, occluded: !0, offscreen: null } }), Gt && ($t = Gt.placeable, ei = Gt.offscreen); const Ci = $r(Gt && Gt.placeable); if (!$t && this.prevPlacement) { const Ei = this.prevPlacement.variableOffsets[De.crossTileID]; Ei && (this.variableOffsets[De.crossTileID] = Ei, this.markUsedJustification(a, Ei.anchor, De, Ci)) } } } if (Fi = Gt, $t = Fi && Fi.placeable, ei = Fi && Fi.offscreen, De.useRuntimeCollisionCircles) { const $r = a.text.placedSymbolArray.get(De.centerJustifiedTextSymbolIndex), fn = c.ah(a.textSizeData, B, $r), Jr = h.get("text-padding"); Ii = this.collisionIndex.placeCollisionCircles(H, $r, a.lineVertexArray, a.glyphOffsetArray, fn, v, w, o, oe, j.predicate, De.collisionCircleDiameter, Jr, f, Pe), Ii.circles.length && Ii.collisionDetected && !o && c.w("Collisions detected, but collision boxes are not shown"), $t = K || Ii.circles.length > 0 && !Ii.collisionDetected, ei = ei && Ii.offscreen } if (tt.iconFeatureIndex && (pn = tt.iconFeatureIndex), tt.iconBox) { const $r = fn => this.collisionIndex.placeCollisionBox(fn, Q, I, Ie, v, oe, re, g, j.predicate, Pe, ne && jt ? jt : void 0, $e); Li && Li.placeable && tt.verticalIconBox ? (qi = $r(tt.verticalIconBox), oi = qi.placeable) : (qi = $r(tt.iconBox), oi = qi.placeable), ei = ei && qi.offscreen } const ns = q || De.numHorizontalGlyphVertices === 0 && De.numVerticalGlyphVertices === 0, po = G || De.numIconVertices === 0; ns || po ? po ? ns || (oi = oi && $t) : $t = oi && $t : oi = $t = oi && $t; const ss = oi && qi.placeable; if ($t && Fi.placeable && this.collisionIndex.insertCollisionBox(Fi.box, H, h.get("text-ignore-placement"), a.bucketInstanceId, Li && Li.placeable && yn ? yn : kn, j.ID), ss && this.collisionIndex.insertCollisionBox(qi.box, Q, h.get("icon-ignore-placement"), a.bucketInstanceId, pn, j.ID), Ii && $t && this.collisionIndex.insertCollisionCircles(Ii.circles, H, h.get("text-ignore-placement"), a.bucketInstanceId, kn, j.ID), o && this.storeCollisionData(a.bucketInstanceId, st, tt, Fi, qi, Ii), De.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0"); if (a.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0"); this.placements[De.crossTileID] = new Mc(($t || ge) && !(Fi != null && Fi.occluded), (oi || Se) && !(qi != null && qi.occluded), ei || a.justReloaded), i[De.crossTileID] = !0 }; if (me) { if (e.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0"); const De = a.getSortedSymbolIndexes(-this.transform.bearingInRadians); for (let tt = De.length - 1; tt >= 0; --tt) { const st = De[tt]; Ue(a.symbolInstances.get(st), a.collisionArrays[st], st) } } else for (let De = e.symbolInstanceStart; De < e.symbolInstanceEnd; De++)Ue(a.symbolInstances.get(De), a.collisionArrays[De], De); a.justReloaded = !1 } storeCollisionData(e, i, o, a, h, f) { if (o.textBox || o.iconBox) { let g, v; this.collisionBoxArrays.has(e) ? g = this.collisionBoxArrays.get(e) : (g = new Map, this.collisionBoxArrays.set(e, g)), g.has(i) ? v = g.get(i) : (v = { text: null, icon: null }, g.set(i, v)), o.textBox && (v.text = a.box), o.iconBox && (v.icon = h.box) } if (f) { let g = this.collisionCircleArrays[e]; g === void 0 && (g = this.collisionCircleArrays[e] = []); for (let v = 0; v < f.circles.length; v += 4)g.push(f.circles[v + 0] - Qt), g.push(f.circles[v + 1] - Qt), g.push(f.circles[v + 2]), g.push(f.collisionDetected ? 1 : 0) } } markUsedJustification(e, i, o, a) { let h; h = a === c.ag.vertical ? o.verticalPlacedTextSymbolIndex : { left: o.leftJustifiedTextSymbolIndex, center: o.centerJustifiedTextSymbolIndex, right: o.rightJustifiedTextSymbolIndex }[c.az(i)]; const f = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex]; for (const g of f) g >= 0 && (e.text.placedSymbolArray.get(g).crossTileID = h >= 0 && g !== h ? 0 : o.crossTileID) } markUsedOrientation(e, i, o) { const a = i === c.ag.horizontal || i === c.ag.horizontalOnly ? i : 0, h = i === c.ag.vertical ? i : 0, f = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex]; for (const g of f) e.text.placedSymbolArray.get(g).placedOrientation = a; o.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = h) } commit(e) { this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom; const i = this.prevPlacement; let o = !1; this.prevZoomAdjustment = i ? i.zoomAdjustment(this.transform.zoom) : 0; const a = i ? i.symbolFadeChange(e) : 1, h = i ? i.opacities : {}, f = i ? i.variableOffsets : {}, g = i ? i.placedOrientations : {}; for (const v in this.placements) { const w = this.placements[v], I = h[v]; I ? (this.opacities[v] = new Wt(I, a, w.text, w.icon), o = o || w.text !== I.text.placed || w.icon !== I.icon.placed) : (this.opacities[v] = new Wt(null, a, w.text, w.icon, w.skipFade), o = o || w.text || w.icon) } for (const v in h) { const w = h[v]; if (!this.opacities[v]) { const I = new Wt(w, a, !1, !1); I.isHidden() || (this.opacities[v] = I, o = o || w.text.placed || w.icon.placed) } } for (const v in f) this.variableOffsets[v] || !this.opacities[v] || this.opacities[v].isHidden() || (this.variableOffsets[v] = f[v]); for (const v in g) this.placedOrientations[v] || !this.opacities[v] || this.opacities[v].isHidden() || (this.placedOrientations[v] = g[v]); if (i && i.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined"); o ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = i ? i.lastPlacementChangeTime : e) } updateLayerOpacities(e, i) { const o = {}; for (const a of i) { const h = a.getBucket(e); h && a.latestFeatureIndex && e.id === h.layerIds[0] && this.updateBucketOpacities(h, a.tileID, o, a.collisionBoxArray) } } updateBucketOpacities(e, i, o, a) { e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear(); const h = e.layers[0], f = h.layout, g = new Wt(null, 0, !1, !1, !0), v = f.get("text-allow-overlap"), w = f.get("icon-allow-overlap"), I = h._unevaluatedLayout.hasValue("text-variable-anchor") || h._unevaluatedLayout.hasValue("text-variable-anchor-offset"), E = f.get("text-rotation-alignment") === "map", A = f.get("text-pitch-alignment") === "map", B = f.get("icon-text-fit") !== "none", j = new Wt(null, 0, v && (w || !e.hasIconData() || f.get("icon-optional")), w && (v || !e.hasTextData() || f.get("text-optional")), !0); !e.collisionArrays && a && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(a); const q = (H, K, Q) => { for (let ee = 0; ee < K / 4; ee++)H.opacityVertexArray.emplaceBack(Q); H.hasVisibleVertices = H.hasVisibleVertices || Q !== _s }, G = this.collisionBoxArrays.get(e.bucketInstanceId); for (let H = 0; H < e.symbolInstances.length; H++) { const K = e.symbolInstances.get(H), { numHorizontalGlyphVertices: Q, numVerticalGlyphVertices: ee, crossTileID: re } = K; let oe = this.opacities[re]; o[re] ? oe = g : oe || (oe = j, this.opacities[re] = oe), o[re] = !0; const ne = K.numIconVertices > 0, me = this.placedOrientations[K.crossTileID], ge = me === c.ag.vertical, Se = me === c.ag.horizontal || me === c.ag.horizontalOnly; if (Q > 0 || ee > 0) { const Pe = Ua(oe.text); q(e.text, Q, ge ? _s : Pe), q(e.text, ee, Se ? _s : Pe); const $e = oe.text.isHidden();[K.rightJustifiedTextSymbolIndex, K.centerJustifiedTextSymbolIndex, K.leftJustifiedTextSymbolIndex].forEach(tt => { tt >= 0 && (e.text.placedSymbolArray.get(tt).hidden = $e || ge ? 1 : 0) }), K.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(K.verticalPlacedTextSymbolIndex).hidden = $e || Se ? 1 : 0); const Ue = this.variableOffsets[K.crossTileID]; Ue && this.markUsedJustification(e, Ue.anchor, K, me); const De = this.placedOrientations[K.crossTileID]; De && (this.markUsedJustification(e, "left", K, De), this.markUsedOrientation(e, De, K)) } if (ne) { const Pe = Ua(oe.icon), $e = !(B && K.verticalPlacedIconSymbolIndex && ge); K.placedIconSymbolIndex >= 0 && (q(e.icon, K.numIconVertices, $e ? Pe : _s), e.icon.placedSymbolArray.get(K.placedIconSymbolIndex).hidden = oe.icon.isHidden()), K.verticalPlacedIconSymbolIndex >= 0 && (q(e.icon, K.numVerticalIconVertices, $e ? _s : Pe), e.icon.placedSymbolArray.get(K.verticalPlacedIconSymbolIndex).hidden = oe.icon.isHidden()) } const Ie = G && G.has(H) ? G.get(H) : { text: null, icon: null }; if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) { const Pe = e.collisionArrays[H]; if (Pe) { let $e = new c.P(0, 0); if (Pe.textBox || Pe.verticalTextBox) { let Ue = !0; if (I) { const De = this.variableOffsets[re]; De ? ($e = Sn(De.anchor, De.width, De.height, De.textOffset, De.textBoxScale), E && $e._rotate(A ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Ue = !1 } if (Pe.textBox || Pe.verticalTextBox) { let De; Pe.textBox && (De = ge), Pe.verticalTextBox && (De = Se), Za(e.textCollisionBox.collisionVertexArray, oe.text.placed, !Ue || De, Ie.text, $e.x, $e.y) } } if (Pe.iconBox || Pe.verticalIconBox) { const Ue = !!(!Se && Pe.verticalIconBox); let De; Pe.iconBox && (De = Ue), Pe.verticalIconBox && (De = !Ue), Za(e.iconCollisionBox.collisionVertexArray, oe.icon.placed, De, Ie.icon, B ? $e.x : 0, B ? $e.y : 0) } } } } if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`); if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`); e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]) } symbolFadeChange(e) { return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment } zoomAdjustment(e) { return Math.max(0, (this.transform.zoom - e) / 1.5) } hasTransitions(e) { return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration } stillRecent(e, i) { const o = this.zoomAtLastRecencyCheck === i ? 1 - this.zoomAdjustment(i) : 1; return this.zoomAtLastRecencyCheck = i, this.commitTime + this.fadeDuration * o > e } setStale() { this.stale = !0 } } function Za(u, e, i, o, a, h) { o && o.length !== 0 || (o = [0, 0, 0, 0]); const f = o[0] - Qt, g = o[1] - Qt, v = o[2] - Qt, w = o[3] - Qt; u.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, f, g), u.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, v, g), u.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, v, w), u.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, f, w) } const Ic = Math.pow(2, 25), Cc = Math.pow(2, 24), ms = Math.pow(2, 17), Ec = Math.pow(2, 16), sh = Math.pow(2, 9), oh = Math.pow(2, 8), ah = Math.pow(2, 1); function Ua(u) { if (u.opacity === 0 && !u.placed) return 0; if (u.opacity === 1 && u.placed) return 4294967295; const e = u.placed ? 1 : 0, i = Math.floor(127 * u.opacity); return i * Ic + e * Cc + i * ms + e * Ec + i * sh + e * oh + i * ah + e } const _s = 0; class $a { constructor(e) { this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [] } continuePlacement(e, i, o, a, h) { const f = this._bucketParts; for (; this._currentTileIndex < e.length;)if (i.getBucketParts(f, a, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, h()) return !0; for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, f.sort((g, v) => g.sortKey - v.sortKey)); this._currentPartIndex < f.length;)if (i.placeLayerBucketPart(f[this._currentPartIndex], this._seenCrossTileIDs, o), this._currentPartIndex++, h()) return !0; return !1 } } class Ga { constructor(e, i, o, a, h, f, g, v) { this.placement = new fs(e, i, f, g, v), this._currentPlacementIndex = o.length - 1, this._forceFullPlacement = a, this._showCollisionBoxes = h, this._done = !1 } isDone() { return this._done } continuePlacement(e, i, o) { const a = Le.now(), h = () => !this._forceFullPlacement && Le.now() - a > 2; for (; this._currentPlacementIndex >= 0;) { const f = i[e[this._currentPlacementIndex]], g = this.placement.collisionIndex.transform.zoom; if (f.type === "symbol" && (!f.minzoom || f.minzoom <= g) && (!f.maxzoom || f.maxzoom > g)) { if (this._inProgressLayer || (this._inProgressLayer = new $a(f)), this._inProgressLayer.continuePlacement(o[f.source], this.placement, this._showCollisionBoxes, f, h)) return; delete this._inProgressLayer } this._currentPlacementIndex-- } this._done = !0 } commit(e) { return this.placement.commit(e), this.placement } } const gs = 512 / c.Z / 2; class qa { constructor(e, i, o) { this.tileID = e, this.bucketInstanceId = o, this._symbolsByKey = {}; const a = new Map; for (let h = 0; h < i.length; h++) { const f = i.get(h), g = f.key, v = a.get(g); v ? v.push(f) : a.set(g, [f]) } for (const [h, f] of a) { const g = { positions: f.map(v => ({ x: Math.floor(v.anchorX * gs), y: Math.floor(v.anchorY * gs) })), crossTileIDs: f.map(v => v.crossTileID) }; if (g.positions.length > 128) { const v = new c.aB(g.positions.length, 16, Uint16Array); for (const { x: w, y: I } of g.positions) v.add(w, I); v.finish(), delete g.positions, g.index = v } this._symbolsByKey[h] = g } } getScaledCoordinates(e, i) { const { x: o, y: a, z: h } = this.tileID.canonical, { x: f, y: g, z: v } = i.canonical, w = gs / Math.pow(2, v - h), I = (g * c.Z + e.anchorY) * w, E = a * c.Z * gs; return { x: Math.floor((f * c.Z + e.anchorX) * w - o * c.Z * gs), y: Math.floor(I - E) } } findMatches(e, i, o) { const a = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z); for (let h = 0; h < e.length; h++) { const f = e.get(h); if (f.crossTileID) continue; const g = this._symbolsByKey[f.key]; if (!g) continue; const v = this.getScaledCoordinates(f, i); if (g.index) { const w = g.index.range(v.x - a, v.y - a, v.x + a, v.y + a).sort(); for (const I of w) { const E = g.crossTileIDs[I]; if (!o[E]) { o[E] = !0, f.crossTileID = E; break } } } else if (g.positions) for (let w = 0; w < g.positions.length; w++) { const I = g.positions[w], E = g.crossTileIDs[w]; if (Math.abs(I.x - v.x) <= a && Math.abs(I.y - v.y) <= a && !o[E]) { o[E] = !0, f.crossTileID = E; break } } } } getCrossTileIDsLists() { return Object.values(this._symbolsByKey).map(({ crossTileIDs: e }) => e) } } class Ha { constructor() { this.maxCrossTileID = 0 } generate() { return ++this.maxCrossTileID } } class Io { constructor() { this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0 } handleWrapJump(e) { const i = Math.round((e - this.lng) / 360); if (i !== 0) for (const o in this.indexes) { const a = this.indexes[o], h = {}; for (const f in a) { const g = a[f]; g.tileID = g.tileID.unwrapTo(g.tileID.wrap + i), h[g.tileID.key] = g } this.indexes[o] = h } this.lng = e } addBucket(e, i, o) { if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) { if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === i.bucketInstanceId) return !1; this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]) } for (let h = 0; h < i.symbolInstances.length; h++)i.symbolInstances.get(h).crossTileID = 0; this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {}); const a = this.usedCrossTileIDs[e.overscaledZ]; for (const h in this.indexes) { const f = this.indexes[h]; if (Number(h) > e.overscaledZ) for (const g in f) { const v = f[g]; v.tileID.isChildOf(e) && v.findMatches(i.symbolInstances, e, a) } else { const g = f[e.scaledTo(Number(h)).key]; g && g.findMatches(i.symbolInstances, e, a) } } for (let h = 0; h < i.symbolInstances.length; h++) { const f = i.symbolInstances.get(h); f.crossTileID || (f.crossTileID = o.generate(), a[f.crossTileID] = !0) } return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new qa(e, i.symbolInstances, i.bucketInstanceId), !0 } removeBucketCrossTileIDs(e, i) { for (const o of i.getCrossTileIDsLists()) for (const a of o) delete this.usedCrossTileIDs[e][a] } removeStaleBuckets(e) { let i = !1; for (const o in this.indexes) { const a = this.indexes[o]; for (const h in a) e[a[h].bucketInstanceId] || (this.removeBucketCrossTileIDs(o, a[h]), delete a[h], i = !0) } return i } } class Wa { constructor() { this.layerIndexes = {}, this.crossTileIDs = new Ha, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {} } addLayer(e, i, o) { let a = this.layerIndexes[e.id]; a === void 0 && (a = this.layerIndexes[e.id] = new Io); let h = !1; const f = {}; a.handleWrapJump(o); for (const g of i) { const v = g.getBucket(e); v && e.id === v.layerIds[0] && (v.bucketInstanceId || (v.bucketInstanceId = ++this.maxBucketInstanceId), a.addBucket(g.tileID, v, this.crossTileIDs) && (h = !0), f[v.bucketInstanceId] = !0) } return a.removeStaleBuckets(f) && (h = !0), h } pruneUnusedLayers(e) { const i = {}; e.forEach(o => { i[o] = !0 }); for (const o in this.layerIndexes) i[o] || delete this.layerIndexes[o] } } var Un = "void main() {fragColor=vec4(1.0);}"; const Wr = {
          prelude: Rt(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Rt("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Rt("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Rt(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Rt(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Rt(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Rt(Un, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Rt(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Rt(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Rt("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Rt("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Rt("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Rt(Un, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Rt(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Rt(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Rt(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Rt(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Rt(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Rt(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Rt(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));fragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Rt(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Rt(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Rt(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Rt(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Rt(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Rt(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Rt(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Rt(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Rt(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Rt("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Rt("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Rt("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Rt("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Rt(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Rt("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
        }; function Rt(u, e) {
          const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o = e.match(/in ([\w]+) ([\w]+)/g), a = u.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), h = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), f = h ? h.concat(a) : a, g = {}; return {
            fragmentSource: u = u.replace(i, (v, w, I, E, A) => (g[A] = !0, w === "define" ? `
#ifndef HAS_UNIFORM_u_${A}
in ${I} ${E} ${A};
#else
uniform ${I} ${E} u_${A};
#endif
`: `
#ifdef HAS_UNIFORM_u_${A}
    ${I} ${E} ${A} = u_${A};
#endif
`)), vertexSource: e = e.replace(i, (v, w, I, E, A) => {
              const B = E === "float" ? "vec2" : "vec4", j = A.match(/color/) ? "color" : B; return g[A] ? w === "define" ? `
#ifndef HAS_UNIFORM_u_${A}
uniform lowp float u_${A}_t;
in ${I} ${B} a_${A};
out ${I} ${E} ${A};
#else
uniform ${I} ${E} u_${A};
#endif
`: j === "vec4" ? `
#ifndef HAS_UNIFORM_u_${A}
    ${A} = a_${A};
#else
    ${I} ${E} ${A} = u_${A};
#endif
`: `
#ifndef HAS_UNIFORM_u_${A}
    ${A} = unpack_mix_${j}(a_${A}, u_${A}_t);
#else
    ${I} ${E} ${A} = u_${A};
#endif
`: w === "define" ? `
#ifndef HAS_UNIFORM_u_${A}
uniform lowp float u_${A}_t;
in ${I} ${B} a_${A};
#else
uniform ${I} ${E} u_${A};
#endif
`: j === "vec4" ? `
#ifndef HAS_UNIFORM_u_${A}
    ${I} ${E} ${A} = a_${A};
#else
    ${I} ${E} ${A} = u_${A};
#endif
`: `
#ifndef HAS_UNIFORM_u_${A}
    ${I} ${E} ${A} = unpack_mix_${j}(a_${A}, u_${A}_t);
#else
    ${I} ${E} ${A} = u_${A};
#endif
`}), staticAttributes: o, staticUniforms: f
          }
        } class vr { constructor(e, i, o) { this.vertexBuffer = e, this.indexBuffer = i, this.segments = o } destroy() { this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null } } var Lr = c.aC([{ name: "a_pos", type: "Int16", components: 2 }]); const Lt = "#define PROJECTION_MERCATOR", Co = "mercator"; class Xa { constructor() { this._cachedMesh = null } get name() { return "mercator" } get useSubdivision() { return !1 } get shaderVariantName() { return Co } get shaderDefine() { return Lt } get shaderPreludeCode() { return Wr.projectionMercator } get vertexShaderPreludeCode() { return Wr.projectionMercator.vertexSource } get subdivisionGranularity() { return c.aD.noSubdivision } get useGlobeControls() { return !1 } get transitionState() { return 0 } get latitudeErrorCorrectionRadians() { return 0 } destroy() { } updateGPUdependent(e) { } getMeshFromTileID(e, i, o, a, h) { if (this._cachedMesh) return this._cachedMesh; const f = new c.aE; f.emplaceBack(0, 0), f.emplaceBack(c.Z, 0), f.emplaceBack(0, c.Z), f.emplaceBack(c.Z, c.Z); const g = e.createVertexBuffer(f, Lr.members), v = c.aF.simpleSegment(0, 0, 4, 2), w = new c.aG; w.emplaceBack(1, 0, 2), w.emplaceBack(1, 2, 3); const I = e.createIndexBuffer(w); return this._cachedMesh = new vr(g, I, v), this._cachedMesh } recalculate() { } hasTransition() { return !1 } setErrorQueryLatitudeDegrees(e) { } } function Fr(u, e) { const i = c.ad(e.lat, -85.051129, c.aI); return new c.P(c.U(e.lng) * u, c.S(i) * u) } function Gi(u, e) { return new c.$(e.x / u, e.y / u).toLngLat() } function Di(u) { return u.cameraToCenterDistance * Math.min(.85 * Math.tan(c.ac(90 - u.pitch)), Math.tan(c.ac(89.25 - u.pitch))) } function hi(u, e) { const i = u.canonical, o = e / c.aH(i.z), a = i.x + Math.pow(2, i.z) * u.wrap, h = c.as(new Float64Array(16)); return c.L(h, h, [a * o, i.y * o, 0]), c.M(h, h, [o / c.Z, o / c.Z, 1]), h } function Ka(u, e, i, o, a) { const h = c.$.fromLngLat(u, e), f = a * c.aJ(1, u.lat), g = f * Math.cos(c.ac(i)), v = Math.sqrt(f * f - g * g), w = v * Math.sin(c.ac(-o)), I = v * Math.cos(c.ac(-o)); return new c.$(h.x + w, h.y + I, h.z + g) } class Ri { constructor(e = 0, i = 0, o = 0, a = 0) { if (isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0 || isNaN(a) || a < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers"); this.top = e, this.bottom = i, this.left = o, this.right = a } interpolate(e, i, o) { return i.top != null && e.top != null && (this.top = c.B.number(e.top, i.top, o)), i.bottom != null && e.bottom != null && (this.bottom = c.B.number(e.bottom, i.bottom, o)), i.left != null && e.left != null && (this.left = c.B.number(e.left, i.left, o)), i.right != null && e.right != null && (this.right = c.B.number(e.right, i.right, o)), this } getCenter(e, i) { const o = c.ad((this.left + e - this.right) / 2, 0, e), a = c.ad((this.top + i - this.bottom) / 2, 0, i); return new c.P(o, a) } equals(e) { return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right } clone() { return new Ri(this.top, this.bottom, this.left, this.right) } toJSON() { return { top: this.top, bottom: this.bottom, left: this.left, right: this.right } } } function nr(u, e) { if (!u.renderWorldCopies || u.lngRange) return; const i = e.lng - u.center.lng; e.lng += i > 180 ? -360 : i < -180 ? 360 : 0 } function dr(u) { return Math.max(0, Math.floor(u)) } class Eo { constructor(e, i, o, a, h, f) { this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = f === void 0 || !!f, this._minZoom = i || 0, this._maxZoom = o || 22, this._minPitch = a ?? 0, this._maxPitch = h ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new c.Q(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = dr(this._zoom), this._scale = c.aH(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Ri, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0 } apply(e, i, o) { this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = dr(this._zoom), this._scale = c.aH(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new Ri(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !o && e.autoCalculateNearFarZ, i && this._constrain(), this._calcMatrices() } get pixelsToClipSpaceMatrix() { return this._pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._clipSpaceToPixelsMatrix } get minElevationForCurrentTile() { return this._minElevationForCurrentTile } setMinElevationForCurrentTile(e) { this._minElevationForCurrentTile = e } get tileSize() { return this._tileSize } get tileZoom() { return this._tileZoom } get scale() { return this._scale } get width() { return this._width } get height() { return this._height } get bearingInRadians() { return this._bearingInRadians } get lngRange() { return this._lngRange } get latRange() { return this._latRange } get pixelsToGLUnits() { return this._pixelsToGLUnits } get minZoom() { return this._minZoom } setMinZoom(e) { this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom)) } get maxZoom() { return this._maxZoom } setMaxZoom(e) { this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom)) } get minPitch() { return this._minPitch } setMinPitch(e) { this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e))) } get maxPitch() { return this._maxPitch } setMaxPitch(e) { this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e))) } get renderWorldCopies() { return this._renderWorldCopies } setRenderWorldCopies(e) { e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e } get worldSize() { return this._tileSize * this._scale } get centerOffset() { return this.centerPoint._sub(this.size._div(2)) } get size() { return new c.P(this._width, this._height) } get bearing() { return this._bearingInRadians / Math.PI * 180 } setBearing(e) { const i = c.aK(e, -180, 180) * Math.PI / 180; var o, a, h, f, g, v, w, I, E; this._bearingInRadians !== i && (this._unmodified = !1, this._bearingInRadians = i, this._calcMatrices(), this._rotationMatrix = ze(), o = this._rotationMatrix, h = -this._bearingInRadians, f = (a = this._rotationMatrix)[0], g = a[1], v = a[2], w = a[3], I = Math.sin(h), E = Math.cos(h), o[0] = f * E + v * I, o[1] = g * E + w * I, o[2] = f * -I + v * E, o[3] = g * -I + w * E) } get rotationMatrix() { return this._rotationMatrix } get pitchInRadians() { return this._pitchInRadians } get pitch() { return this._pitchInRadians / Math.PI * 180 } setPitch(e) { const i = c.ad(e, this.minPitch, this.maxPitch) / 180 * Math.PI; this._pitchInRadians !== i && (this._unmodified = !1, this._pitchInRadians = i, this._calcMatrices()) } get rollInRadians() { return this._rollInRadians } get roll() { return this._rollInRadians / Math.PI * 180 } setRoll(e) { const i = e / 180 * Math.PI; this._rollInRadians !== i && (this._unmodified = !1, this._rollInRadians = i, this._calcMatrices()) } get fovInRadians() { return this._fovInRadians } get fov() { return c.aL(this._fovInRadians) } setFov(e) { e = c.ad(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = c.ac(e), this._calcMatrices()) } get zoom() { return this._zoom } setZoom(e) { const i = this.getConstrained(this._center, e).zoom; this._zoom !== i && (this._unmodified = !1, this._zoom = i, this._tileZoom = Math.max(0, Math.floor(i)), this._scale = c.aH(i), this._constrain(), this._calcMatrices()) } get center() { return this._center } setCenter(e) { e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices()) } get elevation() { return this._elevation } setElevation(e) { e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices()) } get padding() { return this._edgeInsets.toJSON() } setPadding(e) { this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices()) } get centerPoint() { return this._edgeInsets.getCenter(this._width, this._height) } get pixelsPerMeter() { return this._pixelPerMeter } get unmodified() { return this._unmodified } get cameraToCenterDistance() { return this._cameraToCenterDistance } get nearZ() { return this._nearZ } get farZ() { return this._farZ } get autoCalculateNearFarZ() { return this._autoCalculateNearFarZ } overrideNearFarZ(e, i) { this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = i, this._calcMatrices() } clearNearFarZOverride() { this._autoCalculateNearFarZ = !0, this._calcMatrices() } isPaddingEqual(e) { return this._edgeInsets.equals(e) } interpolatePadding(e, i, o) { this._unmodified = !1, this._edgeInsets.interpolate(e, i, o), this._constrain(), this._calcMatrices() } resize(e, i, o = !0) { this._width = e, this._height = i, o && this._constrain(), this._calcMatrices() } getMaxBounds() { return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new we([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null } setMaxBounds(e) { e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-85.051129, c.aI]) } getConstrained(e, i) { return this._callbacks.getConstrained(e, i) } getCameraQueryGeometry(e, i) { if (i.length === 1) return [i[0], e]; { let o = e.x, a = e.y, h = e.x, f = e.y; for (const g of i) o = Math.min(o, g.x), a = Math.min(a, g.y), h = Math.max(h, g.x), f = Math.max(f, g.y); return [new c.P(o, a), new c.P(h, a), new c.P(h, f), new c.P(o, f), new c.P(o, a)] } } _constrain() { if (!this.center || !this._width || !this._height || this._constraining) return; this._constraining = !0; const e = this._unmodified, { center: i, zoom: o } = this.getConstrained(this.center, this.zoom); this.setCenter(i), this.setZoom(o), this._unmodified = e, this._constraining = !1 } _calcMatrices() { if (this._width && this._height) { this._pixelsToGLUnits = [2 / this._width, -2 / this._height]; let e = c.as(new Float64Array(16)); c.M(e, e, [this._width / 2, -this._height / 2, 1]), c.L(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = c.as(new Float64Array(16)), c.M(e, e, [1, -1, 1]), c.L(e, e, [-1, -1, 0]), c.M(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height } this._callbacks.calcMatrices() } calculateCenterFromCameraLngLatAlt(e, i, o, a) { const h = o !== void 0 ? o : this.bearing, f = a = a !== void 0 ? a : this.pitch, g = c.$.fromLngLat(e, i), v = -Math.cos(c.ac(f)), w = Math.sin(c.ac(f)), I = w * Math.sin(c.ac(h)), E = -w * Math.cos(c.ac(h)); let A = this.elevation; const B = i - A; let j; v * B >= 0 || Math.abs(v) < .1 ? (j = 1e4, A = i + j * v) : j = -B / v; let q, G, H = c.aM(1, g.y), K = 0; do { if (K += 1, K > 10) break; G = j / H, q = new c.$(g.x + I * G, g.y + E * G), H = 1 / q.meterInMercatorCoordinateUnits() } while (Math.abs(j - G * H) > 1e-12); return { center: q.toLngLat(), elevation: A, zoom: c.aa(this.height / 2 / Math.tan(this.fovInRadians / 2) / G / this.tileSize) } } recalculateZoomAndCenter(e) { if (this.elevation - e == 0) return; const i = c.aJ(1, this.center.lat) * this.worldSize, o = this.cameraToCenterDistance / i, a = c.$.fromLngLat(this.center, this.elevation), h = Ka(this.center, this.elevation, this.pitch, this.bearing, o); this._elevation = e; const f = this.calculateCenterFromCameraLngLatAlt(h.toLngLat(), c.aM(h.z, a.y), this.bearing, this.pitch); this._elevation = f.elevation, this._center = f.center, this.setZoom(f.zoom) } getCameraPoint() { const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1); return this.centerPoint.add(new c.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians))) } getCameraAltitude() { return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation } getCameraLngLat() { const e = c.aJ(1, this.center.lat) * this.worldSize; return Ka(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat() } getMercatorTileCoordinates(e) { if (!e) return [0, 0, 1, 1]; const i = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z); return [e.canonical.x / i, e.canonical.y / i, 1 / i / c.Z, 1 / i / c.Z] } } class Xr { constructor(e, i) { this.min = e, this.max = i, this.center = c.aN([], c.aO([], this.min, this.max), .5) } quadrant(e) { const i = [e % 2 == 0, e < 2], o = c.aP(this.min), a = c.aP(this.max); for (let h = 0; h < i.length; h++)o[h] = i[h] ? this.min[h] : this.center[h], a[h] = i[h] ? this.center[h] : this.max[h]; return a[2] = this.max[2], new Xr(o, a) } distanceX(e) { return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0] } distanceY(e) { return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1] } intersectsFrustum(e) { let i = !0; for (let o = 0; o < e.planes.length; o++) { const a = this.intersectsPlane(e.planes[o]); if (a === 0) return 0; a === 1 && (i = !1) } return i ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1 } intersectsPlane(e) { let i = e[3], o = e[3]; for (let a = 0; a < 3; a++)e[a] > 0 ? (i += e[a] * this.min[a], o += e[a] * this.max[a]) : (o += e[a] * this.min[a], i += e[a] * this.max[a]); return i >= 0 ? 2 : o < 0 ? 0 : 1 } } class Ti { distanceToTile2d(e, i, o, a) { const h = a.distanceX([e, i]), f = a.distanceY([e, i]); return Math.hypot(h, f) } getWrap(e, i, o) { return o } getTileAABB(e, i, o, a) { var h, f; let g = o, v = o; if (a.terrain) { const I = new c.Y(e.z, i, e.z, e.x, e.y), E = a.terrain.getMinMaxElevation(I); g = (h = E.minElevation) !== null && h !== void 0 ? h : o, v = (f = E.maxElevation) !== null && f !== void 0 ? f : o } const w = 1 << e.z; return new Xr([i + e.x / w, e.y / w, g], [i + (e.x + 1) / w, (e.y + 1) / w, v]) } allowVariableZoom(e, i) { const o = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, a = c.ad(78.5 - o / 2, 0, 60); return !!i.terrain || e.pitch > a } allowWorldCopies() { return !0 } recalculateCache() { } } class Mn { constructor(e, i, o) { this.points = e, this.planes = i, this.aabb = o } static fromInvProjectionMatrix(e, i = 1, o = 0) { const a = Math.pow(2, o), h = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(w => { const I = 1 / (w = c.ao([], w, e))[3] / i * a; return c.aQ(w, w, [I, I, 1 / w[3], I]) }), f = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(w => { const I = c.aR([], h[w[0]], h[w[1]]), E = c.aR([], h[w[2]], h[w[1]]), A = c.aS([], c.aT([], I, E)), B = -c.aU(A, h[w[1]]); return A.concat(B) }), g = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], v = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]; for (const w of h) for (let I = 0; I < 3; I++)g[I] = Math.min(g[I], w[I]), v[I] = Math.max(v[I], w[I]); return new Mn(h, f, new Xr(g, v)) } } class Br { get pixelsToClipSpaceMatrix() { return this._helper.pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._helper.clipSpaceToPixelsMatrix } get pixelsToGLUnits() { return this._helper.pixelsToGLUnits } get centerOffset() { return this._helper.centerOffset } get size() { return this._helper.size } get rotationMatrix() { return this._helper.rotationMatrix } get centerPoint() { return this._helper.centerPoint } get pixelsPerMeter() { return this._helper.pixelsPerMeter } setMinZoom(e) { this._helper.setMinZoom(e) } setMaxZoom(e) { this._helper.setMaxZoom(e) } setMinPitch(e) { this._helper.setMinPitch(e) } setMaxPitch(e) { this._helper.setMaxPitch(e) } setRenderWorldCopies(e) { this._helper.setRenderWorldCopies(e) } setBearing(e) { this._helper.setBearing(e) } setPitch(e) { this._helper.setPitch(e) } setRoll(e) { this._helper.setRoll(e) } setFov(e) { this._helper.setFov(e) } setZoom(e) { this._helper.setZoom(e) } setCenter(e) { this._helper.setCenter(e) } setElevation(e) { this._helper.setElevation(e) } setMinElevationForCurrentTile(e) { this._helper.setMinElevationForCurrentTile(e) } setPadding(e) { this._helper.setPadding(e) } interpolatePadding(e, i, o) { return this._helper.interpolatePadding(e, i, o) } isPaddingEqual(e) { return this._helper.isPaddingEqual(e) } resize(e, i, o = !0) { this._helper.resize(e, i, o) } getMaxBounds() { return this._helper.getMaxBounds() } setMaxBounds(e) { this._helper.setMaxBounds(e) } overrideNearFarZ(e, i) { this._helper.overrideNearFarZ(e, i) } clearNearFarZOverride() { this._helper.clearNearFarZOverride() } getCameraQueryGeometry(e) { return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e) } get tileSize() { return this._helper.tileSize } get tileZoom() { return this._helper.tileZoom } get scale() { return this._helper.scale } get worldSize() { return this._helper.worldSize } get width() { return this._helper.width } get height() { return this._helper.height } get lngRange() { return this._helper.lngRange } get latRange() { return this._helper.latRange } get minZoom() { return this._helper.minZoom } get maxZoom() { return this._helper.maxZoom } get zoom() { return this._helper.zoom } get center() { return this._helper.center } get minPitch() { return this._helper.minPitch } get maxPitch() { return this._helper.maxPitch } get pitch() { return this._helper.pitch } get pitchInRadians() { return this._helper.pitchInRadians } get roll() { return this._helper.roll } get rollInRadians() { return this._helper.rollInRadians } get bearing() { return this._helper.bearing } get bearingInRadians() { return this._helper.bearingInRadians } get fov() { return this._helper.fov } get fovInRadians() { return this._helper.fovInRadians } get elevation() { return this._helper.elevation } get minElevationForCurrentTile() { return this._helper.minElevationForCurrentTile } get padding() { return this._helper.padding } get unmodified() { return this._helper.unmodified } get renderWorldCopies() { return this._helper.renderWorldCopies } get cameraToCenterDistance() { return this._helper.cameraToCenterDistance } get nearZ() { return this._helper.nearZ } get farZ() { return this._helper.farZ } get autoCalculateNearFarZ() { return this._helper.autoCalculateNearFarZ } setTransitionState(e, i) { } constructor(e, i, o, a, h) { this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this._helper = new Eo({ calcMatrices: () => { this._calcMatrices() }, getConstrained: (f, g) => this.getConstrained(f, g) }, e, i, o, a, h), this._coveringTilesDetailsProvider = new Ti } clone() { const e = new Br; return e.apply(this), e } apply(e, i, o) { this._helper.apply(e, i, o) } get cameraPosition() { return this._cameraPosition } get projectionMatrix() { return this._projectionMatrix } get modelViewProjectionMatrix() { return this._viewProjMatrix } get inverseProjectionMatrix() { return this._invProjMatrix } get mercatorMatrix() { return this._mercatorMatrix } getVisibleUnwrappedCoordinates(e) { const i = [new c.aV(0, e)]; if (this._helper._renderWorldCopies) { const o = this.screenPointToMercatorCoordinate(new c.P(0, 0)), a = this.screenPointToMercatorCoordinate(new c.P(this._helper._width, 0)), h = this.screenPointToMercatorCoordinate(new c.P(this._helper._width, this._helper._height)), f = this.screenPointToMercatorCoordinate(new c.P(0, this._helper._height)), g = Math.floor(Math.min(o.x, a.x, h.x, f.x)), v = Math.floor(Math.max(o.x, a.x, h.x, f.x)), w = 1; for (let I = g - w; I <= v + w; I++)I !== 0 && i.push(new c.aV(I, e)) } return i } getCameraFrustum() { return Mn.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize) } getClippingPlane() { return null } getCoveringTilesDetailsProvider() { return this._coveringTilesDetailsProvider } recalculateZoomAndCenter(e) { const i = this.screenPointToLocation(this.centerPoint, e), o = e ? e.getElevationForLngLatZoom(i, this._helper._tileZoom) : 0; this._helper.recalculateZoomAndCenter(o) } setLocationAtPoint(e, i) { const o = c.aJ(this.elevation, this.center.lat), a = this.screenPointToMercatorCoordinateAtZ(i, o), h = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, o), f = c.$.fromLngLat(e), g = new c.$(f.x - (a.x - h.x), f.y - (a.y - h.y)); this.setCenter(g == null ? void 0 : g.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap()) } locationToScreenPoint(e, i) { return i ? this.coordinatePoint(c.$.fromLngLat(e), i.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(c.$.fromLngLat(e)) } screenPointToLocation(e, i) { var o; return (o = this.screenPointToMercatorCoordinate(e, i)) === null || o === void 0 ? void 0 : o.toLngLat() } screenPointToMercatorCoordinate(e, i) { if (i) { const o = i.pointCoordinate(e); if (o != null) return o } return this.screenPointToMercatorCoordinateAtZ(e) } screenPointToMercatorCoordinateAtZ(e, i) { const o = i || 0, a = [e.x, e.y, 0, 1], h = [e.x, e.y, 1, 1]; c.ao(a, a, this._pixelMatrixInverse), c.ao(h, h, this._pixelMatrixInverse); const f = a[3], g = h[3], v = a[1] / f, w = h[1] / g, I = a[2] / f, E = h[2] / g, A = I === E ? 0 : (o - I) / (E - I); return new c.$(c.B.number(a[0] / f, h[0] / g, A) / this.worldSize, c.B.number(v, w, A) / this.worldSize, o) } coordinatePoint(e, i = 0, o = this._pixelMatrix) { const a = [e.x * this.worldSize, e.y * this.worldSize, i, 1]; return c.ao(a, a, o), new c.P(a[0] / a[3], a[1] / a[3]) } getBounds() { const e = Math.max(0, this._helper._height / 2 - Di(this)); return new we().extend(this.screenPointToLocation(new c.P(0, e))).extend(this.screenPointToLocation(new c.P(this._helper._width, e))).extend(this.screenPointToLocation(new c.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new c.P(0, this._helper._height))) } isPointOnMapSurface(e, i) { return i ? i.pointCoordinate(e) != null : e.y > this.height / 2 - Di(this) } calculatePosMatrix(e, i = !1, o) { var a; const h = (a = e.key) !== null && a !== void 0 ? a : c.aW(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), f = i ? this._alignedPosMatrixCache : this._posMatrixCache; if (f.has(h)) { const w = f.get(h); return o ? w.f32 : w.f64 } const g = hi(e, this.worldSize); c.N(g, i ? this._alignedProjMatrix : this._viewProjMatrix, g); const v = { f64: g, f32: new Float32Array(g) }; return f.set(h, v), o ? v.f32 : v.f64 } calculateFogMatrix(e) { const i = e.key, o = this._fogMatrixCacheF32; if (o.has(i)) return o.get(i); const a = hi(e, this.worldSize); return c.N(a, this._fogMatrix, a), o.set(i, new Float32Array(a)), o.get(i) } getConstrained(e, i) { i = c.ad(+i, this.minZoom, this.maxZoom); const o = { center: new c.Q(e.lng, e.lat), zoom: i }; let a = this._helper._lngRange; this._helper._renderWorldCopies || a !== null || (a = [-179.9999999999, 180 - 1e-10]); const h = this.tileSize * c.aH(o.zoom); let f = 0, g = h, v = 0, w = h, I = 0, E = 0; const { x: A, y: B } = this.size; if (this._helper._latRange) { const Q = this._helper._latRange; f = c.S(Q[1]) * h, g = c.S(Q[0]) * h, g - f < B && (I = B / (g - f)) } a && (v = c.aK(c.U(a[0]) * h, 0, h), w = c.aK(c.U(a[1]) * h, 0, h), w < v && (w += h), w - v < A && (E = A / (w - v))); const { x: j, y: q } = Fr(h, e); let G, H; const K = Math.max(E || 0, I || 0); if (K) { const Q = new c.P(E ? (w + v) / 2 : j, I ? (g + f) / 2 : q); return o.center = Gi(h, Q).wrap(), o.zoom += c.aa(K), o } if (this._helper._latRange) { const Q = B / 2; q - Q < f && (H = f + Q), q + Q > g && (H = g - Q) } if (a) { const Q = (v + w) / 2; let ee = j; this._helper._renderWorldCopies && (ee = c.aK(j, Q - h / 2, Q + h / 2)); const re = A / 2; ee - re < v && (G = v + re), ee + re > w && (G = w - re) } if (G !== void 0 || H !== void 0) { const Q = new c.P(G ?? j, H ?? q); o.center = Gi(h, Q).wrap() } return o } calculateCenterFromCameraLngLatAlt(e, i, o, a) { return this._helper.calculateCenterFromCameraLngLatAlt(e, i, o, a) } _calculateNearFarZIfNeeded(e, i, o) { if (!this._helper.autoCalculateNearFarZ) return; const a = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), h = e - a * this._helper._pixelPerMeter / Math.cos(i), f = a < 0 ? h : e, g = Math.PI / 2 + this.pitchInRadians, v = c.ac(this.fov) * (Math.abs(Math.cos(c.ac(this.roll))) * this.height + Math.abs(Math.sin(c.ac(this.roll))) * this.width) / this.height * (.5 + o.y / this.height), w = Math.sin(v) * f / Math.sin(c.ad(Math.PI - g - v, .01, Math.PI - .01)), I = Di(this), E = Math.atan(I / this._helper.cameraToCenterDistance), A = c.ac(.75), B = E > A ? 2 * E * (.5 + o.y / (2 * I)) : A, j = Math.sin(B) * f / Math.sin(c.ad(Math.PI - g - B, .01, Math.PI - .01)), q = Math.min(w, j); this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * q + f), this._helper._nearZ = this._helper._height / 50 } _calcMatrices() { if (!this._helper._height) return; const e = this.centerOffset, i = Fr(this.worldSize, this.center), o = i.x, a = i.y; this._helper._pixelPerMeter = c.aJ(1, this.center.lat) * this.worldSize; const h = c.ac(Math.min(this.pitch, 89.25)), f = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(h)); let g; this._calculateNearFarZIfNeeded(f, h, e), g = new Float64Array(16), c.aX(g, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), c.ai(this._invProjMatrix, g), g[8] = 2 * -e.x / this._helper._width, g[9] = 2 * e.y / this._helper._height, this._projectionMatrix = c.aY(g), c.M(g, g, [1, -1, 1]), c.L(g, g, [0, 0, -this._helper.cameraToCenterDistance]), c.aZ(g, g, -this.rollInRadians), c.a_(g, g, this.pitchInRadians), c.aZ(g, g, -this.bearingInRadians), c.L(g, g, [-o, -a, 0]), this._mercatorMatrix = c.M([], g, [this.worldSize, this.worldSize, this.worldSize]), c.M(g, g, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = c.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, g), c.L(g, g, [0, 0, -this.elevation]), this._viewProjMatrix = g, this._invViewProjMatrix = c.ai([], g); const v = [0, 0, -1, 1]; c.ao(v, v, this._invViewProjMatrix), this._cameraPosition = [v[0] / v[3], v[1] / v[3], v[2] / v[3]], this._fogMatrix = new Float64Array(16), c.aX(this._fogMatrix, this.fovInRadians, this.width / this.height, f, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, c.M(this._fogMatrix, this._fogMatrix, [1, -1, 1]), c.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), c.aZ(this._fogMatrix, this._fogMatrix, -this.rollInRadians), c.a_(this._fogMatrix, this._fogMatrix, this.pitchInRadians), c.aZ(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), c.L(this._fogMatrix, this._fogMatrix, [-o, -a, 0]), c.M(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), c.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = c.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, g); const w = this._helper._width % 2 / 2, I = this._helper._height % 2 / 2, E = Math.cos(this.bearingInRadians), A = Math.sin(-this.bearingInRadians), B = o - Math.round(o) + E * w + A * I, j = a - Math.round(a) + E * I + A * w, q = new Float64Array(g); if (c.L(q, q, [B > .5 ? B - 1 : B, j > .5 ? j - 1 : j, 0]), this._alignedProjMatrix = q, g = c.ai(new Float64Array(16), this._pixelMatrix), !g) throw new Error("failed to invert matrix"); this._pixelMatrixInverse = g, this._clearMatrixCaches() } _clearMatrixCaches() { this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear() } maxPitchScaleFactor() { if (!this._pixelMatrixInverse) return 1; const e = this.screenPointToMercatorCoordinate(new c.P(0, 0)), i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1]; return c.ao(i, i, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance } getCameraPoint() { return this._helper.getCameraPoint() } getCameraAltitude() { return this._helper.getCameraAltitude() } getCameraLngLat() { const e = c.aJ(1, this.center.lat) * this.worldSize; return Ka(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat() } lngLatToCameraDepth(e, i) { const o = c.$.fromLngLat(e), a = [o.x * this.worldSize, o.y * this.worldSize, i, 1]; return c.ao(a, a, this._viewProjMatrix), a[2] / a[3] } getProjectionData(e) { const { overscaledTileID: i, aligned: o, applyTerrainMatrix: a } = e, h = this._helper.getMercatorTileCoordinates(i), f = i ? this.calculatePosMatrix(i, o, !0) : null; let g; return g = i && i.terrainRttPosMatrix32f && a ? i.terrainRttPosMatrix32f : f || c.a$(), { mainMatrix: g, tileMercatorCoords: h, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: g } } isLocationOccluded(e) { return !1 } getPixelScale() { return 1 } getCircleRadiusCorrection() { return 1 } getPitchedTextCorrection(e, i, o) { return 1 } transformLightDirection(e) { return c.aP(e) } getRayDirectionFromPixel(e) { throw new Error("Not implemented.") } projectTileCoordinates(e, i, o, a) { const h = this.calculatePosMatrix(o); let f; a ? (f = [e, i, a(e, i), 1], c.ao(f, f, h)) : (f = [e, i, 0, 1], Mi(f, f, h)); const g = f[3]; return { point: new c.P(f[0] / g, f[1] / g), signedDistanceFromCamera: g, isOccluded: !1 } } populateCache(e) { for (const i of e) this.calculatePosMatrix(i) } getMatrixForModel(e, i) { const o = c.$.fromLngLat(e, i), a = o.meterInMercatorCoordinateUnits(), h = c.b0(); return c.L(h, h, [o.x, o.y, o.z]), c.aZ(h, h, Math.PI), c.a_(h, h, Math.PI / 2), c.M(h, h, [-a, a, a]), h } getProjectionDataForCustomLayer(e = !0) { const i = new c.Y(0, 0, 0, 0, 0), o = this.getProjectionData({ overscaledTileID: i, applyGlobeMatrix: e }), a = hi(i, this.worldSize); c.N(a, this._viewProjMatrix, a), o.tileMercatorCoords = [0, 0, 1, 1]; const h = [c.Z, c.Z, this.worldSize / this._helper.pixelsPerMeter], f = c.b1(); return c.M(f, a, h), o.fallbackMatrix = f, o.mainMatrix = f, o } getFastPathSimpleProjectionMatrix(e) { return this.calculatePosMatrix(e) } } function Hs() { c.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.") } function Or(u) { if (u.useSlerp) if (u.k < 1) { const e = c.b2(u.startEulerAngles.roll, u.startEulerAngles.pitch, u.startEulerAngles.bearing), i = c.b2(u.endEulerAngles.roll, u.endEulerAngles.pitch, u.endEulerAngles.bearing), o = new Float64Array(4); c.b3(o, e, i, u.k); const a = c.b4(o); u.tr.setRoll(a.roll), u.tr.setPitch(a.pitch), u.tr.setBearing(a.bearing) } else u.tr.setRoll(u.endEulerAngles.roll), u.tr.setPitch(u.endEulerAngles.pitch), u.tr.setBearing(u.endEulerAngles.bearing); else u.tr.setRoll(c.B.number(u.startEulerAngles.roll, u.endEulerAngles.roll, u.k)), u.tr.setPitch(c.B.number(u.startEulerAngles.pitch, u.endEulerAngles.pitch, u.k)), u.tr.setBearing(c.B.number(u.startEulerAngles.bearing, u.endEulerAngles.bearing, u.k)) } function Ja(u, e, i, o, a) { const h = a.padding, f = Fr(a.worldSize, i.getNorthWest()), g = Fr(a.worldSize, i.getNorthEast()), v = Fr(a.worldSize, i.getSouthEast()), w = Fr(a.worldSize, i.getSouthWest()), I = c.ac(-o), E = f.rotate(I), A = g.rotate(I), B = v.rotate(I), j = w.rotate(I), q = new c.P(Math.max(E.x, A.x, j.x, B.x), Math.max(E.y, A.y, j.y, B.y)), G = new c.P(Math.min(E.x, A.x, j.x, B.x), Math.min(E.y, A.y, j.y, B.y)), H = q.sub(G), K = (a.width - (h.left + h.right + e.left + e.right)) / H.x, Q = (a.height - (h.top + h.bottom + e.top + e.bottom)) / H.y; if (Q < 0 || K < 0) return void Hs(); const ee = Math.min(c.aa(a.scale * Math.min(K, Q)), u.maxZoom), re = c.P.convert(u.offset), oe = new c.P((e.left - e.right) / 2, (e.top - e.bottom) / 2).rotate(c.ac(o)), ne = re.add(oe).mult(a.scale / c.aH(ee)); return { center: Gi(a.worldSize, f.add(v).div(2).sub(ne)), zoom: ee, bearing: o } } class Kr { get useGlobeControls() { return !1 } handlePanInertia(e, i) { return { easingOffset: e, easingCenter: i.center } } handleMapControlsRollPitchBearingZoom(e, i) { e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta), e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta) } handleMapControlsPan(e, i, o) { e.around.distSqr(i.centerPoint) < .01 || i.setLocationAtPoint(o, e.around) } cameraForBoxAndBearing(e, i, o, a, h) { return Ja(e, i, o, a, h) } handleJumpToCenterZoom(e, i) { e.zoom !== (i.zoom !== void 0 ? +i.zoom : e.zoom) && e.setZoom(+i.zoom), i.center !== void 0 && e.setCenter(c.Q.convert(i.center)) } handleEaseTo(e, i) { const o = e.zoom, a = e.padding, h = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, f = { roll: i.roll === void 0 ? e.roll : i.roll, pitch: i.pitch === void 0 ? e.pitch : i.pitch, bearing: i.bearing === void 0 ? e.bearing : i.bearing }, g = i.zoom !== void 0, v = !e.isPaddingEqual(i.padding); let w = !1; const I = g ? +i.zoom : e.zoom; let E = e.centerPoint.add(i.offsetAsPoint); const A = e.screenPointToLocation(E), { center: B, zoom: j } = e.getConstrained(c.Q.convert(i.center || A), I ?? o); nr(e, B); const q = Fr(e.worldSize, A), G = Fr(e.worldSize, B).sub(q), H = c.aH(j - o); return w = j !== o, { easeFunc: K => { if (w && e.setZoom(c.B.number(o, j, K)), c.b5(h, f) || Or({ startEulerAngles: h, endEulerAngles: f, tr: e, k: K, useSlerp: h.roll != f.roll }), v && (e.interpolatePadding(a, i.padding, K), E = e.centerPoint.add(i.offsetAsPoint)), i.around) e.setLocationAtPoint(i.around, i.aroundPoint); else { const Q = c.aH(e.zoom - o), ee = j > o ? Math.min(2, H) : Math.max(.5, H), re = Math.pow(ee, 1 - K), oe = Gi(e.worldSize, q.add(G.mult(K * re)).mult(Q)); e.setLocationAtPoint(e.renderWorldCopies ? oe.wrap() : oe, E) } }, isZooming: w, elevationCenter: B } } handleFlyTo(e, i) { const o = i.zoom !== void 0, a = e.zoom, h = e.getConstrained(c.Q.convert(i.center || i.locationAtOffset), o ? +i.zoom : a), f = h.center, g = h.zoom; nr(e, f); const v = Fr(e.worldSize, i.locationAtOffset), w = Fr(e.worldSize, f).sub(v), I = w.mag(), E = c.aH(g - a); let A; if (i.minZoom !== void 0) { const B = Math.min(+i.minZoom, a, g), j = e.getConstrained(f, B).zoom; A = c.aH(j - a) } return { easeFunc: (B, j, q, G) => { e.setZoom(B === 1 ? g : a + c.aa(j)); const H = B === 1 ? f : Gi(e.worldSize, v.add(w.mult(q)).mult(j)); e.setLocationAtPoint(e.renderWorldCopies ? H.wrap() : H, G) }, scaleOfZoom: E, targetCenter: f, scaleOfMinZoom: A, pixelPathLength: I } } } class ni { constructor(e, i, o) { this.blendFunction = e, this.blendColor = i, this.mask = o } } ni.Replace = [1, 0], ni.disabled = new ni(ni.Replace, c.b6.transparent, [!1, !1, !1, !1]), ni.unblended = new ni(ni.Replace, c.b6.transparent, [!0, !0, !0, !0]), ni.alphaBlended = new ni([1, 771], c.b6.transparent, [!0, !0, !0, !0]); const Ao = 2305; class Ct { constructor(e, i, o) { this.enable = e, this.mode = i, this.frontFace = o } } Ct.disabled = new Ct(!1, 1029, Ao), Ct.backCCW = new Ct(!0, 1029, Ao), Ct.frontCCW = new Ct(!0, 1028, Ao); class yt { constructor(e, i, o) { this.func = e, this.mask = i, this.range = o } } yt.ReadOnly = !1, yt.ReadWrite = !0, yt.disabled = new yt(519, yt.ReadOnly, [0, 1]); const ys = 7680; class zt { constructor(e, i, o, a, h, f) { this.test = e, this.ref = i, this.mask = o, this.fail = a, this.depthFail = h, this.pass = f } } zt.disabled = new zt({ func: 519, mask: 0 }, 0, 0, ys, ys, ys); const Ws = new WeakMap; function jr(u) { var e; if (Ws.has(u)) return Ws.get(u); { const i = (e = u.getParameter(u.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0"); return Ws.set(u, i), i } } class Xs { get awaitingQuery() { return !!this._readbackQueue } constructor(e) { this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e; const i = e.context, o = i.gl; this._texFormat = o.RGBA, this._texType = o.UNSIGNED_BYTE; const a = new c.aE; a.emplaceBack(-1, -1), a.emplaceBack(2, -1), a.emplaceBack(-1, 2); const h = new c.aG; h.emplaceBack(0, 1, 2), this._fullscreenTriangle = new vr(i.createVertexBuffer(a, Lr.members), i.createIndexBuffer(h), c.aF.simpleSegment(0, 0, a.length, h.length)), this._resultBuffer = new Uint8Array(4), i.activeTexture.set(o.TEXTURE1); const f = o.createTexture(); o.bindTexture(o.TEXTURE_2D, f), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.NEAREST), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.NEAREST), o.texImage2D(o.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(f), jr(o) && (this._pbo = o.createBuffer(), o.bindBuffer(o.PIXEL_PACK_BUFFER, this._pbo), o.bufferData(o.PIXEL_PACK_BUFFER, 4, o.STREAM_READ), o.bindBuffer(o.PIXEL_PACK_BUFFER, null)) } destroy() { const e = this._cachedRenderContext.context.gl; this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null } updateErrorLoop(e, i) { const o = this._updateCount; return this._readbackQueue ? o >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : o >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, i), this._updateCount++, this._measuredError } _bindFramebuffer() { const e = this._cachedRenderContext.context, i = e.gl; e.activeTexture.set(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer) } _renderErrorTexture(e, i) { const o = this._cachedRenderContext.context, a = o.gl; if (this._bindFramebuffer(), o.viewport.set([0, 0, this._texWidth, this._texHeight]), o.clear({ color: c.b6.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(o, a.TRIANGLES, yt.disabled, zt.disabled, ni.unblended, Ct.disabled, ((h, f) => ({ u_input: h, u_output_expected: f }))(e, i), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && jr(a)) { a.bindBuffer(a.PIXEL_PACK_BUFFER, this._pbo), a.readBuffer(a.COLOR_ATTACHMENT0), a.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), a.bindBuffer(a.PIXEL_PACK_BUFFER, null); const h = a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE, 0); a.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: h } } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null } } _tryReadback() { const e = this._cachedRenderContext.context.gl; if (this._pbo && this._readbackQueue && jr(e)) { const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0); if (i === e.WAIT_FAILED) return c.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount); if (i === e.TIMEOUT_EXPIRED) return; e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null) } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer); this._readbackQueue = null, this._measuredError = Xs._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount } static _parseRGBA8float(e) { let i = 0; return i += e[0] / 256, i += e[1] / 65536, i += e[2] / 16777216, e[3] < 127 && (i = -i), i / 128 } } const zo = c.Z / 128; function Ks(u, e) { const i = u.granularity !== void 0 ? Math.max(u.granularity, 1) : 1, o = i + (u.generateBorders ? 2 : 0), a = i + (u.extendToNorthPole || u.generateBorders ? 1 : 0) + (u.extendToSouthPole || u.generateBorders ? 1 : 0), h = o + 1, f = a + 1, g = u.generateBorders ? -1 : 0, v = u.generateBorders || u.extendToNorthPole ? -1 : 0, w = i + (u.generateBorders ? 1 : 0), I = i + (u.generateBorders || u.extendToSouthPole ? 1 : 0), E = h * f, A = o * a * 6, B = h * f > 65536; if (B && e === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices."); const j = B || e === "32bit", q = new Int16Array(2 * E); let G = 0; for (let Q = v; Q <= I; Q++)for (let ee = g; ee <= w; ee++) { let re = ee / i * c.Z; ee === -1 && (re = -64), ee === i + 1 && (re = c.Z + zo); let oe = Q / i * c.Z; Q === -1 && (oe = u.extendToNorthPole ? c.b8 : -64), Q === i + 1 && (oe = u.extendToSouthPole ? c.b9 : c.Z + zo), q[G++] = re, q[G++] = oe } const H = j ? new Uint32Array(A) : new Uint16Array(A); let K = 0; for (let Q = 0; Q < a; Q++)for (let ee = 0; ee < o; ee++) { const re = ee + 1 + Q * h, oe = ee + (Q + 1) * h, ne = ee + 1 + (Q + 1) * h; H[K++] = ee + Q * h, H[K++] = oe, H[K++] = re, H[K++] = re, H[K++] = oe, H[K++] = ne } return { vertices: q.buffer.slice(0), indices: H.buffer.slice(0), uses32bitIndices: j } } const xs = new c.aD({ fill: new c.ba(128, 2), line: new c.ba(512, 0), tile: new c.ba(128, 32), stencil: new c.ba(128, 1), circle: 3 }); class vs { constructor() { this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3 } get name() { return "vertical-perspective" } get transitionState() { return 1 } get useSubdivision() { return !0 } get shaderVariantName() { return "globe" } get shaderDefine() { return "#define GLOBE" } get shaderPreludeCode() { return Wr.projectionGlobe } get vertexShaderPreludeCode() { return Wr.projectionMercator.vertexSource } get subdivisionGranularity() { return xs } get useGlobeControls() { return !0 } get latitudeErrorCorrectionRadians() { return this._errorCorrectionUsable } destroy() { this._errorMeasurement && this._errorMeasurement.destroy() } updateGPUdependent(e) { this._errorMeasurement || (this._errorMeasurement = new Xs(e)); const i = c.S(this._errorQueryLatitudeDegrees), o = 2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) - .5 * Math.PI, a = this._errorMeasurement.updateErrorLoop(i, o), h = Le.now(); a !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = a, this._errorMeasurementLastChangeTime = h); const f = Math.min(Math.max((h - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1); this._errorCorrectionUsable = c.bb(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, c.bc(f)) } _getMeshKey(e) { return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}` } getMeshFromTileID(e, i, o, a, h) { const f = (h === "stencil" ? xs.stencil : xs.tile).getGranularityForZoomLevel(i.z); return this._getMesh(e, { granularity: f, generateBorders: o, extendToNorthPole: i.y === 0 && a, extendToSouthPole: i.y === (1 << i.z) - 1 && a }) } _getMesh(e, i) { const o = this._getMeshKey(i); if (o in this._tileMeshCache) return this._tileMeshCache[o]; const a = function (h, f) { const g = Ks(f, "16bit"), v = c.aE.deserialize({ arrayBuffer: g.vertices, length: g.vertices.byteLength / 2 / 2 }), w = c.aG.deserialize({ arrayBuffer: g.indices, length: g.indices.byteLength / 2 / 3 }); return new vr(h.createVertexBuffer(v, Lr.members), h.createIndexBuffer(w), c.aF.simpleSegment(0, 0, v.length, w.length)) }(e, i); return this._tileMeshCache[o] = a, a } recalculate(e) { } hasTransition() { const e = Le.now(); let i = !1; return i = i || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, i = i || this._errorMeasurement && this._errorMeasurement.awaitingQuery, i } setErrorQueryLatitudeDegrees(e) { this._errorQueryLatitudeDegrees = e } } const lh = new c.r({ type: new c.D(c.v.projection.type) }); class ko extends c.E { constructor(e) { super(), this._transitionable = new c.T(lh), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new c.C(0)), this._mercatorProjection = new Xa, this._verticalPerspectiveProjection = new vs } get transitionState() { const e = this.properties.get("type"); if (typeof e == "string" && e === "mercator") return 0; if (typeof e == "string" && e === "vertical-perspective") return 1; if (e instanceof c.bd) { if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition; if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition } return 1 } get useGlobeRendering() { return this.transitionState > 0 } get latitudeErrorCorrectionRadians() { return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians } get currentProjection() { return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection } get name() { return "globe" } get useSubdivision() { return this.currentProjection.useSubdivision } get shaderVariantName() { return this.currentProjection.shaderVariantName } get shaderDefine() { return this.currentProjection.shaderDefine } get shaderPreludeCode() { return this.currentProjection.shaderPreludeCode } get vertexShaderPreludeCode() { return this.currentProjection.vertexShaderPreludeCode } get subdivisionGranularity() { return this.currentProjection.subdivisionGranularity } get useGlobeControls() { return this.transitionState > 0 } destroy() { this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy() } updateGPUdependent(e) { this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e) } getMeshFromTileID(e, i, o, a, h) { return this.currentProjection.getMeshFromTileID(e, i, o, a, h) } setProjection(e) { this._transitionable.setValue("type", (e == null ? void 0 : e.type) || "mercator") } updateTransitions(e) { this._transitioning = this._transitionable.transitioned(e, this._transitioning) } hasTransition() { return this._transitioning.hasTransition() || this.currentProjection.hasTransition() } recalculate(e) { this.properties = this._transitioning.possiblyEvaluate(e) } setErrorQueryLatitudeDegrees(e) { this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e) } } function Ya(u) { const e = Qi(u.worldSize, u.center.lat); return 2 * Math.PI * e } function Js(u, e, i, o, a) { const h = 1 / (1 << a), f = e / c.Z * h + o * h, g = c.bf((u / c.Z * h + i * h) * Math.PI * 2 + Math.PI, 2 * Math.PI), v = 2 * Math.atan(Math.exp(Math.PI - f * Math.PI * 2)) - .5 * Math.PI, w = Math.cos(v), I = new Float64Array(3); return I[0] = Math.sin(g) * w, I[1] = Math.sin(v), I[2] = Math.cos(g) * w, I } function Yi(u) { return function (e, i) { const o = Math.cos(i), a = new Float64Array(3); return a[0] = Math.sin(e) * o, a[1] = Math.sin(i), a[2] = Math.cos(e) * o, a }(u.lng * Math.PI / 180, u.lat * Math.PI / 180) } function Qi(u, e) { return u / (2 * Math.PI) / Math.cos(e * Math.PI / 180) } function Do(u) { const e = Math.asin(u[1]) / Math.PI * 180, i = Math.sqrt(u[0] * u[0] + u[2] * u[2]); if (i > 1e-6) { const o = u[0] / i, a = Math.acos(u[2] / i), h = (o > 0 ? a : -a) / Math.PI * 180; return new c.Q(c.aK(h, -180, 180), e) } return new c.Q(0, e) } function br(u) { return Math.cos(u * Math.PI / 180) } function yi(u, e) { const i = br(u), o = br(e); return c.aa(o / i) } function Qa(u, e) { const i = u.rotate(e.bearingInRadians), o = e.zoom + yi(e.center.lat, 0), a = c.bb(1 / br(e.center.lat), 1 / br(Math.min(Math.abs(e.center.lat), 60)), c.be(o, 7, 3, 0, 1)), h = 360 / Ya({ worldSize: e.worldSize, center: { lat: e.center.lat } }); return new c.Q(e.center.lng - i.x * h * a, c.ad(e.center.lat + i.y * h, -85.051129, c.aI)) } function Ro(u) { const e = .5 * u, i = Math.sin(e), o = Math.cos(e); return Math.log(i + o) - Math.log(o - i) } function $n(u, e, i, o) { const a = u.lat + i * o; if (Math.abs(i) > 1) { const h = (Math.sign(u.lat + i) !== Math.sign(u.lat) ? -Math.abs(u.lat) : Math.abs(u.lat)) * Math.PI / 180, f = Math.abs(u.lat + i) * Math.PI / 180, g = Ro(h + o * (f - h)), v = Ro(h), w = Ro(f); return new c.Q(u.lng + e * ((g - v) / (w - v)), a) } return new c.Q(u.lng + e * o, a) } class ch { constructor(e) { this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._aabbFactory = e } recalculateCache() { if (!this._hadAnyChanges) return; const e = this._cachePrevious; this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1 } getTileAABB(e, i, o, a) { const h = `${e.z}_${e.x}_${e.y}`, f = this._cache.get(h); if (f) return f; const g = this._cachePrevious.get(h); if (g) return this._cache.set(h, g), g; const v = this._aabbFactory(e, i, o, a); return this._cache.set(h, v), this._hadAnyChanges = !0, v } } function Lo(u, e, i) { const o = u - e; return o < 0 ? -o : Math.max(0, o - i) } function el(u, e, i, o, a) { const h = u - i; let f; return f = h < 0 ? Math.min(-h, 1 + h - a) : h > 1 ? Math.min(Math.max(h - a, 0), 1 - h) : 0, Math.max(f, Lo(e, o, a)) } class uh { constructor() { this._aabbCache = new ch(this._computeTileAABB) } recalculateCache() { this._aabbCache.recalculateCache() } distanceToTile2d(e, i, o, a) { const h = 1 << o.z, f = 1 / h, g = o.x / h, v = o.y / h; let w = 2; return w = Math.min(w, el(e, i, g, v, f)), w = Math.min(w, el(e, i, g + .5, -v - f, f)), w = Math.min(w, el(e, i, g + .5, 2 - v - f, f)), w } getWrap(e, i, o) { const a = 1 << i.z, h = 1 / a, f = i.x / a, g = Lo(e.x, f, h), v = Lo(e.x, f - 1, h), w = Lo(e.x, f + 1, h), I = Math.min(g, v, w); return I === w ? 1 : I === v ? -1 : 0 } allowVariableZoom(e, i) { return Rr(e, i) > 4 } allowWorldCopies() { return !1 } getTileAABB(e, i, o, a) { return this._aabbCache.getTileAABB(e, i, o, a) } _computeTileAABB(e, i, o, a) { if (e.z <= 0) return new Xr([-1, -1, -1], [1, 1, 1]); if (e.z === 1) return new Xr([e.x === 0 ? -1 : 0, e.y === 0 ? 0 : -1, -1], [e.x === 0 ? 0 : 1, e.y === 0 ? 1 : 0, 1]); { const h = [Js(0, 0, e.x, e.y, e.z), Js(c.Z, 0, e.x, e.y, e.z), Js(c.Z, c.Z, e.x, e.y, e.z), Js(0, c.Z, e.x, e.y, e.z)], f = [1, 1, 1], g = [-1, -1, -1]; for (const v of h) for (let w = 0; w < 3; w++)f[w] = Math.min(f[w], v[w]), g[w] = Math.max(g[w], v[w]); if (e.y === 0 || e.y === (1 << e.z) - 1) { const v = [0, e.y === 0 ? 1 : -1, 0]; for (let w = 0; w < 3; w++)f[w] = Math.min(f[w], v[w]), g[w] = Math.max(g[w], v[w]) } return new Xr(f, g) } } } class Fo { get pixelsToClipSpaceMatrix() { return this._helper.pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._helper.clipSpaceToPixelsMatrix } get pixelsToGLUnits() { return this._helper.pixelsToGLUnits } get centerOffset() { return this._helper.centerOffset } get size() { return this._helper.size } get rotationMatrix() { return this._helper.rotationMatrix } get centerPoint() { return this._helper.centerPoint } get pixelsPerMeter() { return this._helper.pixelsPerMeter } setMinZoom(e) { this._helper.setMinZoom(e) } setMaxZoom(e) { this._helper.setMaxZoom(e) } setMinPitch(e) { this._helper.setMinPitch(e) } setMaxPitch(e) { this._helper.setMaxPitch(e) } setRenderWorldCopies(e) { this._helper.setRenderWorldCopies(e) } setBearing(e) { this._helper.setBearing(e) } setPitch(e) { this._helper.setPitch(e) } setRoll(e) { this._helper.setRoll(e) } setFov(e) { this._helper.setFov(e) } setZoom(e) { this._helper.setZoom(e) } setCenter(e) { this._helper.setCenter(e) } setElevation(e) { this._helper.setElevation(e) } setMinElevationForCurrentTile(e) { this._helper.setMinElevationForCurrentTile(e) } setPadding(e) { this._helper.setPadding(e) } interpolatePadding(e, i, o) { return this._helper.interpolatePadding(e, i, o) } isPaddingEqual(e) { return this._helper.isPaddingEqual(e) } resize(e, i) { this._helper.resize(e, i) } getMaxBounds() { return this._helper.getMaxBounds() } setMaxBounds(e) { this._helper.setMaxBounds(e) } overrideNearFarZ(e, i) { this._helper.overrideNearFarZ(e, i) } clearNearFarZOverride() { this._helper.clearNearFarZOverride() } getCameraQueryGeometry(e) { return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e) } get tileSize() { return this._helper.tileSize } get tileZoom() { return this._helper.tileZoom } get scale() { return this._helper.scale } get worldSize() { return this._helper.worldSize } get width() { return this._helper.width } get height() { return this._helper.height } get lngRange() { return this._helper.lngRange } get latRange() { return this._helper.latRange } get minZoom() { return this._helper.minZoom } get maxZoom() { return this._helper.maxZoom } get zoom() { return this._helper.zoom } get center() { return this._helper.center } get minPitch() { return this._helper.minPitch } get maxPitch() { return this._helper.maxPitch } get pitch() { return this._helper.pitch } get pitchInRadians() { return this._helper.pitchInRadians } get roll() { return this._helper.roll } get rollInRadians() { return this._helper.rollInRadians } get bearing() { return this._helper.bearing } get bearingInRadians() { return this._helper.bearingInRadians } get fov() { return this._helper.fov } get fovInRadians() { return this._helper.fovInRadians } get elevation() { return this._helper.elevation } get minElevationForCurrentTile() { return this._helper.minElevationForCurrentTile } get padding() { return this._helper.padding } get unmodified() { return this._helper.unmodified } get renderWorldCopies() { return this._helper.renderWorldCopies } get nearZ() { return this._helper.nearZ } get farZ() { return this._helper.farZ } get autoCalculateNearFarZ() { return this._helper.autoCalculateNearFarZ } setTransitionState(e) { } constructor() { this._cachedClippingPlane = c.bg(), this._projectionMatrix = c.b0(), this._globeViewProjMatrix32f = c.a$(), this._globeViewProjMatrixNoCorrection = c.b0(), this._globeViewProjMatrixNoCorrectionInverted = c.b0(), this._globeProjMatrixInverted = c.b0(), this._cameraPosition = c.bh(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Eo({ calcMatrices: () => { this._calcMatrices() }, getConstrained: (e, i) => this.getConstrained(e, i) }), this._coveringTilesDetailsProvider = new uh } clone() { const e = new Fo; return e.apply(this), e } apply(e, i) { this._globeLatitudeErrorCorrectionRadians = i || 0, this._helper.apply(e) } get projectionMatrix() { return this._projectionMatrix } get modelViewProjectionMatrix() { return this._globeViewProjMatrixNoCorrection } get inverseProjectionMatrix() { return this._globeProjMatrixInverted } get cameraPosition() { const e = c.bh(); return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e } get cameraToCenterDistance() { return this._helper.cameraToCenterDistance } getProjectionData(e) { const { overscaledTileID: i, applyGlobeMatrix: o } = e, a = this._helper.getMercatorTileCoordinates(i); return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: a, clippingPlane: this._cachedClippingPlane, projectionTransition: o ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f } } _computeClippingPlane(e) { const i = this.pitchInRadians, o = this.cameraToCenterDistance / e, a = Math.sin(i) * o, h = Math.cos(i) * o + 1, f = 1 / Math.sqrt(a * a + h * h) * 1; let g = -a, v = h; const w = Math.sqrt(g * g + v * v); g /= w, v /= w; const I = [0, g, v]; return c.bi(I, I, [0, 0, 0], -this.bearingInRadians), c.bj(I, I, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), c.bk(I, I, [0, 0, 0], this.center.lng * Math.PI / 180), c.aN(I, I, .25), [...I, .25 * -f] } isLocationOccluded(e) { return !this.isSurfacePointVisible(Yi(e)) } transformLightDirection(e) { const i = this._helper._center.lng * Math.PI / 180, o = this._helper._center.lat * Math.PI / 180, a = Math.cos(o), h = [Math.sin(i) * a, Math.sin(o), Math.cos(i) * a], f = [h[2], 0, -h[0]], g = [0, 0, 0]; c.aT(g, f, h), c.aS(f, f), c.aS(g, g); const v = [0, 0, 0]; return c.aS(v, [f[0] * e[0] + g[0] * e[1] + h[0] * e[2], f[1] * e[0] + g[1] * e[1] + h[1] * e[2], f[2] * e[0] + g[2] * e[1] + h[2] * e[2]]), v } getPixelScale() { return 1 / Math.cos(this._helper._center.lat * Math.PI / 180) } getCircleRadiusCorrection() { return Math.cos(this._helper._center.lat * Math.PI / 180) } getPitchedTextCorrection(e, i, o) { const a = function (g, v, w) { const I = 1 / (1 << w.z); return new c.$(g / c.Z * I + w.x * I, v / c.Z * I + w.y * I) }(e, i, o.canonical), h = (f = a.y, [c.bf(a.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - f * Math.PI * 2)) - .5 * Math.PI]); var f; return this.getCircleRadiusCorrection() / Math.cos(h[1]) } projectTileCoordinates(e, i, o, a) { const h = o.canonical, f = Js(e, i, h.x, h.y, h.z), g = 1 + (a ? a(e, i) : 0) / c.bq, v = [f[0] * g, f[1] * g, f[2] * g, 1]; c.ao(v, v, this._globeViewProjMatrixNoCorrection); const w = this._cachedClippingPlane, I = w[0] * f[0] + w[1] * f[1] + w[2] * f[2] + w[3] < 0; return { point: new c.P(v[0] / v[3], v[1] / v[3]), signedDistanceFromCamera: v[3], isOccluded: I } } _calcMatrices() { if (!this._helper._width || !this._helper._height) return; const e = Qi(this.worldSize, this.center.lat), i = c.b1(), o = c.b1(); this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), c.aX(i, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ); const a = this.centerOffset; i[8] = 2 * -a.x / this._helper._width, i[9] = 2 * a.y / this._helper._height, this._projectionMatrix = c.aY(i), this._globeProjMatrixInverted = c.b1(), c.ai(this._globeProjMatrixInverted, i), c.L(i, i, [0, 0, -this.cameraToCenterDistance]), c.aZ(i, i, this.rollInRadians), c.a_(i, i, -this.pitchInRadians), c.aZ(i, i, this.bearingInRadians), c.L(i, i, [0, 0, -e]); const h = c.bh(); h[0] = e, h[1] = e, h[2] = e, c.a_(o, i, this.center.lat * Math.PI / 180), c.bl(o, o, -this.center.lng * Math.PI / 180), c.M(o, o, h), this._globeViewProjMatrixNoCorrection = o, c.a_(i, i, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), c.bl(i, i, -this.center.lng * Math.PI / 180), c.M(i, i, h), this._globeViewProjMatrix32f = new Float32Array(i), this._globeViewProjMatrixNoCorrectionInverted = c.b1(), c.ai(this._globeViewProjMatrixNoCorrectionInverted, o); const f = c.bh(); this._cameraPosition = c.bh(), this._cameraPosition[2] = this.cameraToCenterDistance / e, c.bi(this._cameraPosition, this._cameraPosition, f, -this.rollInRadians), c.bj(this._cameraPosition, this._cameraPosition, f, this.pitchInRadians), c.bi(this._cameraPosition, this._cameraPosition, f, -this.bearingInRadians), c.aO(this._cameraPosition, this._cameraPosition, [0, 0, 1]), c.bj(this._cameraPosition, this._cameraPosition, f, -this.center.lat * Math.PI / 180), c.bk(this._cameraPosition, this._cameraPosition, f, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e); const g = c.aY(this._globeViewProjMatrixNoCorrectionInverted); c.M(g, g, [1, 1, -1]), this._cachedFrustum = Mn.fromInvProjectionMatrix(g) } calculateFogMatrix(e) { c.w("calculateFogMatrix is not supported on globe projection."); const i = c.b1(); return c.as(i), i } getVisibleUnwrappedCoordinates(e) { return [new c.aV(0, e)] } getCameraFrustum() { return this._cachedFrustum } getClippingPlane() { return this._cachedClippingPlane } getCoveringTilesDetailsProvider() { return this._coveringTilesDetailsProvider } recalculateZoomAndCenter(e) { e && c.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0) } maxPitchScaleFactor() { return 1 } getCameraPoint() { return this._helper.getCameraPoint() } getCameraAltitude() { return this._helper.getCameraAltitude() } getCameraLngLat() { return this._helper.getCameraLngLat() } lngLatToCameraDepth(e, i) { if (!this._globeViewProjMatrixNoCorrection) return 1; const o = Yi(e); c.aN(o, o, 1 + i / c.bq); const a = c.bg(); return c.ao(a, [o[0], o[1], o[2], 1], this._globeViewProjMatrixNoCorrection), a[2] / a[3] } populateCache(e) { } getBounds() { const e = .5 * this.width, i = .5 * this.height, o = [new c.P(0, 0), new c.P(e, 0), new c.P(this.width, 0), new c.P(this.width, i), new c.P(this.width, this.height), new c.P(e, this.height), new c.P(0, this.height), new c.P(0, i)], a = []; for (const E of o) a.push(this.unprojectScreenPoint(E)); let h = 0, f = 0, g = 0, v = 0; const w = this.center; for (const E of a) { const A = c.bm(w.lng, E.lng), B = c.bm(w.lat, E.lat); A < f && (f = A), A > h && (h = A), B < v && (v = B), B > g && (g = B) } const I = [w.lng + f, w.lat + v, w.lng + h, w.lat + g]; return this.isSurfacePointOnScreen([0, 1, 0]) && (I[3] = 90, I[0] = -180, I[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (I[1] = -90, I[0] = -180, I[2] = 180), new we(I) } getConstrained(e, i) { const o = c.ad(e.lat, -85.051129, c.aI), a = c.ad(+i, this.minZoom + yi(0, o), this.maxZoom); return { center: new c.Q(e.lng, o), zoom: a } } calculateCenterFromCameraLngLatAlt(e, i, o, a) { return this._helper.calculateCenterFromCameraLngLatAlt(e, i, o, a) } setLocationAtPoint(e, i) { const o = Yi(this.unprojectScreenPoint(i)), a = Yi(e), h = c.bh(); c.bn(h); const f = c.bh(); c.bk(f, o, h, -this.center.lng * Math.PI / 180), c.bj(f, f, h, this.center.lat * Math.PI / 180); const g = a[0] * a[0] + a[2] * a[2], v = f[0] * f[0]; if (g < v) return; const w = Math.sqrt(g - v), I = -w, E = c.bo(a[0], a[2], f[0], w), A = c.bo(a[0], a[2], f[0], I), B = c.bh(); c.bk(B, a, h, -E); const j = c.bo(B[1], B[2], f[1], f[2]), q = c.bh(); c.bk(q, a, h, -A); const G = c.bo(q[1], q[2], f[1], f[2]), H = .5 * Math.PI, K = j >= -H && j <= H, Q = G >= -H && G <= H; let ee, re; if (K && Q) { const ge = this.center.lng * Math.PI / 180, Se = this.center.lat * Math.PI / 180; c.br(E, ge) + c.br(j, Se) < c.br(A, ge) + c.br(G, Se) ? (ee = E, re = j) : (ee = A, re = G) } else if (K) ee = E, re = j; else { if (!Q) return; ee = A, re = G } const oe = ee / Math.PI * 180, ne = re / Math.PI * 180, me = this.center.lat; this.setCenter(new c.Q(oe, c.ad(ne, -90, 90))), this.setZoom(this.zoom + yi(me, this.center.lat)) } locationToScreenPoint(e, i) { const o = Yi(e); if (i) { const a = i.getElevationForLngLatZoom(e, this._helper._tileZoom); c.aN(o, o, 1 + a / c.bq) } return this._projectSurfacePointToScreen(o) } _projectSurfacePointToScreen(e) { const i = c.bg(); return c.ao(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], new c.P((.5 * i[0] + .5) * this.width, (.5 * -i[1] + .5) * this.height) } screenPointToMercatorCoordinate(e, i) { if (i) { const o = i.pointCoordinate(e); if (o) return o } return c.$.fromLngLat(this.unprojectScreenPoint(e)) } screenPointToLocation(e, i) { var o; return (o = this.screenPointToMercatorCoordinate(e, i)) === null || o === void 0 ? void 0 : o.toLngLat() } isPointOnMapSurface(e, i) { const o = this._cameraPosition, a = this.getRayDirectionFromPixel(e); return !!this.rayPlanetIntersection(o, a) } getRayDirectionFromPixel(e) { const i = c.bg(); i[0] = e.x / this.width * 2 - 1, i[1] = -1 * (e.y / this.height * 2 - 1), i[2] = 1, i[3] = 1, c.ao(i, i, this._globeViewProjMatrixNoCorrectionInverted), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3]; const o = c.bh(); o[0] = i[0] - this._cameraPosition[0], o[1] = i[1] - this._cameraPosition[1], o[2] = i[2] - this._cameraPosition[2]; const a = c.bh(); return c.aS(a, o), a } isSurfacePointVisible(e) { const i = this._cachedClippingPlane; return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] >= 0 } isSurfacePointOnScreen(e) { if (!this.isSurfacePointVisible(e)) return !1; const i = c.bg(); return c.ao(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3], i[0] > -1 && i[0] < 1 && i[1] > -1 && i[1] < 1 && i[2] > -1 && i[2] < 1 } rayPlanetIntersection(e, i) { const o = c.aU(e, i), a = c.bh(), h = c.bh(); c.aN(h, i, o), c.aR(a, e, h); const f = 1 - c.aU(a, a); if (f < 0) return null; const g = c.aU(e, e) - 1, v = -o + (o < 0 ? 1 : -1) * Math.sqrt(f), w = g / v, I = v; return { tMin: Math.min(w, I), tMax: Math.max(w, I) } } unprojectScreenPoint(e) { const i = this._cameraPosition, o = this.getRayDirectionFromPixel(e), a = this.rayPlanetIntersection(i, o); if (a) { const w = c.bh(); c.aO(w, i, [o[0] * a.tMin, o[1] * a.tMin, o[2] * a.tMin]); const I = c.bh(); return c.aS(I, w), Do(I) } const h = this._cachedClippingPlane[0] * o[0] + this._cachedClippingPlane[1] * o[1] + this._cachedClippingPlane[2] * o[2], f = -c.bp(this._cachedClippingPlane, i) / h, g = c.bh(); if (f > 0) c.aO(g, i, [o[0] * f, o[1] * f, o[2] * f]); else { const w = c.bh(); c.aO(w, i, [2 * o[0], 2 * o[1], 2 * o[2]]); const I = c.bp(this._cachedClippingPlane, w); c.aR(g, w, [this._cachedClippingPlane[0] * I, this._cachedClippingPlane[1] * I, this._cachedClippingPlane[2] * I]) } const v = c.bh(); return c.aS(v, g), Do(v) } getMatrixForModel(e, i) { const o = c.Q.convert(e), a = 1 / c.bq, h = c.b0(); return c.bl(h, h, o.lng / 180 * Math.PI), c.a_(h, h, -o.lat / 180 * Math.PI), c.L(h, h, [0, 0, 1 + i / c.bq]), c.a_(h, h, .5 * Math.PI), c.M(h, h, [a, a, a]), h } getProjectionDataForCustomLayer(e = !0) { const i = this.getProjectionData({ overscaledTileID: new c.Y(0, 0, 0, 0, 0), applyGlobeMatrix: e }); return i.tileMercatorCoords = [0, 0, 1, 1], i } getFastPathSimpleProjectionMatrix(e) { } } class Bo { get pixelsToClipSpaceMatrix() { return this._helper.pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._helper.clipSpaceToPixelsMatrix } get pixelsToGLUnits() { return this._helper.pixelsToGLUnits } get centerOffset() { return this._helper.centerOffset } get size() { return this._helper.size } get rotationMatrix() { return this._helper.rotationMatrix } get centerPoint() { return this._helper.centerPoint } get pixelsPerMeter() { return this._helper.pixelsPerMeter } setMinZoom(e) { this._helper.setMinZoom(e) } setMaxZoom(e) { this._helper.setMaxZoom(e) } setMinPitch(e) { this._helper.setMinPitch(e) } setMaxPitch(e) { this._helper.setMaxPitch(e) } setRenderWorldCopies(e) { this._helper.setRenderWorldCopies(e) } setBearing(e) { this._helper.setBearing(e) } setPitch(e) { this._helper.setPitch(e) } setRoll(e) { this._helper.setRoll(e) } setFov(e) { this._helper.setFov(e) } setZoom(e) { this._helper.setZoom(e) } setCenter(e) { this._helper.setCenter(e) } setElevation(e) { this._helper.setElevation(e) } setMinElevationForCurrentTile(e) { this._helper.setMinElevationForCurrentTile(e) } setPadding(e) { this._helper.setPadding(e) } interpolatePadding(e, i, o) { return this._helper.interpolatePadding(e, i, o) } isPaddingEqual(e) { return this._helper.isPaddingEqual(e) } resize(e, i, o = !0) { this._helper.resize(e, i, o) } getMaxBounds() { return this._helper.getMaxBounds() } setMaxBounds(e) { this._helper.setMaxBounds(e) } overrideNearFarZ(e, i) { this._helper.overrideNearFarZ(e, i) } clearNearFarZOverride() { this._helper.clearNearFarZOverride() } getCameraQueryGeometry(e) { return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e) } get tileSize() { return this._helper.tileSize } get tileZoom() { return this._helper.tileZoom } get scale() { return this._helper.scale } get worldSize() { return this._helper.worldSize } get width() { return this._helper.width } get height() { return this._helper.height } get lngRange() { return this._helper.lngRange } get latRange() { return this._helper.latRange } get minZoom() { return this._helper.minZoom } get maxZoom() { return this._helper.maxZoom } get zoom() { return this._helper.zoom } get center() { return this._helper.center } get minPitch() { return this._helper.minPitch } get maxPitch() { return this._helper.maxPitch } get pitch() { return this._helper.pitch } get pitchInRadians() { return this._helper.pitchInRadians } get roll() { return this._helper.roll } get rollInRadians() { return this._helper.rollInRadians } get bearing() { return this._helper.bearing } get bearingInRadians() { return this._helper.bearingInRadians } get fov() { return this._helper.fov } get fovInRadians() { return this._helper.fovInRadians } get elevation() { return this._helper.elevation } get minElevationForCurrentTile() { return this._helper.minElevationForCurrentTile } get padding() { return this._helper.padding } get unmodified() { return this._helper.unmodified } get renderWorldCopies() { return this._helper.renderWorldCopies } get cameraToCenterDistance() { return this._helper.cameraToCenterDistance } get nearZ() { return this._helper.nearZ } get farZ() { return this._helper.farZ } get autoCalculateNearFarZ() { return this._helper.autoCalculateNearFarZ } get isGlobeRendering() { return this._globeness > 0 } setTransitionState(e, i) { this._globeness = e, this._globeLatitudeErrorCorrectionRadians = i, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().recalculateCache(), this._mercatorTransform.getCoveringTilesDetailsProvider().recalculateCache() } get currentTransform() { return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform } constructor() { this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Eo({ calcMatrices: () => { this._calcMatrices() }, getConstrained: (e, i) => this.getConstrained(e, i) }), this._globeness = 1, this._mercatorTransform = new Br, this._verticalPerspectiveTransform = new Fo } clone() { const e = new Bo; return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e } apply(e) { this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians) } get projectionMatrix() { return this.currentTransform.projectionMatrix } get modelViewProjectionMatrix() { return this.currentTransform.modelViewProjectionMatrix } get inverseProjectionMatrix() { return this.currentTransform.inverseProjectionMatrix } get cameraPosition() { return this.currentTransform.cameraPosition } getProjectionData(e) { const i = this._mercatorTransform.getProjectionData(e), o = this._verticalPerspectiveTransform.getProjectionData(e); return { mainMatrix: this.isGlobeRendering ? o.mainMatrix : i.mainMatrix, clippingPlane: o.clippingPlane, tileMercatorCoords: o.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: i.fallbackMatrix } } isLocationOccluded(e) { return this.currentTransform.isLocationOccluded(e) } transformLightDirection(e) { return this.currentTransform.transformLightDirection(e) } getPixelScale() { return c.bb(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness) } getCircleRadiusCorrection() { return c.bb(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness) } getPitchedTextCorrection(e, i, o) { const a = this._mercatorTransform.getPitchedTextCorrection(e, i, o), h = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, i, o); return c.bb(a, h, this._globeness) } projectTileCoordinates(e, i, o, a) { return this.currentTransform.projectTileCoordinates(e, i, o, a) } _calcMatrices() { this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ) } calculateFogMatrix(e) { return this.currentTransform.calculateFogMatrix(e) } getVisibleUnwrappedCoordinates(e) { return this.currentTransform.getVisibleUnwrappedCoordinates(e) } getCameraFrustum() { return this.currentTransform.getCameraFrustum() } getClippingPlane() { return this.currentTransform.getClippingPlane() } getCoveringTilesDetailsProvider() { return this.currentTransform.getCoveringTilesDetailsProvider() } recalculateZoomAndCenter(e) { this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e) } maxPitchScaleFactor() { return this._mercatorTransform.maxPitchScaleFactor() } getCameraPoint() { return this._helper.getCameraPoint() } getCameraAltitude() { return this._helper.getCameraAltitude() } getCameraLngLat() { return this._helper.getCameraLngLat() } lngLatToCameraDepth(e, i) { return this.currentTransform.lngLatToCameraDepth(e, i) } populateCache(e) { this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e) } getBounds() { return this.currentTransform.getBounds() } getConstrained(e, i) { return this.currentTransform.getConstrained(e, i) } calculateCenterFromCameraLngLatAlt(e, i, o, a) { return this._helper.calculateCenterFromCameraLngLatAlt(e, i, o, a) } setLocationAtPoint(e, i) { if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, i), void this.apply(this._mercatorTransform); this._verticalPerspectiveTransform.setLocationAtPoint(e, i), this.apply(this._verticalPerspectiveTransform) } locationToScreenPoint(e, i) { return this.currentTransform.locationToScreenPoint(e, i) } screenPointToMercatorCoordinate(e, i) { return this.currentTransform.screenPointToMercatorCoordinate(e, i) } screenPointToLocation(e, i) { return this.currentTransform.screenPointToLocation(e, i) } isPointOnMapSurface(e, i) { return this.currentTransform.isPointOnMapSurface(e, i) } getRayDirectionFromPixel(e) { return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e) } getMatrixForModel(e, i) { return this.currentTransform.getMatrixForModel(e, i) } getProjectionDataForCustomLayer(e = !0) { const i = this._mercatorTransform.getProjectionDataForCustomLayer(e); if (!this.isGlobeRendering) return i; const o = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e); return o.fallbackMatrix = i.mainMatrix, o } getFastPathSimpleProjectionMatrix(e) { return this.currentTransform.getFastPathSimpleProjectionMatrix(e) } } class pr { get useGlobeControls() { return !0 } handlePanInertia(e, i) { const o = Qa(e, i); return Math.abs(o.lng - i.center.lng) > 180 && (o.lng = i.center.lng + 179.5 * Math.sign(o.lng - i.center.lng)), { easingCenter: o, easingOffset: new c.P(0, 0) } } handleMapControlsRollPitchBearingZoom(e, i) { const o = e.around, a = i.screenPointToLocation(o); e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta); const h = i.zoom; e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta); const f = i.zoom - h; if (f === 0) return; const g = c.bm(i.center.lng, a.lng), v = g / (Math.abs(g / 180) + 1), w = c.bm(i.center.lat, a.lat), I = i.getRayDirectionFromPixel(o), E = i.cameraPosition, A = -1 * c.aU(E, I), B = c.bh(); c.aO(B, E, [I[0] * A, I[1] * A, I[2] * A]); const j = c.bs(B) - 1, q = Math.exp(.5 * -Math.max(j - .3, 0)), G = Qi(i.worldSize, i.center.lat) / Math.min(i.width, i.height), H = c.be(G, .9, .5, 1, .25), K = (1 - c.aH(-f)) * Math.min(q, H), Q = i.center.lat, ee = i.zoom, re = new c.Q(i.center.lng + v * K, c.ad(i.center.lat + w * K, -85.051129, c.aI)); i.setLocationAtPoint(a, o); const oe = i.center, ne = c.be(Math.abs(g), 45, 85, 0, 1), me = c.be(G, .75, .35, 0, 1), ge = Math.pow(Math.max(ne, me), .25), Se = c.bm(oe.lng, re.lng), Ie = c.bm(oe.lat, re.lat); i.setCenter(new c.Q(oe.lng + Se * ge, oe.lat + Ie * ge).wrap()), i.setZoom(ee + yi(Q, i.center.lat)) } handleMapControlsPan(e, i, o) { if (!e.panDelta) return; const a = i.center.lat, h = i.zoom; i.setCenter(Qa(e.panDelta, i).wrap()), i.setZoom(h + yi(a, i.center.lat)) } cameraForBoxAndBearing(e, i, o, a, h) { const f = Ja(e, i, o, a, h), g = i.left / h.width * 2 - 1, v = (h.width - i.right) / h.width * 2 - 1, w = i.top / h.height * -2 + 1, I = (h.height - i.bottom) / h.height * -2 + 1, E = c.bm(o.getWest(), o.getEast()) < 0, A = E ? o.getEast() : o.getWest(), B = E ? o.getWest() : o.getEast(), j = Math.max(o.getNorth(), o.getSouth()), q = Math.min(o.getNorth(), o.getSouth()), G = A + .5 * c.bm(A, B), H = j + .5 * c.bm(j, q), K = h.clone(); K.setCenter(f.center), K.setBearing(f.bearing), K.setPitch(0), K.setRoll(0), K.setZoom(f.zoom); const Q = K.modelViewProjectionMatrix, ee = [Yi(o.getNorthWest()), Yi(o.getNorthEast()), Yi(o.getSouthWest()), Yi(o.getSouthEast()), Yi(new c.Q(B, H)), Yi(new c.Q(A, H)), Yi(new c.Q(G, j)), Yi(new c.Q(G, q))], re = Yi(f.center); let oe = Number.POSITIVE_INFINITY; for (const ne of ee) g < 0 && (oe = pr.getLesserNonNegativeNonNull(oe, pr.solveVectorScale(ne, re, Q, "x", g))), v > 0 && (oe = pr.getLesserNonNegativeNonNull(oe, pr.solveVectorScale(ne, re, Q, "x", v))), w > 0 && (oe = pr.getLesserNonNegativeNonNull(oe, pr.solveVectorScale(ne, re, Q, "y", w))), I < 0 && (oe = pr.getLesserNonNegativeNonNull(oe, pr.solveVectorScale(ne, re, Q, "y", I))); if (Number.isFinite(oe) && oe !== 0) return f.zoom = K.zoom + c.aa(oe), f; Hs() } handleJumpToCenterZoom(e, i) { const o = e.center.lat, a = e.getConstrained(i.center ? c.Q.convert(i.center) : e.center, e.zoom).center; e.setCenter(a.wrap()); const h = i.zoom !== void 0 ? +i.zoom : e.zoom + yi(o, a.lat); e.zoom !== h && e.setZoom(h) } handleEaseTo(e, i) { const o = e.zoom, a = e.center, h = e.padding, f = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, g = { roll: i.roll === void 0 ? e.roll : i.roll, pitch: i.pitch === void 0 ? e.pitch : i.pitch, bearing: i.bearing === void 0 ? e.bearing : i.bearing }, v = i.zoom !== void 0, w = !e.isPaddingEqual(i.padding); let I = !1; const E = i.center ? c.Q.convert(i.center) : a, A = e.getConstrained(E, o).center; nr(e, A); const B = e.clone(); B.setCenter(A), B.setZoom(v ? +i.zoom : o + yi(a.lat, E.lat)), B.setBearing(i.bearing); const j = new c.P(c.ad(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), c.ad(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height)); B.setLocationAtPoint(A, j); const q = (i.offset && i.offsetAsPoint.mag()) > 0 ? B.center : A, G = v ? +i.zoom : o + yi(a.lat, q.lat), H = o + yi(a.lat, 0), K = G + yi(q.lat, 0), Q = c.bm(a.lng, q.lng), ee = c.bm(a.lat, q.lat), re = c.aH(K - H); return I = G !== o, { easeFunc: oe => { if (c.b5(f, g) || Or({ startEulerAngles: f, endEulerAngles: g, tr: e, k: oe, useSlerp: f.roll != g.roll }), w && e.interpolatePadding(h, i.padding, oe), i.around) c.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(i.around, i.aroundPoint); else { const ne = K > H ? Math.min(2, re) : Math.max(.5, re), me = Math.pow(ne, 1 - oe), ge = $n(a, Q, ee, oe * me); e.setCenter(ge.wrap()) } if (I) { const ne = c.B.number(H, K, oe) + yi(0, e.center.lat); e.setZoom(ne) } }, isZooming: I, elevationCenter: q } } handleFlyTo(e, i) { const o = i.zoom !== void 0, a = e.center, h = e.zoom, f = e.padding, g = !e.isPaddingEqual(i.padding), v = e.getConstrained(c.Q.convert(i.center || i.locationAtOffset), h).center, w = o ? +i.zoom : e.zoom + yi(e.center.lat, v.lat), I = e.clone(); I.setCenter(v), I.setZoom(w), I.setBearing(i.bearing); const E = new c.P(c.ad(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), c.ad(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height)); I.setLocationAtPoint(v, E); const A = I.center; nr(e, A); const B = function (ee, re, oe) { const ne = Yi(re), me = Yi(oe), ge = c.aU(ne, me), Se = Math.acos(ge), Ie = Ya(ee); return Se / (2 * Math.PI) * Ie }(e, a, A), j = h + yi(a.lat, 0), q = w + yi(A.lat, 0), G = c.aH(q - j); let H; if (typeof i.minZoom == "number") { const ee = +i.minZoom + yi(A.lat, 0), re = Math.min(ee, j, q) + yi(0, A.lat), oe = e.getConstrained(A, re).zoom + yi(A.lat, 0); H = c.aH(oe - j) } const K = c.bm(a.lng, A.lng), Q = c.bm(a.lat, A.lat); return { easeFunc: (ee, re, oe, ne) => { const me = $n(a, K, Q, oe); g && e.interpolatePadding(f, i.padding, ee); const ge = ee === 1 ? A : me; e.setCenter(ge.wrap()); const Se = j + c.aa(re); e.setZoom(ee === 1 ? w : Se + yi(0, ge.lat)) }, scaleOfZoom: G, targetCenter: A, scaleOfMinZoom: H, pixelPathLength: B } } static solveVectorScale(e, i, o, a, h) { const f = a === "x" ? [o[0], o[4], o[8], o[12]] : [o[1], o[5], o[9], o[13]], g = [o[3], o[7], o[11], o[15]], v = e[0] * f[0] + e[1] * f[1] + e[2] * f[2], w = e[0] * g[0] + e[1] * g[1] + e[2] * g[2], I = i[0] * f[0] + i[1] * f[1] + i[2] * f[2], E = i[0] * g[0] + i[1] * g[1] + i[2] * g[2]; return I + h * w === v + h * E || g[3] * (v - I) + f[3] * (E - w) + v * E == I * w ? null : (I + f[3] - h * E - h * g[3]) / (I - v - h * E + h * w) } static getLesserNonNegativeNonNull(e, i) { return i !== null && i >= 0 && i < e ? i : e } } class Oo { constructor(e) { this._globe = e, this._mercatorCameraHelper = new Kr, this._verticalPerspectiveCameraHelper = new pr } get useGlobeControls() { return this._globe.useGlobeRendering } get currentHelper() { return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper } handlePanInertia(e, i) { return this.currentHelper.handlePanInertia(e, i) } handleMapControlsRollPitchBearingZoom(e, i) { return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, i) } handleMapControlsPan(e, i, o) { this.currentHelper.handleMapControlsPan(e, i, o) } cameraForBoxAndBearing(e, i, o, a, h) { return this.currentHelper.cameraForBoxAndBearing(e, i, o, a, h) } handleJumpToCenterZoom(e, i) { this.currentHelper.handleJumpToCenterZoom(e, i) } handleEaseTo(e, i) { return this.currentHelper.handleEaseTo(e, i) } handleFlyTo(e, i) { return this.currentHelper.handleFlyTo(e, i) } } const Gn = (u, e) => c.x(u, e && e.filter(i => i.identifier !== "source.canvas")), tl = c.bt(); class Ys extends c.E { constructor(e, i = {}) { super(), this._rtlPluginLoaded = () => { for (const o in this.sourceCaches) { const a = this.sourceCaches[o].getSource().type; a !== "vector" && a !== "geojson" || this.sourceCaches[o].reload() } }, this.map = e, this.dispatcher = new Dr(xr(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", (o, a) => this.getGlyphs(o, a)), this.dispatcher.registerMessageHandler("GI", (o, a) => this.getImages(o, a)), this.imageManager = new zr, this.imageManager.setEventedParent(this), this.glyphManager = new bi(e._requestManager, i.localIdeographFontFamily), this.lineAtlas = new kr(256, 512), this.crossTileSymbolIndex = new Wa, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new c.bu, this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", c.bv()), Pt().on(mt, this._rtlPluginLoaded), this.on("data", o => { if (o.dataType !== "source" || o.sourceDataType !== "metadata") return; const a = this.sourceCaches[o.sourceId]; if (!a) return; const h = a.getSource(); if (h && h.vectorLayerIds) for (const f in this._layers) { const g = this._layers[f]; g.source === h.id && this._validateLayer(g) } }) } loadURL(e, i = {}, o) { this.fire(new c.l("dataloading", { dataType: "style" })), i.validate = typeof i.validate != "boolean" || i.validate; const a = this.map._requestManager.transformRequest(e, "Style"); this._loadStyleRequest = new AbortController; const h = this._loadStyleRequest; c.j(a, this._loadStyleRequest).then(f => { this._loadStyleRequest = null, this._load(f.data, i, o) }).catch(f => { this._loadStyleRequest = null, f && !h.signal.aborted && this.fire(new c.k(f)) }) } loadJSON(e, i = {}, o) { this.fire(new c.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController, Le.frameAsync(this._frameRequest).then(() => { this._frameRequest = null, i.validate = i.validate !== !1, this._load(e, i, o) }).catch(() => { }) } loadEmpty() { this.fire(new c.l("dataloading", { dataType: "style" })), this._load(tl, { validate: !1 }) } _load(e, i, o) { var a, h; const f = i.transformStyle ? i.transformStyle(o, e) : e; if (!i.validate || !Gn(this, c.y(f))) { this._loaded = !0, this.stylesheet = f; for (const g in f.sources) this.addSource(g, f.sources[g], { validate: !1 }); f.sprite ? this._loadSprite(f.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(f.glyphs), this._createLayers(), this.light = new Ut(this.stylesheet.light), this._setProjectionInternal(((a = this.stylesheet.projection) === null || a === void 0 ? void 0 : a.type) || "mercator"), this.sky = new rr(this.stylesheet.sky), this.map.setTerrain((h = this.stylesheet.terrain) !== null && h !== void 0 ? h : null), this.fire(new c.l("data", { dataType: "style" })), this.fire(new c.l("style.load")) } } _createLayers() { const e = c.bw(this.stylesheet.layers); this.dispatcher.broadcast("SL", e), this._order = e.map(i => i.id), this._layers = {}, this._serializedLayers = null; for (const i of e) { const o = c.bx(i); o.setEventedParent(this, { layer: { id: i.id } }), this._layers[i.id] = o } } _loadSprite(e, i = !1, o = void 0) { let a; this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, function (h, f, g, v) { return c._(this, void 0, void 0, function* () { const w = Vt(h), I = g > 1 ? "@2x" : "", E = {}, A = {}; for (const { id: B, url: j } of w) { const q = f.transformRequest(Et(j, I, ".json"), "SpriteJSON"); E[B] = c.j(q, v); const G = f.transformRequest(Et(j, I, ".png"), "SpriteImage"); A[B] = ot.getImage(G, v) } return yield Promise.all([...Object.values(E), ...Object.values(A)]), function (B, j) { return c._(this, void 0, void 0, function* () { const q = {}; for (const G in B) { q[G] = {}; const H = Le.getImageCanvasContext((yield j[G]).data), K = (yield B[G]).data; for (const Q in K) { const { width: ee, height: re, x: oe, y: ne, sdf: me, pixelRatio: ge, stretchX: Se, stretchY: Ie, content: Pe, textFitWidth: $e, textFitHeight: Ue } = K[Q]; q[G][Q] = { data: null, pixelRatio: ge, sdf: me, stretchX: Se, stretchY: Ie, content: Pe, textFitWidth: $e, textFitHeight: Ue, spriteData: { width: ee, height: re, x: oe, y: ne, context: H } } } } return q }) }(E, A) }) }(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(h => { if (this._spriteRequest = null, h) for (const f in h) { this._spritesImagesIds[f] = []; const g = this._spritesImagesIds[f] ? this._spritesImagesIds[f].filter(v => !(v in h)) : []; for (const v of g) this.imageManager.removeImage(v), this._changedImages[v] = !0; for (const v in h[f]) { const w = f === "default" ? v : `${f}:${v}`; this._spritesImagesIds[f].push(w), w in this.imageManager.images ? this.imageManager.updateImage(w, h[f][v], !1) : this.imageManager.addImage(w, h[f][v]), i && (this._changedImages[w] = !0) } } }).catch(h => { this._spriteRequest = null, a = h, this.fire(new c.k(a)) }).finally(() => { this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" })), o && o(a) }) } _unloadSprite() { for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0; this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" })) } _validateLayer(e) { const i = this.sourceCaches[e.source]; if (!i) return; const o = e.sourceLayer; if (!o) return; const a = i.getSource(); (a.type === "geojson" || a.vectorLayerIds && a.vectorLayerIds.indexOf(o) === -1) && this.fire(new c.k(new Error(`Source layer "${o}" does not exist on source "${a.id}" as specified by style layer "${e.id}".`))) } loaded() { if (!this._loaded || Object.keys(this._updatedSources).length) return !1; for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1; return !!this.imageManager.isLoaded() } _serializeByIds(e, i = !1) { const o = this._serializedAllLayers(); if (!e || e.length === 0) return Object.values(i ? c.by(o) : o); const a = []; for (const h of e) if (o[h]) { const f = i ? c.by(o[h]) : o[h]; a.push(f) } return a } _serializedAllLayers() { let e = this._serializedLayers; if (e) return e; e = this._serializedLayers = {}; const i = Object.keys(this._layers); for (const o of i) { const a = this._layers[o]; a.type !== "custom" && (e[o] = a.serialize()) } return e } hasTransitions() { var e, i, o; if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((i = this.sky) === null || i === void 0) && i.hasTransition() || !((o = this.projection) === null || o === void 0) && o.hasTransition()) return !0; for (const a in this.sourceCaches) if (this.sourceCaches[a].hasTransition()) return !0; for (const a in this._layers) if (this._layers[a].hasTransition()) return !0; return !1 } _checkLoaded() { if (!this._loaded) throw new Error("Style is not done loading.") } update(e) { if (!this._loaded) return; const i = this._changed; if (i) { const a = Object.keys(this._updatedLayers), h = Object.keys(this._removedLayers); (a.length || h.length) && this._updateWorkerLayers(a, h); for (const f in this._updatedSources) { const g = this._updatedSources[f]; if (g === "reload") this._reloadSource(f); else { if (g !== "clear") throw new Error(`Invalid action ${g}`); this._clearSource(f) } } this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs(); for (const f in this._updatedPaintProps) this._layers[f].updateTransitions(e); this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates() } const o = {}; for (const a in this.sourceCaches) { const h = this.sourceCaches[a]; o[a] = h.used, h.used = !1 } for (const a of this._order) { const h = this._layers[a]; h.recalculate(e, this._availableImages), !h.isHidden(e.zoom) && h.source && (this.sourceCaches[h.source].used = !0) } for (const a in o) { const h = this.sourceCaches[a]; !!o[a] != !!h.used && h.fire(new c.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: a })) } this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, i && this.fire(new c.l("data", { dataType: "style" })) } _updateTilesForChangedImages() { const e = Object.keys(this._changedImages); if (e.length) { for (const i in this.sourceCaches) this.sourceCaches[i].reloadTilesForDependencies(["icons", "patterns"], e); this._changedImages = {} } } _updateTilesForChangedGlyphs() { if (this._glyphsDidChange) { for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]); this._glyphsDidChange = !1 } } _updateWorkerLayers(e, i) { this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, !1), removedIds: i }) } _resetUpdates() { this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1 } setState(e, i = {}) { var o; this._checkLoaded(); const a = this.serialize(); if (e = i.transformStyle ? i.transformStyle(a, e) : e, ((o = i.validate) === null || o === void 0 || o) && Gn(this, c.y(e))) return !1; (e = c.by(e)).layers = c.bw(e.layers); const h = c.bz(a, e), f = this._getOperationsToPerform(h); if (f.unimplemented.length > 0) throw new Error(`Unimplemented: ${f.unimplemented.join(", ")}.`); if (f.operations.length === 0) return !1; for (const g of f.operations) g(); return this.stylesheet = e, this._serializedLayers = null, !0 } _getOperationsToPerform(e) { const i = [], o = []; for (const a of e) switch (a.command) { case "setCenter": case "setZoom": case "setBearing": case "setPitch": case "setRoll": continue; case "addLayer": i.push(() => this.addLayer.apply(this, a.args)); break; case "removeLayer": i.push(() => this.removeLayer.apply(this, a.args)); break; case "setPaintProperty": i.push(() => this.setPaintProperty.apply(this, a.args)); break; case "setLayoutProperty": i.push(() => this.setLayoutProperty.apply(this, a.args)); break; case "setFilter": i.push(() => this.setFilter.apply(this, a.args)); break; case "addSource": i.push(() => this.addSource.apply(this, a.args)); break; case "removeSource": i.push(() => this.removeSource.apply(this, a.args)); break; case "setLayerZoomRange": i.push(() => this.setLayerZoomRange.apply(this, a.args)); break; case "setLight": i.push(() => this.setLight.apply(this, a.args)); break; case "setGeoJSONSourceData": i.push(() => this.setGeoJSONSourceData.apply(this, a.args)); break; case "setGlyphs": i.push(() => this.setGlyphs.apply(this, a.args)); break; case "setSprite": i.push(() => this.setSprite.apply(this, a.args)); break; case "setTerrain": i.push(() => this.map.setTerrain.apply(this, a.args)); break; case "setSky": i.push(() => this.setSky.apply(this, a.args)); break; case "setProjection": this.setProjection.apply(this, a.args); break; case "setTransition": i.push(() => { }); break; default: o.push(a.command) }return { operations: i, unimplemented: o } } addImage(e, i) { if (this.getImage(e)) return this.fire(new c.k(new Error(`An image named "${e}" already exists.`))); this.imageManager.addImage(e, i), this._afterImageUpdated(e) } updateImage(e, i) { this.imageManager.updateImage(e, i) } getImage(e) { return this.imageManager.getImage(e) } removeImage(e) { if (!this.getImage(e)) return this.fire(new c.k(new Error(`An image named "${e}" does not exist.`))); this.imageManager.removeImage(e), this._afterImageUpdated(e) } _afterImageUpdated(e) { this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" })) } listImages() { return this._checkLoaded(), this.imageManager.listImages() } addSource(e, i, o = {}) { if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw new Error(`Source "${e}" already exists.`); if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`); if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(c.y.source, `sources.${e}`, i, null, o)) return; this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0); const a = this.sourceCaches[e] = new C(e, i, this.dispatcher); a.style = this, a.setEventedParent(this, () => ({ isSourceLoaded: a.loaded(), source: a.serialize(), sourceId: e })), a.onAdd(this.map), this._changed = !0 } removeSource(e) { if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error("There is no source with this ID"); for (const o in this._layers) if (this._layers[o].source === e) return this.fire(new c.k(new Error(`Source "${e}" cannot be removed while layer "${o}" is using it.`))); const i = this.sourceCaches[e]; delete this.sourceCaches[e], delete this._updatedSources[e], i.fire(new c.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), i.setEventedParent(null), i.onRemove(this.map), this._changed = !0 } setGeoJSONSourceData(e, i) { if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw new Error(`There is no source with this ID=${e}`); const o = this.sourceCaches[e].getSource(); if (o.type !== "geojson") throw new Error(`geojsonSource.type is ${o.type}, which is !== 'geojson`); o.setData(i), this._changed = !0 } getSource(e) { return this.sourceCaches[e] && this.sourceCaches[e].getSource() } addLayer(e, i, o = {}) { this._checkLoaded(); const a = e.id; if (this.getLayer(a)) return void this.fire(new c.k(new Error(`Layer "${a}" already exists on this map.`))); let h; if (e.type === "custom") { if (Gn(this, c.bA(e))) return; h = c.bx(e) } else { if ("source" in e && typeof e.source == "object" && (this.addSource(a, e.source), e = c.by(e), e = c.e(e, { source: a })), this._validate(c.y.layer, `layers.${a}`, e, { arrayIndex: -1 }, o)) return; h = c.bx(e), this._validateLayer(h), h.setEventedParent(this, { layer: { id: a } }) } const f = i ? this._order.indexOf(i) : this._order.length; if (i && f === -1) this.fire(new c.k(new Error(`Cannot add layer "${a}" before non-existing layer "${i}".`))); else { if (this._order.splice(f, 0, a), this._layerOrderChanged = !0, this._layers[a] = h, this._removedLayers[a] && h.source && h.type !== "custom") { const g = this._removedLayers[a]; delete this._removedLayers[a], g.type !== h.type ? this._updatedSources[h.source] = "clear" : (this._updatedSources[h.source] = "reload", this.sourceCaches[h.source].pause()) } this._updateLayer(h), h.onAdd && h.onAdd(this.map) } } moveLayer(e, i) { if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new c.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`))); if (e === i) return; const o = this._order.indexOf(e); this._order.splice(o, 1); const a = i ? this._order.indexOf(i) : this._order.length; i && a === -1 ? this.fire(new c.k(new Error(`Cannot move layer "${e}" before non-existing layer "${i}".`))) : (this._order.splice(a, 0, e), this._layerOrderChanged = !0) } removeLayer(e) { this._checkLoaded(); const i = this._layers[e]; if (!i) return void this.fire(new c.k(new Error(`Cannot remove non-existing layer "${e}".`))); i.setEventedParent(null); const o = this._order.indexOf(e); this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map) } getLayer(e) { return this._layers[e] } getLayersOrder() { return [...this._order] } hasLayer(e) { return e in this._layers } setLayerZoomRange(e, i, o) { this._checkLoaded(); const a = this.getLayer(e); a ? a.minzoom === i && a.maxzoom === o || (i != null && (a.minzoom = i), o != null && (a.maxzoom = o), this._updateLayer(a)) : this.fire(new c.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`))) } setFilter(e, i, o = {}) { this._checkLoaded(); const a = this.getLayer(e); if (a) { if (!c.bB(a.filter, i)) return i == null ? (a.filter = void 0, void this._updateLayer(a)) : void (this._validate(c.y.filter, `layers.${a.id}.filter`, i, null, o) || (a.filter = c.by(i), this._updateLayer(a))) } else this.fire(new c.k(new Error(`Cannot filter non-existing layer "${e}".`))) } getFilter(e) { return c.by(this.getLayer(e).filter) } setLayoutProperty(e, i, o, a = {}) { this._checkLoaded(); const h = this.getLayer(e); h ? c.bB(h.getLayoutProperty(i), o) || (h.setLayoutProperty(i, o, a), this._updateLayer(h)) : this.fire(new c.k(new Error(`Cannot style non-existing layer "${e}".`))) } getLayoutProperty(e, i) { const o = this.getLayer(e); if (o) return o.getLayoutProperty(i); this.fire(new c.k(new Error(`Cannot get style of non-existing layer "${e}".`))) } setPaintProperty(e, i, o, a = {}) { this._checkLoaded(); const h = this.getLayer(e); h ? c.bB(h.getPaintProperty(i), o) || (h.setPaintProperty(i, o, a) && this._updateLayer(h), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new c.k(new Error(`Cannot style non-existing layer "${e}".`))) } getPaintProperty(e, i) { return this.getLayer(e).getPaintProperty(i) } setFeatureState(e, i) { this._checkLoaded(); const o = e.source, a = e.sourceLayer, h = this.sourceCaches[o]; if (h === void 0) return void this.fire(new c.k(new Error(`The source '${o}' does not exist in the map's style.`))); const f = h.getSource().type; f === "geojson" && a ? this.fire(new c.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : f !== "vector" || a ? (e.id === void 0 && this.fire(new c.k(new Error("The feature id parameter must be provided."))), h.setFeatureState(a, e.id, i)) : this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types."))) } removeFeatureState(e, i) { this._checkLoaded(); const o = e.source, a = this.sourceCaches[o]; if (a === void 0) return void this.fire(new c.k(new Error(`The source '${o}' does not exist in the map's style.`))); const h = a.getSource().type, f = h === "vector" ? e.sourceLayer : void 0; h !== "vector" || f ? i && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new c.k(new Error("A feature id is required to remove its specific state property."))) : a.removeFeatureState(f, e.id, i) : this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types."))) } getFeatureState(e) { this._checkLoaded(); const i = e.source, o = e.sourceLayer, a = this.sourceCaches[i]; if (a !== void 0) return a.getSource().type !== "vector" || o ? (e.id === void 0 && this.fire(new c.k(new Error("The feature id parameter must be provided."))), a.getFeatureState(o, e.id)) : void this.fire(new c.k(new Error("The sourceLayer parameter must be provided for vector source types."))); this.fire(new c.k(new Error(`The source '${i}' does not exist in the map's style.`))) } getTransition() { return c.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition) } serialize() { if (!this._loaded) return; const e = c.bC(this.sourceCaches, h => h.serialize()), i = this._serializeByIds(this._order, !0), o = this.map.getTerrain() || void 0, a = this.stylesheet; return c.bD({ version: a.version, name: a.name, metadata: a.metadata, light: a.light, sky: a.sky, center: a.center, zoom: a.zoom, bearing: a.bearing, pitch: a.pitch, sprite: a.sprite, glyphs: a.glyphs, transition: a.transition, projection: a.projection, sources: e, layers: i, terrain: o }, h => h !== void 0) } _updateLayer(e) { this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0 } _flattenAndSortRenderedFeatures(e) { const i = f => this._layers[f].type === "fill-extrusion", o = {}, a = []; for (let f = this._order.length - 1; f >= 0; f--) { const g = this._order[f]; if (i(g)) { o[g] = f; for (const v of e) { const w = v[g]; if (w) for (const I of w) a.push(I) } } } a.sort((f, g) => g.intersectionZ - f.intersectionZ); const h = []; for (let f = this._order.length - 1; f >= 0; f--) { const g = this._order[f]; if (i(g)) for (let v = a.length - 1; v >= 0; v--) { const w = a[v].feature; if (o[w.layer.id] < f) break; h.push(w), a.pop() } else for (const v of e) { const w = v[g]; if (w) for (const I of w) h.push(I.feature) } } return h } queryRenderedFeatures(e, i, o) { i && i.filter && this._validate(c.y.filter, "queryRenderedFeatures.filter", i.filter, null, i); const a = {}; if (i && i.layers) { if (!(Array.isArray(i.layers) || i.layers instanceof Set)) return this.fire(new c.k(new Error("parameters.layers must be an Array or a Set of strings"))), []; for (const w of i.layers) { const I = this._layers[w]; if (!I) return this.fire(new c.k(new Error(`The layer '${w}' does not exist in the map's style and cannot be queried for features.`))), []; a[I.source] = !0 } } const h = []; i.availableImages = this._availableImages; const f = this._serializedAllLayers(), g = i.layers instanceof Set ? i.layers : Array.isArray(i.layers) ? new Set(i.layers) : null, v = Object.assign(Object.assign({}, i), { layers: g }); for (const w in this.sourceCaches) i.layers && !a[w] || h.push(qr(this.sourceCaches[w], this._layers, f, e, v, o)); return this.placement && h.push(function (w, I, E, A, B, j, q) { const G = {}, H = j.queryRenderedSymbols(A), K = []; for (const Q of Object.keys(H).map(Number)) K.push(q[Q]); K.sort(Ui); for (const Q of K) { const ee = Q.featureIndex.lookupSymbolFeatures(H[Q.bucketInstanceId], I, Q.bucketIndex, Q.sourceLayerIndex, B.filter, B.layers, B.availableImages, w); for (const re in ee) { const oe = G[re] = G[re] || [], ne = ee[re]; ne.sort((me, ge) => { const Se = Q.featureSortOrder; if (Se) { const Ie = Se.indexOf(me.featureIndex); return Se.indexOf(ge.featureIndex) - Ie } return ge.featureIndex - me.featureIndex }); for (const me of ne) oe.push(me) } } return function (Q, ee, re) { for (const oe in Q) for (const ne of Q[oe]) te(ne, re[ee[oe].source]); return Q }(G, w, E) }(this._layers, f, this.sourceCaches, e, v, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(h) } querySourceFeatures(e, i) { i && i.filter && this._validate(c.y.filter, "querySourceFeatures.filter", i.filter, null, i); const o = this.sourceCaches[e]; return o ? function (a, h) { const f = a.getRenderableIds().map(w => a.getTileByID(w)), g = [], v = {}; for (let w = 0; w < f.length; w++) { const I = f[w], E = I.tileID.canonical.key; v[E] || (v[E] = !0, I.querySourceFeatures(g, h)) } return g }(o, i) : [] } getLight() { return this.light.getLight() } setLight(e, i = {}) { this._checkLoaded(); const o = this.light.getLight(); let a = !1; for (const f in e) if (!c.bB(e[f], o[f])) { a = !0; break } if (!a) return; const h = { now: Le.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) }; this.light.setLight(e, i), this.light.updateTransitions(h) } getProjection() { var e; return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection } setProjection(e) { if (this._checkLoaded(), this.projection) { if (this.projection.name === e.type) return; this.projection.destroy(), delete this.projection } this.stylesheet.projection = e, this._setProjectionInternal(e.type) } getSky() { var e; return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky } setSky(e, i = {}) { this._checkLoaded(); const o = this.getSky(); let a = !1; if (!e && !o) return; if (e && !o) a = !0; else if (!e && o) a = !0; else for (const f in e) if (!c.bB(e[f], o[f])) { a = !0; break } if (!a) return; const h = { now: Le.now(), transition: c.e({ duration: 300, delay: 0 }, this.stylesheet.transition) }; this.stylesheet.sky = e, this.sky.setSky(e, i), this.sky.updateTransitions(h) } _setProjectionInternal(e) { const i = function (o) { if (Array.isArray(o)) { const a = new ko({ type: o }); return { projection: a, transform: new Bo, cameraHelper: new Oo(a) } } switch (o) { case "mercator": return { projection: new Xa, transform: new Br, cameraHelper: new Kr }; case "globe": { const a = new ko({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] }); return { projection: a, transform: new Bo, cameraHelper: new Oo(a) } } case "vertical-perspective": return { projection: new vs, transform: new Fo, cameraHelper: new pr }; default: return c.w(`Unknown projection name: ${o}. Falling back to mercator projection.`), { projection: new Xa, transform: new Br, cameraHelper: new Kr } } }(e); this.projection = i.projection, this.map.migrateProjection(i.transform, i.cameraHelper); for (const o in this.sourceCaches) this.sourceCaches[o].reload() } _validate(e, i, o, a, h = {}) { return (!h || h.validate !== !1) && Gn(this, e.call(c.y, c.e({ key: i, style: this.serialize(), value: o, styleSpec: c.v }, a))) } _remove(e = !0) { this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), Pt().off(mt, this._rtlPluginLoaded); for (const i in this._layers) this._layers[i].setEventedParent(null); for (const i in this.sourceCaches) { const o = this.sourceCaches[i]; o.setEventedParent(null), o.onRemove(this.map) } this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e) } _clearSource(e) { this.sourceCaches[e].clearTiles() } _reloadSource(e) { this.sourceCaches[e].resume(), this.sourceCaches[e].reload() } _updateSources(e) { for (const i in this.sourceCaches) this.sourceCaches[i].update(e, this.map.terrain) } _generateCollisionBoxes() { for (const e in this.sourceCaches) this._reloadSource(e) } _updatePlacement(e, i, o, a, h = !1) { let f = !1, g = !1; const v = {}; for (const w of this._order) { const I = this._layers[w]; if (I.type !== "symbol") continue; if (!v[I.source]) { const A = this.sourceCaches[I.source]; v[I.source] = A.getRenderableIds(!0).map(B => A.getTileByID(B)).sort((B, j) => j.tileID.overscaledZ - B.tileID.overscaledZ || (B.tileID.isLessThan(j.tileID) ? -1 : 1)) } const E = this.crossTileSymbolIndex.addLayer(I, v[I.source], e.center.lng); f = f || E } if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((h = h || this._layerOrderChanged || o === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(Le.now(), e.zoom)) && (this.pauseablePlacement = new Ga(e, this.map.terrain, this._order, h, i, o, a, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, v), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(Le.now()), g = !0), f && this.pauseablePlacement.placement.setStale()), g || f) for (const w of this._order) { const I = this._layers[w]; I.type === "symbol" && this.placement.updateLayerOpacities(I, v[I.source]) } return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(Le.now()) } _releaseSymbolFadeTiles() { for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles() } getImages(e, i) { return c._(this, void 0, void 0, function* () { const o = yield this.imageManager.getImages(i.icons); this._updateTilesForChangedImages(); const a = this.sourceCaches[i.source]; return a && a.setDependencies(i.tileID.key, i.type, i.icons), o }) } getGlyphs(e, i) { return c._(this, void 0, void 0, function* () { const o = yield this.glyphManager.getGlyphs(i.stacks), a = this.sourceCaches[i.source]; return a && a.setDependencies(i.tileID.key, i.type, [""]), o }) } getGlyphsUrl() { return this.stylesheet.glyphs || null } setGlyphs(e, i = {}) { this._checkLoaded(), e && this._validate(c.y.glyphs, "glyphs", e, null, i) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e)) } addSprite(e, i, o = {}, a) { this._checkLoaded(); const h = [{ id: e, url: i }], f = [...Vt(this.stylesheet.sprite), ...h]; this._validate(c.y.sprite, "sprite", f, null, o) || (this.stylesheet.sprite = f, this._loadSprite(h, !0, a)) } removeSprite(e) { this._checkLoaded(); const i = Vt(this.stylesheet.sprite); if (i.find(o => o.id === e)) { if (this._spritesImagesIds[e]) for (const o of this._spritesImagesIds[e]) this.imageManager.removeImage(o), this._changedImages[o] = !0; i.splice(i.findIndex(o => o.id === e), 1), this.stylesheet.sprite = i.length > 0 ? i : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new c.l("data", { dataType: "style" })) } else this.fire(new c.k(new Error(`Sprite "${e}" doesn't exists on this map.`))) } getSprite() { return Vt(this.stylesheet.sprite) } setSprite(e, i = {}, o) { this._checkLoaded(), e && this._validate(c.y.sprite, "sprite", e, null, i) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, o) : (this._unloadSprite(), o && o(null))) } } var cn = c.aC([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]); class hh { constructor() { this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null } bind(e, i, o, a, h, f, g, v, w) { this.context = e; let I = this.boundPaintVertexBuffers.length !== a.length; for (let E = 0; !I && E < a.length; E++)this.boundPaintVertexBuffers[E] !== a[E] && (I = !0); !this.vao || this.boundProgram !== i || this.boundLayoutVertexBuffer !== o || I || this.boundIndexBuffer !== h || this.boundVertexOffset !== f || this.boundDynamicVertexBuffer !== g || this.boundDynamicVertexBuffer2 !== v || this.boundDynamicVertexBuffer3 !== w ? this.freshBind(i, o, a, h, f, g, v, w) : (e.bindVertexArray.set(this.vao), g && g.bind(), h && h.dynamicDraw && h.bind(), v && v.bind(), w && w.bind()) } freshBind(e, i, o, a, h, f, g, v) { const w = e.numAttributes, I = this.context, E = I.gl; this.vao && this.destroy(), this.vao = I.createVertexArray(), I.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = i, this.boundPaintVertexBuffers = o, this.boundIndexBuffer = a, this.boundVertexOffset = h, this.boundDynamicVertexBuffer = f, this.boundDynamicVertexBuffer2 = g, this.boundDynamicVertexBuffer3 = v, i.enableAttributes(E, e); for (const A of o) A.enableAttributes(E, e); f && f.enableAttributes(E, e), g && g.enableAttributes(E, e), v && v.enableAttributes(E, e), i.bind(), i.setVertexAttribPointers(E, e, h); for (const A of o) A.bind(), A.setVertexAttribPointers(E, e, h); f && (f.bind(), f.setVertexAttribPointers(E, e, h)), a && a.bind(), g && (g.bind(), g.setVertexAttribPointers(E, e, h)), v && (v.bind(), v.setVertexAttribPointers(E, e, h)), I.currentNumAttributes = w } destroy() { this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null) } } const il = (u, e, i, o, a) => ({ u_texture: 0, u_ele_delta: u, u_fog_matrix: e, u_fog_color: i ? i.properties.get("fog-color") : c.b6.white, u_fog_ground_blend: i ? i.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: a ? 0 : i ? i.calculateFogBlendOpacity(o) : 0, u_horizon_color: i ? i.properties.get("horizon-color") : c.b6.white, u_horizon_fog_blend: i ? i.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: a ? 1 : 0 }), Qs = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" }; function In(u) { const e = []; for (let i = 0; i < u.length; i++) { if (u[i] === null) continue; const o = u[i].split(" "); e.push(o.pop()) } return e } class dh {
          constructor(e, i, o, a, h, f, g, v) {
            const w = e.gl; this.program = w.createProgram(); const I = In(i.staticAttributes), E = o ? o.getBinderAttributes() : [], A = I.concat(E), B = Wr.prelude.staticUniforms ? In(Wr.prelude.staticUniforms) : [], j = g.staticUniforms ? In(g.staticUniforms) : [], q = i.staticUniforms ? In(i.staticUniforms) : [], G = o ? o.getBinderUniforms() : [], H = B.concat(j).concat(q).concat(G), K = []; for (const ge of H) K.indexOf(ge) < 0 && K.push(ge); const Q = o ? o.defines() : []; jr(w) && Q.unshift("#version 300 es"), h && Q.push("#define OVERDRAW_INSPECTOR;"), f && Q.push("#define TERRAIN3D;"), v && Q.push(v); let ee = Q.concat(Wr.prelude.fragmentSource, g.fragmentSource, i.fragmentSource).join(`
`), re = Q.concat(Wr.prelude.vertexSource, g.vertexSource, i.vertexSource).join(`
`); jr(w) || (ee = function (ge) { return ge.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(") }(ee), re = function (ge) { return ge.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(") }(re)); const oe = w.createShader(w.FRAGMENT_SHADER); if (w.isContextLost()) return void (this.failedToCreate = !0); if (w.shaderSource(oe, ee), w.compileShader(oe), !w.getShaderParameter(oe, w.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${w.getShaderInfoLog(oe)}`); w.attachShader(this.program, oe); const ne = w.createShader(w.VERTEX_SHADER); if (w.isContextLost()) return void (this.failedToCreate = !0); if (w.shaderSource(ne, re), w.compileShader(ne), !w.getShaderParameter(ne, w.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${w.getShaderInfoLog(ne)}`); w.attachShader(this.program, ne), this.attributes = {}; const me = {}; this.numAttributes = A.length; for (let ge = 0; ge < this.numAttributes; ge++)A[ge] && (w.bindAttribLocation(this.program, ge, A[ge]), this.attributes[A[ge]] = ge); if (w.linkProgram(this.program), !w.getProgramParameter(this.program, w.LINK_STATUS)) throw new Error(`Program failed to link: ${w.getProgramInfoLog(this.program)}`); w.deleteShader(ne), w.deleteShader(oe); for (let ge = 0; ge < K.length; ge++) { const Se = K[ge]; if (Se && !me[Se]) { const Ie = w.getUniformLocation(this.program, Se); Ie && (me[Se] = Ie) } } this.fixedUniforms = a(e, me), this.terrainUniforms = ((ge, Se) => ({ u_depth: new c.bE(ge, Se.u_depth), u_terrain: new c.bE(ge, Se.u_terrain), u_terrain_dim: new c.b7(ge, Se.u_terrain_dim), u_terrain_matrix: new c.bG(ge, Se.u_terrain_matrix), u_terrain_unpack: new c.bH(ge, Se.u_terrain_unpack), u_terrain_exaggeration: new c.b7(ge, Se.u_terrain_exaggeration) }))(e, me), this.projectionUniforms = ((ge, Se) => ({ u_projection_matrix: new c.bG(ge, Se.u_projection_matrix), u_projection_tile_mercator_coords: new c.bH(ge, Se.u_projection_tile_mercator_coords), u_projection_clipping_plane: new c.bH(ge, Se.u_projection_clipping_plane), u_projection_transition: new c.b7(ge, Se.u_projection_transition), u_projection_fallback_matrix: new c.bG(ge, Se.u_projection_fallback_matrix) }))(e, me), this.binderUniforms = o ? o.getUniforms(e, me) : []
          } draw(e, i, o, a, h, f, g, v, w, I, E, A, B, j, q, G, H, K, Q) { const ee = e.gl; if (this.failedToCreate) return; if (e.program.set(this.program), e.setDepthMode(o), e.setStencilMode(a), e.setColorMode(h), e.setCullFace(f), v) { e.activeTexture.set(ee.TEXTURE2), ee.bindTexture(ee.TEXTURE_2D, v.depthTexture), e.activeTexture.set(ee.TEXTURE3), ee.bindTexture(ee.TEXTURE_2D, v.texture); for (const oe in this.terrainUniforms) this.terrainUniforms[oe].set(v[oe]) } if (w) for (const oe in w) this.projectionUniforms[Qs[oe]].set(w[oe]); if (g) for (const oe in this.fixedUniforms) this.fixedUniforms[oe].set(g[oe]); G && G.setUniforms(e, this.binderUniforms, j, { zoom: q }); let re = 0; switch (i) { case ee.LINES: re = 2; break; case ee.TRIANGLES: re = 3; break; case ee.LINE_STRIP: re = 1 }for (const oe of B.get()) { const ne = oe.vaos || (oe.vaos = {}); (ne[I] || (ne[I] = new hh)).bind(e, this, E, G ? G.getPaintVertexBuffers() : [], A, oe.vertexOffset, H, K, Q), ee.drawElements(i, oe.primitiveLength * re, ee.UNSIGNED_SHORT, oe.primitiveOffset * re * 2) } }
        } function eo(u, e, i) { const o = 1 / c.av(i, 1, e.transform.tileZoom), a = Math.pow(2, i.tileID.overscaledZ), h = i.tileSize * Math.pow(2, e.transform.tileZoom) / a, f = h * (i.tileID.canonical.x + i.tileID.wrap * a), g = h * i.tileID.canonical.y; return { u_image: 0, u_texsize: i.imageAtlasTexture.size, u_scale: [o, u.fromScale, u.toScale], u_fade: u.t, u_pixel_coord_upper: [f >> 16, g >> 16], u_pixel_coord_lower: [65535 & f, 65535 & g] } } const Ac = (u, e, i, o) => { const a = u.style.light, h = a.properties.get("position"), f = [h.x, h.y, h.z], g = c.bK(); a.properties.get("anchor") === "viewport" && c.bL(g, u.transform.bearingInRadians), c.bM(f, f, g); const v = u.transform.transformLightDirection(f), w = a.properties.get("color"); return { u_lightpos: f, u_lightpos_globe: v, u_lightintensity: a.properties.get("intensity"), u_lightcolor: [w.r, w.g, w.b], u_vertical_gradient: +e, u_opacity: i, u_fill_translate: o } }, bs = (u, e, i, o, a, h, f) => c.e(Ac(u, e, i, o), eo(h, u, f), { u_height_factor: -Math.pow(2, a.overscaledZ) / f.tileSize / 8 }), zc = (u, e, i, o) => c.e(eo(e, u, i), { u_fill_translate: o }), kc = (u, e) => ({ u_world: u, u_fill_translate: e }), ph = (u, e, i, o, a) => c.e(zc(u, e, i, a), { u_world: o }), Dc = (u, e, i, o, a) => { const h = u.transform; let f, g, v = 0; if (i.paint.get("circle-pitch-alignment") === "map") { const w = c.av(e, 1, h.zoom); f = !0, g = [w, w], v = w / (c.Z * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * a } else f = !1, g = h.pixelsToGLUnits; return { u_camera_to_center_distance: h.cameraToCenterDistance, u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +f, u_device_pixel_ratio: u.pixelRatio, u_extrude_scale: g, u_globe_extrude_scale: v, u_translate: o } }, rl = u => ({ u_pixel_extrude_scale: [1 / u.width, 1 / u.height] }), Rc = u => ({ u_viewport_size: [u.width, u.height] }), nl = (u, e = 1) => ({ u_color: u, u_overlay: 0, u_overlay_scale: e }), sl = (u, e, i, o) => { const a = c.av(u, 1, e) / (c.Z * Math.pow(2, u.tileID.overscaledZ)) * 2 * Math.PI * o; return { u_extrude_scale: c.av(u, 1, e), u_intensity: i, u_globe_extrude_scale: a } }, ol = (u, e, i, o) => { const a = c.K(); c.bN(a, 0, u.width, u.height, 0, 0, 1); const h = u.context.gl; return { u_matrix: a, u_world: [h.drawingBufferWidth, h.drawingBufferHeight], u_image: i, u_color_ramp: o, u_opacity: e.paint.get("heatmap-opacity") } }, qn = (u, e, i) => { const o = i.paint.get("hillshade-shadow-color"), a = i.paint.get("hillshade-highlight-color"), h = i.paint.get("hillshade-accent-color"); let f = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180); return i.paint.get("hillshade-illumination-anchor") === "viewport" && (f += u.transform.bearingInRadians), { u_image: 0, u_latrange: Fc(0, e.tileID), u_light: [i.paint.get("hillshade-exaggeration"), f], u_shadow: o, u_highlight: a, u_accent: h } }, Lc = (u, e) => { const i = e.stride, o = c.K(); return c.bN(o, 0, c.Z, -8192, 0, 0, 1), c.L(o, o, [0, -8192, 0]), { u_matrix: o, u_image: 1, u_dimension: [i, i], u_zoom: u.overscaledZ, u_unpack: e.getUnpackVector() } }; function Fc(u, e) { const i = Math.pow(2, e.canonical.z), o = e.canonical.y; return [new c.$(0, o / i).toLngLat().lat, new c.$(0, (o + 1) / i).toLngLat().lat] } const Hn = (u, e, i, o) => { const a = u.transform; return { u_translation: al(u, e, i), u_ratio: o / c.av(e, 1, a.zoom), u_device_pixel_ratio: u.pixelRatio, u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]] } }, fh = (u, e, i, o, a) => c.e(Hn(u, e, i, o), { u_image: 0, u_image_height: a }), jo = (u, e, i, o, a) => { const h = u.transform, f = Bc(e, h); return { u_translation: al(u, e, i), u_texsize: e.imageAtlasTexture.size, u_ratio: o / c.av(e, 1, h.zoom), u_device_pixel_ratio: u.pixelRatio, u_image: 0, u_scale: [f, a.fromScale, a.toScale], u_fade: a.t, u_units_to_pixels: [1 / h.pixelsToGLUnits[0], 1 / h.pixelsToGLUnits[1]] } }, mh = (u, e, i, o, a, h) => { const f = u.lineAtlas, g = Bc(e, u.transform), v = i.layout.get("line-cap") === "round", w = f.getDash(a.from, v), I = f.getDash(a.to, v), E = w.width * h.fromScale, A = I.width * h.toScale; return c.e(Hn(u, e, i, o), { u_patternscale_a: [g / E, -w.height / 2], u_patternscale_b: [g / A, -I.height / 2], u_sdfgamma: f.width / (256 * Math.min(E, A) * u.pixelRatio) / 2, u_image: 0, u_tex_y_a: w.y, u_tex_y_b: I.y, u_mix: h.t }) }; function Bc(u, e) { return 1 / c.av(u, 1, e.tileZoom) } function al(u, e, i) { return c.aw(u.transform, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor")) } const Oc = (u, e, i, o, a) => { return { u_tl_parent: u, u_scale_parent: e, u_buffer_scale: 1, u_fade_t: i.mix, u_opacity: i.opacity * o.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: o.paint.get("raster-brightness-min"), u_brightness_high: o.paint.get("raster-brightness-max"), u_saturation_factor: (f = o.paint.get("raster-saturation"), f > 0 ? 1 - 1 / (1.001 - f) : -f), u_contrast_factor: (h = o.paint.get("raster-contrast"), h > 0 ? 1 / (1 - h) : 1 + h), u_spin_weights: jc(o.paint.get("raster-hue-rotate")), u_coords_top: [a[0].x, a[0].y, a[1].x, a[1].y], u_coords_bottom: [a[3].x, a[3].y, a[2].x, a[2].y] }; var h, f }; function jc(u) { u *= Math.PI / 180; const e = Math.sin(u), i = Math.cos(u); return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3] } const Vo = (u, e, i, o, a, h, f, g, v, w, I, E, A) => { const B = f.transform; return { u_is_size_zoom_constant: +(u === "constant" || u === "source"), u_is_size_feature_constant: +(u === "constant" || u === "camera"), u_size_t: e ? e.uSizeT : 0, u_size: e ? e.uSize : 0, u_camera_to_center_distance: B.cameraToCenterDistance, u_pitch: B.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i, u_aspect_ratio: B.width / B.height, u_fade_change: f.options.fadeDuration ? f.symbolFadeChange : 1, u_label_plane_matrix: g, u_coord_matrix: v, u_is_text: +I, u_pitch_with_map: +o, u_is_along_line: a, u_is_variable_anchor: h, u_texsize: E, u_texture: 0, u_translation: w, u_pitched_scale: A } }, ll = (u, e, i, o, a, h, f, g, v, w, I, E, A, B) => { const j = f.transform; return c.e(Vo(u, e, i, o, a, h, f, g, v, w, I, E, B), { u_gamma_scale: o ? Math.cos(j.pitch * Math.PI / 180) * j.cameraToCenterDistance : 1, u_device_pixel_ratio: f.pixelRatio, u_is_halo: 1 }) }, No = (u, e, i, o, a, h, f, g, v, w, I, E, A) => c.e(ll(u, e, i, o, a, h, f, g, v, w, !0, I, 0, A), { u_texsize_icon: E, u_texture_icon: 1 }), _n = (u, e) => ({ u_opacity: u, u_color: e }), cl = (u, e, i, o, a) => c.e(function (h, f, g, v) { const w = g.imageManager.getPattern(h.from.toString()), I = g.imageManager.getPattern(h.to.toString()), { width: E, height: A } = g.imageManager.getPixelSize(), B = Math.pow(2, v.tileID.overscaledZ), j = v.tileSize * Math.pow(2, g.transform.tileZoom) / B, q = j * (v.tileID.canonical.x + v.tileID.wrap * B), G = j * v.tileID.canonical.y; return { u_image: 0, u_pattern_tl_a: w.tl, u_pattern_br_a: w.br, u_pattern_tl_b: I.tl, u_pattern_br_b: I.br, u_texsize: [E, A], u_mix: f.t, u_pattern_size_a: w.displaySize, u_pattern_size_b: I.displaySize, u_scale_a: f.fromScale, u_scale_b: f.toScale, u_tile_units_to_pixels: 1 / c.av(v, 1, g.transform.tileZoom), u_pixel_coord_upper: [q >> 16, G >> 16], u_pixel_coord_lower: [65535 & q, 65535 & G] } }(i, a, e, o), { u_opacity: u }), Zo = (u, e) => { }, ul = { fillExtrusion: (u, e) => ({ u_lightpos: new c.bI(u, e.u_lightpos), u_lightpos_globe: new c.bI(u, e.u_lightpos_globe), u_lightintensity: new c.b7(u, e.u_lightintensity), u_lightcolor: new c.bI(u, e.u_lightcolor), u_vertical_gradient: new c.b7(u, e.u_vertical_gradient), u_opacity: new c.b7(u, e.u_opacity), u_fill_translate: new c.bJ(u, e.u_fill_translate) }), fillExtrusionPattern: (u, e) => ({ u_lightpos: new c.bI(u, e.u_lightpos), u_lightpos_globe: new c.bI(u, e.u_lightpos_globe), u_lightintensity: new c.b7(u, e.u_lightintensity), u_lightcolor: new c.bI(u, e.u_lightcolor), u_vertical_gradient: new c.b7(u, e.u_vertical_gradient), u_height_factor: new c.b7(u, e.u_height_factor), u_opacity: new c.b7(u, e.u_opacity), u_fill_translate: new c.bJ(u, e.u_fill_translate), u_image: new c.bE(u, e.u_image), u_texsize: new c.bJ(u, e.u_texsize), u_pixel_coord_upper: new c.bJ(u, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bJ(u, e.u_pixel_coord_lower), u_scale: new c.bI(u, e.u_scale), u_fade: new c.b7(u, e.u_fade) }), fill: (u, e) => ({ u_fill_translate: new c.bJ(u, e.u_fill_translate) }), fillPattern: (u, e) => ({ u_image: new c.bE(u, e.u_image), u_texsize: new c.bJ(u, e.u_texsize), u_pixel_coord_upper: new c.bJ(u, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bJ(u, e.u_pixel_coord_lower), u_scale: new c.bI(u, e.u_scale), u_fade: new c.b7(u, e.u_fade), u_fill_translate: new c.bJ(u, e.u_fill_translate) }), fillOutline: (u, e) => ({ u_world: new c.bJ(u, e.u_world), u_fill_translate: new c.bJ(u, e.u_fill_translate) }), fillOutlinePattern: (u, e) => ({ u_world: new c.bJ(u, e.u_world), u_image: new c.bE(u, e.u_image), u_texsize: new c.bJ(u, e.u_texsize), u_pixel_coord_upper: new c.bJ(u, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bJ(u, e.u_pixel_coord_lower), u_scale: new c.bI(u, e.u_scale), u_fade: new c.b7(u, e.u_fade), u_fill_translate: new c.bJ(u, e.u_fill_translate) }), circle: (u, e) => ({ u_camera_to_center_distance: new c.b7(u, e.u_camera_to_center_distance), u_scale_with_map: new c.bE(u, e.u_scale_with_map), u_pitch_with_map: new c.bE(u, e.u_pitch_with_map), u_extrude_scale: new c.bJ(u, e.u_extrude_scale), u_device_pixel_ratio: new c.b7(u, e.u_device_pixel_ratio), u_globe_extrude_scale: new c.b7(u, e.u_globe_extrude_scale), u_translate: new c.bJ(u, e.u_translate) }), collisionBox: (u, e) => ({ u_pixel_extrude_scale: new c.bJ(u, e.u_pixel_extrude_scale) }), collisionCircle: (u, e) => ({ u_viewport_size: new c.bJ(u, e.u_viewport_size) }), debug: (u, e) => ({ u_color: new c.bF(u, e.u_color), u_overlay: new c.bE(u, e.u_overlay), u_overlay_scale: new c.b7(u, e.u_overlay_scale) }), depth: Zo, clippingMask: Zo, heatmap: (u, e) => ({ u_extrude_scale: new c.b7(u, e.u_extrude_scale), u_intensity: new c.b7(u, e.u_intensity), u_globe_extrude_scale: new c.b7(u, e.u_globe_extrude_scale) }), heatmapTexture: (u, e) => ({ u_matrix: new c.bG(u, e.u_matrix), u_world: new c.bJ(u, e.u_world), u_image: new c.bE(u, e.u_image), u_color_ramp: new c.bE(u, e.u_color_ramp), u_opacity: new c.b7(u, e.u_opacity) }), hillshade: (u, e) => ({ u_image: new c.bE(u, e.u_image), u_latrange: new c.bJ(u, e.u_latrange), u_light: new c.bJ(u, e.u_light), u_shadow: new c.bF(u, e.u_shadow), u_highlight: new c.bF(u, e.u_highlight), u_accent: new c.bF(u, e.u_accent) }), hillshadePrepare: (u, e) => ({ u_matrix: new c.bG(u, e.u_matrix), u_image: new c.bE(u, e.u_image), u_dimension: new c.bJ(u, e.u_dimension), u_zoom: new c.b7(u, e.u_zoom), u_unpack: new c.bH(u, e.u_unpack) }), line: (u, e) => ({ u_translation: new c.bJ(u, e.u_translation), u_ratio: new c.b7(u, e.u_ratio), u_device_pixel_ratio: new c.b7(u, e.u_device_pixel_ratio), u_units_to_pixels: new c.bJ(u, e.u_units_to_pixels) }), lineGradient: (u, e) => ({ u_translation: new c.bJ(u, e.u_translation), u_ratio: new c.b7(u, e.u_ratio), u_device_pixel_ratio: new c.b7(u, e.u_device_pixel_ratio), u_units_to_pixels: new c.bJ(u, e.u_units_to_pixels), u_image: new c.bE(u, e.u_image), u_image_height: new c.b7(u, e.u_image_height) }), linePattern: (u, e) => ({ u_translation: new c.bJ(u, e.u_translation), u_texsize: new c.bJ(u, e.u_texsize), u_ratio: new c.b7(u, e.u_ratio), u_device_pixel_ratio: new c.b7(u, e.u_device_pixel_ratio), u_image: new c.bE(u, e.u_image), u_units_to_pixels: new c.bJ(u, e.u_units_to_pixels), u_scale: new c.bI(u, e.u_scale), u_fade: new c.b7(u, e.u_fade) }), lineSDF: (u, e) => ({ u_translation: new c.bJ(u, e.u_translation), u_ratio: new c.b7(u, e.u_ratio), u_device_pixel_ratio: new c.b7(u, e.u_device_pixel_ratio), u_units_to_pixels: new c.bJ(u, e.u_units_to_pixels), u_patternscale_a: new c.bJ(u, e.u_patternscale_a), u_patternscale_b: new c.bJ(u, e.u_patternscale_b), u_sdfgamma: new c.b7(u, e.u_sdfgamma), u_image: new c.bE(u, e.u_image), u_tex_y_a: new c.b7(u, e.u_tex_y_a), u_tex_y_b: new c.b7(u, e.u_tex_y_b), u_mix: new c.b7(u, e.u_mix) }), raster: (u, e) => ({ u_tl_parent: new c.bJ(u, e.u_tl_parent), u_scale_parent: new c.b7(u, e.u_scale_parent), u_buffer_scale: new c.b7(u, e.u_buffer_scale), u_fade_t: new c.b7(u, e.u_fade_t), u_opacity: new c.b7(u, e.u_opacity), u_image0: new c.bE(u, e.u_image0), u_image1: new c.bE(u, e.u_image1), u_brightness_low: new c.b7(u, e.u_brightness_low), u_brightness_high: new c.b7(u, e.u_brightness_high), u_saturation_factor: new c.b7(u, e.u_saturation_factor), u_contrast_factor: new c.b7(u, e.u_contrast_factor), u_spin_weights: new c.bI(u, e.u_spin_weights), u_coords_top: new c.bH(u, e.u_coords_top), u_coords_bottom: new c.bH(u, e.u_coords_bottom) }), symbolIcon: (u, e) => ({ u_is_size_zoom_constant: new c.bE(u, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.bE(u, e.u_is_size_feature_constant), u_size_t: new c.b7(u, e.u_size_t), u_size: new c.b7(u, e.u_size), u_camera_to_center_distance: new c.b7(u, e.u_camera_to_center_distance), u_pitch: new c.b7(u, e.u_pitch), u_rotate_symbol: new c.bE(u, e.u_rotate_symbol), u_aspect_ratio: new c.b7(u, e.u_aspect_ratio), u_fade_change: new c.b7(u, e.u_fade_change), u_label_plane_matrix: new c.bG(u, e.u_label_plane_matrix), u_coord_matrix: new c.bG(u, e.u_coord_matrix), u_is_text: new c.bE(u, e.u_is_text), u_pitch_with_map: new c.bE(u, e.u_pitch_with_map), u_is_along_line: new c.bE(u, e.u_is_along_line), u_is_variable_anchor: new c.bE(u, e.u_is_variable_anchor), u_texsize: new c.bJ(u, e.u_texsize), u_texture: new c.bE(u, e.u_texture), u_translation: new c.bJ(u, e.u_translation), u_pitched_scale: new c.b7(u, e.u_pitched_scale) }), symbolSDF: (u, e) => ({ u_is_size_zoom_constant: new c.bE(u, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.bE(u, e.u_is_size_feature_constant), u_size_t: new c.b7(u, e.u_size_t), u_size: new c.b7(u, e.u_size), u_camera_to_center_distance: new c.b7(u, e.u_camera_to_center_distance), u_pitch: new c.b7(u, e.u_pitch), u_rotate_symbol: new c.bE(u, e.u_rotate_symbol), u_aspect_ratio: new c.b7(u, e.u_aspect_ratio), u_fade_change: new c.b7(u, e.u_fade_change), u_label_plane_matrix: new c.bG(u, e.u_label_plane_matrix), u_coord_matrix: new c.bG(u, e.u_coord_matrix), u_is_text: new c.bE(u, e.u_is_text), u_pitch_with_map: new c.bE(u, e.u_pitch_with_map), u_is_along_line: new c.bE(u, e.u_is_along_line), u_is_variable_anchor: new c.bE(u, e.u_is_variable_anchor), u_texsize: new c.bJ(u, e.u_texsize), u_texture: new c.bE(u, e.u_texture), u_gamma_scale: new c.b7(u, e.u_gamma_scale), u_device_pixel_ratio: new c.b7(u, e.u_device_pixel_ratio), u_is_halo: new c.bE(u, e.u_is_halo), u_translation: new c.bJ(u, e.u_translation), u_pitched_scale: new c.b7(u, e.u_pitched_scale) }), symbolTextAndIcon: (u, e) => ({ u_is_size_zoom_constant: new c.bE(u, e.u_is_size_zoom_constant), u_is_size_feature_constant: new c.bE(u, e.u_is_size_feature_constant), u_size_t: new c.b7(u, e.u_size_t), u_size: new c.b7(u, e.u_size), u_camera_to_center_distance: new c.b7(u, e.u_camera_to_center_distance), u_pitch: new c.b7(u, e.u_pitch), u_rotate_symbol: new c.bE(u, e.u_rotate_symbol), u_aspect_ratio: new c.b7(u, e.u_aspect_ratio), u_fade_change: new c.b7(u, e.u_fade_change), u_label_plane_matrix: new c.bG(u, e.u_label_plane_matrix), u_coord_matrix: new c.bG(u, e.u_coord_matrix), u_is_text: new c.bE(u, e.u_is_text), u_pitch_with_map: new c.bE(u, e.u_pitch_with_map), u_is_along_line: new c.bE(u, e.u_is_along_line), u_is_variable_anchor: new c.bE(u, e.u_is_variable_anchor), u_texsize: new c.bJ(u, e.u_texsize), u_texsize_icon: new c.bJ(u, e.u_texsize_icon), u_texture: new c.bE(u, e.u_texture), u_texture_icon: new c.bE(u, e.u_texture_icon), u_gamma_scale: new c.b7(u, e.u_gamma_scale), u_device_pixel_ratio: new c.b7(u, e.u_device_pixel_ratio), u_is_halo: new c.bE(u, e.u_is_halo), u_translation: new c.bJ(u, e.u_translation), u_pitched_scale: new c.b7(u, e.u_pitched_scale) }), background: (u, e) => ({ u_opacity: new c.b7(u, e.u_opacity), u_color: new c.bF(u, e.u_color) }), backgroundPattern: (u, e) => ({ u_opacity: new c.b7(u, e.u_opacity), u_image: new c.bE(u, e.u_image), u_pattern_tl_a: new c.bJ(u, e.u_pattern_tl_a), u_pattern_br_a: new c.bJ(u, e.u_pattern_br_a), u_pattern_tl_b: new c.bJ(u, e.u_pattern_tl_b), u_pattern_br_b: new c.bJ(u, e.u_pattern_br_b), u_texsize: new c.bJ(u, e.u_texsize), u_mix: new c.b7(u, e.u_mix), u_pattern_size_a: new c.bJ(u, e.u_pattern_size_a), u_pattern_size_b: new c.bJ(u, e.u_pattern_size_b), u_scale_a: new c.b7(u, e.u_scale_a), u_scale_b: new c.b7(u, e.u_scale_b), u_pixel_coord_upper: new c.bJ(u, e.u_pixel_coord_upper), u_pixel_coord_lower: new c.bJ(u, e.u_pixel_coord_lower), u_tile_units_to_pixels: new c.b7(u, e.u_tile_units_to_pixels) }), terrain: (u, e) => ({ u_texture: new c.bE(u, e.u_texture), u_ele_delta: new c.b7(u, e.u_ele_delta), u_fog_matrix: new c.bG(u, e.u_fog_matrix), u_fog_color: new c.bF(u, e.u_fog_color), u_fog_ground_blend: new c.b7(u, e.u_fog_ground_blend), u_fog_ground_blend_opacity: new c.b7(u, e.u_fog_ground_blend_opacity), u_horizon_color: new c.bF(u, e.u_horizon_color), u_horizon_fog_blend: new c.b7(u, e.u_horizon_fog_blend), u_is_globe_mode: new c.b7(u, e.u_is_globe_mode) }), terrainDepth: (u, e) => ({ u_ele_delta: new c.b7(u, e.u_ele_delta) }), terrainCoords: (u, e) => ({ u_texture: new c.bE(u, e.u_texture), u_terrain_coords_id: new c.b7(u, e.u_terrain_coords_id), u_ele_delta: new c.b7(u, e.u_ele_delta) }), projectionErrorMeasurement: (u, e) => ({ u_input: new c.b7(u, e.u_input), u_output_expected: new c.b7(u, e.u_output_expected) }), atmosphere: (u, e) => ({ u_sun_pos: new c.bI(u, e.u_sun_pos), u_atmosphere_blend: new c.b7(u, e.u_atmosphere_blend), u_globe_position: new c.bI(u, e.u_globe_position), u_globe_radius: new c.b7(u, e.u_globe_radius), u_inv_proj_matrix: new c.bG(u, e.u_inv_proj_matrix) }), sky: (u, e) => ({ u_sky_color: new c.bF(u, e.u_sky_color), u_horizon_color: new c.bF(u, e.u_horizon_color), u_horizon: new c.bJ(u, e.u_horizon), u_horizon_normal: new c.bJ(u, e.u_horizon_normal), u_sky_horizon_blend: new c.b7(u, e.u_sky_horizon_blend), u_sky_blend: new c.b7(u, e.u_sky_blend) }) }; class Vc { constructor(e, i, o) { this.context = e; const a = e.gl; this.buffer = a.createBuffer(), this.dynamicDraw = !!o, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), a.bufferData(a.ELEMENT_ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? a.DYNAMIC_DRAW : a.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer } bind() { this.context.bindElementBuffer.set(this.buffer) } updateData(e) { const i = this.context.gl; if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode."); this.context.unbindVAO(), this.bind(), i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer) } destroy() { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer) } } const hl = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }; class Wn { constructor(e, i, o, a) { this.length = i.length, this.attributes = o, this.itemSize = i.bytesPerElement, this.dynamicDraw = a, this.context = e; const h = e.gl; this.buffer = h.createBuffer(), e.bindVertexBuffer.set(this.buffer), h.bufferData(h.ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? h.DYNAMIC_DRAW : h.STATIC_DRAW), this.dynamicDraw || delete i.arrayBuffer } bind() { this.context.bindVertexBuffer.set(this.buffer) } updateData(e) { if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`); const i = this.context.gl; this.bind(), i.bufferSubData(i.ARRAY_BUFFER, 0, e.arrayBuffer) } enableAttributes(e, i) { for (let o = 0; o < this.attributes.length; o++) { const a = i.attributes[this.attributes[o].name]; a !== void 0 && e.enableVertexAttribArray(a) } } setVertexAttribPointers(e, i, o) { for (let a = 0; a < this.attributes.length; a++) { const h = this.attributes[a], f = i.attributes[h.name]; f !== void 0 && e.vertexAttribPointer(f, h.components, e[hl[h.type]], !1, this.itemSize, h.offset + this.itemSize * (o || 0)) } } destroy() { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer) } } class Bt { constructor(e) { this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1 } get() { return this.current } set(e) { } getDefault() { return this.default } setDefault() { this.set(this.default) } } class _h extends Bt { getDefault() { return c.b6.transparent } set(e) { const i = this.current; (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1) } } class gh extends Bt { getDefault() { return 1 } set(e) { (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1) } } class yh extends Bt { getDefault() { return 0 } set(e) { (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1) } } class xh extends Bt { getDefault() { return [!0, !0, !0, !0] } set(e) { const i = this.current; (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1) } } class Nc extends Bt { getDefault() { return !0 } set(e) { (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1) } } class vh extends Bt { getDefault() { return 255 } set(e) { (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1) } } class Zc extends Bt { getDefault() { return { func: this.gl.ALWAYS, ref: 0, mask: 255 } } set(e) { const i = this.current; (e.func !== i.func || e.ref !== i.ref || e.mask !== i.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1) } } class Uo extends Bt { getDefault() { const e = this.gl; return [e.KEEP, e.KEEP, e.KEEP] } set(e) { const i = this.current; (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1) } } class $o extends Bt { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const i = this.gl; e ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST), this.current = e, this.dirty = !1 } } class Go extends Bt { getDefault() { return [0, 1] } set(e) { const i = this.current; (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1) } } class dl extends Bt { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const i = this.gl; e ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST), this.current = e, this.dirty = !1 } } class Xn extends Bt { getDefault() { return this.gl.LESS } set(e) { (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1) } } class ws extends Bt { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const i = this.gl; e ? i.enable(i.BLEND) : i.disable(i.BLEND), this.current = e, this.dirty = !1 } } class Vr extends Bt { getDefault() { const e = this.gl; return [e.ONE, e.ZERO] } set(e) { const i = this.current; (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1) } } class Uc extends Bt { getDefault() { return c.b6.transparent } set(e) { const i = this.current; (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1) } } class $c extends Bt { getDefault() { return this.gl.FUNC_ADD } set(e) { (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1) } } class pl extends Bt { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const i = this.gl; e ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE), this.current = e, this.dirty = !1 } } class Kn extends Bt { getDefault() { return this.gl.BACK } set(e) { (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1) } } class qo extends Bt { getDefault() { return this.gl.CCW } set(e) { (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1) } } class Ho extends Bt { getDefault() { return null } set(e) { (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1) } } class to extends Bt { getDefault() { return this.gl.TEXTURE0 } set(e) { (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1) } } class Wo extends Bt { getDefault() { const e = this.gl; return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight] } set(e) { const i = this.current; (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1) } } class Gc extends Bt { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const i = this.gl; i.bindFramebuffer(i.FRAMEBUFFER, e), this.current = e, this.dirty = !1 } } class Ts extends Bt { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const i = this.gl; i.bindRenderbuffer(i.RENDERBUFFER, e), this.current = e, this.dirty = !1 } } class Ps extends Bt { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const i = this.gl; i.bindTexture(i.TEXTURE_2D, e), this.current = e, this.dirty = !1 } } class qc extends Bt { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const i = this.gl; i.bindBuffer(i.ARRAY_BUFFER, e), this.current = e, this.dirty = !1 } } class fl extends Bt { getDefault() { return null } set(e) { const i = this.gl; i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1 } } class Ft extends Bt { getDefault() { return null } set(e) { var i; if (e === this.current && !this.dirty) return; const o = this.gl; jr(o) ? o.bindVertexArray(e) : (i = o.getExtension("OES_vertex_array_object")) === null || i === void 0 || i.bindVertexArrayOES(e), this.current = e, this.dirty = !1 } } class Xo extends Bt { getDefault() { return 4 } set(e) { if (e === this.current && !this.dirty) return; const i = this.gl; i.pixelStorei(i.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1 } } class bh extends Bt { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const i = this.gl; i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1 } } class Hc extends Bt { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const i = this.gl; i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1 } } class Jn extends Bt { constructor(e, i) { super(e), this.context = e, this.parent = i } getDefault() { return null } } class wh extends Jn { setDirty() { this.dirty = !0 } set(e) { if (e === this.current && !this.dirty) return; this.context.bindFramebuffer.set(this.parent); const i = this.gl; i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1 } } class Th extends Jn { set(e) { if (e === this.current && !this.dirty) return; this.context.bindFramebuffer.set(this.parent); const i = this.gl; i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1 } } class Wc extends Jn { set(e) { if (e === this.current && !this.dirty) return; this.context.bindFramebuffer.set(this.parent); const i = this.gl; i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, e), this.current = e, this.dirty = !1 } } const Xc = "Framebuffer is not complete"; class ml { constructor(e, i, o, a, h) { this.context = e, this.width = i, this.height = o; const f = e.gl, g = this.framebuffer = f.createFramebuffer(); if (this.colorAttachment = new wh(e, g), a) this.depthAttachment = h ? new Wc(e, g) : new Th(e, g); else if (h) throw new Error("Stencil cannot be set without depth"); if (f.checkFramebufferStatus(f.FRAMEBUFFER) !== f.FRAMEBUFFER_COMPLETE) throw new Error(Xc) } destroy() { const e = this.context.gl, i = this.colorAttachment.get(); if (i && e.deleteTexture(i), this.depthAttachment) { const o = this.depthAttachment.get(); o && e.deleteRenderbuffer(o) } e.deleteFramebuffer(this.framebuffer) } } class Ko { constructor(e) { var i, o; if (this.gl = e, this.clearColor = new _h(this), this.clearDepth = new gh(this), this.clearStencil = new yh(this), this.colorMask = new xh(this), this.depthMask = new Nc(this), this.stencilMask = new vh(this), this.stencilFunc = new Zc(this), this.stencilOp = new Uo(this), this.stencilTest = new $o(this), this.depthRange = new Go(this), this.depthTest = new dl(this), this.depthFunc = new Xn(this), this.blend = new ws(this), this.blendFunc = new Vr(this), this.blendColor = new Uc(this), this.blendEquation = new $c(this), this.cullFace = new pl(this), this.cullFaceSide = new Kn(this), this.frontFace = new qo(this), this.program = new Ho(this), this.activeTexture = new to(this), this.viewport = new Wo(this), this.bindFramebuffer = new Gc(this), this.bindRenderbuffer = new Ts(this), this.bindTexture = new Ps(this), this.bindVertexBuffer = new qc(this), this.bindElementBuffer = new fl(this), this.bindVertexArray = new Ft(this), this.pixelStoreUnpack = new Xo(this), this.pixelStoreUnpackPremultiplyAlpha = new bh(this), this.pixelStoreUnpackFlipY = new Hc(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), jr(e)) { this.HALF_FLOAT = e.HALF_FLOAT; const a = e.getExtension("EXT_color_buffer_half_float"); this.RGBA16F = (i = e.RGBA16F) !== null && i !== void 0 ? i : a == null ? void 0 : a.RGBA16F_EXT, this.RGB16F = (o = e.RGB16F) !== null && o !== void 0 ? o : a == null ? void 0 : a.RGB16F_EXT, e.getExtension("EXT_color_buffer_float") } else { e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear"); const a = e.getExtension("OES_texture_half_float"); this.HALF_FLOAT = a == null ? void 0 : a.HALF_FLOAT_OES } } setDefault() { this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault() } setDirty() { this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0 } createIndexBuffer(e, i) { return new Vc(this, e, i) } createVertexBuffer(e, i, o) { return new Wn(this, e, i, o) } createRenderbuffer(e, i, o) { const a = this.gl, h = a.createRenderbuffer(); return this.bindRenderbuffer.set(h), a.renderbufferStorage(a.RENDERBUFFER, e, i, o), this.bindRenderbuffer.set(null), h } createFramebuffer(e, i, o, a) { return new ml(this, e, i, o, a) } clear({ color: e, depth: i, stencil: o }) { const a = this.gl; let h = 0; e && (h |= a.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), i !== void 0 && (h |= a.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), o !== void 0 && (h |= a.STENCIL_BUFFER_BIT, this.clearStencil.set(o), this.stencilMask.set(255)), a.clear(h) } setCullFace(e) { e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace)) } setDepthMode(e) { e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1) } setStencilMode(e) { e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1) } setColorMode(e) { c.bB(e.blendFunction, ni.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask) } createVertexArray() { var e; return jr(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES() } deleteVertexArray(e) { var i; return jr(this.gl) ? this.gl.deleteVertexArray(e) : (i = this.gl.getExtension("OES_vertex_array_object")) === null || i === void 0 ? void 0 : i.deleteVertexArrayOES(e) } unbindVAO() { this.bindVertexArray.set(null) } } let Yn; function Jo(u, e, i, o, a) { const h = u.context, f = u.transform, g = h.gl, v = u.useProgram("collisionBox"), w = []; let I = 0, E = 0; for (let H = 0; H < o.length; H++) { const K = o[H], Q = e.getTile(K).getBucket(i); if (!Q) continue; const ee = a ? Q.textCollisionBox : Q.iconCollisionBox, re = Q.collisionCircleArray; re.length > 0 && (w.push({ circleArray: re, circleOffset: E, coord: K }), I += re.length / 4, E = I), ee && v.draw(h, g.LINES, yt.disabled, zt.disabled, u.colorModeForRenderPass(), Ct.disabled, rl(u.transform), u.style.map.terrain && u.style.map.terrain.getTerrainData(K), f.getProjectionData({ overscaledTileID: K, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), i.id, ee.layoutVertexBuffer, ee.indexBuffer, ee.segments, null, u.transform.zoom, null, null, ee.collisionVertexBuffer) } if (!a || !w.length) return; const A = u.useProgram("collisionCircle"), B = new c.bO; B.resize(4 * I), B._trim(); let j = 0; for (const H of w) for (let K = 0; K < H.circleArray.length / 4; K++) { const Q = 4 * K, ee = H.circleArray[Q + 0], re = H.circleArray[Q + 1], oe = H.circleArray[Q + 2], ne = H.circleArray[Q + 3]; B.emplace(j++, ee, re, oe, ne, 0), B.emplace(j++, ee, re, oe, ne, 1), B.emplace(j++, ee, re, oe, ne, 2), B.emplace(j++, ee, re, oe, ne, 3) } (!Yn || Yn.length < 2 * I) && (Yn = function (H) { const K = 2 * H, Q = new c.bQ; Q.resize(K), Q._trim(); for (let ee = 0; ee < K; ee++) { const re = 6 * ee; Q.uint16[re + 0] = 4 * ee + 0, Q.uint16[re + 1] = 4 * ee + 1, Q.uint16[re + 2] = 4 * ee + 2, Q.uint16[re + 3] = 4 * ee + 2, Q.uint16[re + 4] = 4 * ee + 3, Q.uint16[re + 5] = 4 * ee + 0 } return Q }(I)); const q = h.createIndexBuffer(Yn, !0), G = h.createVertexBuffer(B, c.bP.members, !0); for (const H of w) { const K = Rc(u.transform); A.draw(h, g.TRIANGLES, yt.disabled, zt.disabled, u.colorModeForRenderPass(), Ct.disabled, K, u.style.map.terrain && u.style.map.terrain.getTerrainData(H.coord), null, i.id, G, q, c.aF.simpleSegment(0, 2 * H.circleOffset, H.circleArray.length, H.circleArray.length / 2), null, u.transform.zoom, null, null, null) } G.destroy(), q.destroy() } const _l = c.as(new Float32Array(16)); function Kc(u, e, i, o, a, h) { const { horizontalAlign: f, verticalAlign: g } = c.aA(u); return new c.P((-(f - .5) * e / a + o[0]) * h, (-(g - .5) * i / a + o[1]) * h) } function Yo(u, e, i, o, a, h) { const f = e.tileAnchorPoint.add(new c.P(e.translation[0], e.translation[1])); if (e.pitchWithMap) { let g = o.mult(h); i || (g = g.rotate(-a)); const v = f.add(g); return be(v.x, v.y, e.pitchedLabelPlaneMatrix, e.getElevation).point } if (i) { const g = et(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(u), v = Math.atan(g.y / g.x) + (g.x < 0 ? Math.PI : 0); return u.add(o.rotate(v)) } return u.add(o) } function Qo(u, e, i, o, a, h, f, g, v, w, I, E) { const A = u.text.placedSymbolArray, B = u.text.dynamicLayoutVertexArray, j = u.icon.dynamicLayoutVertexArray, q = {}; B.clear(); for (let G = 0; G < A.length; G++) { const H = A.get(G), K = H.hidden || !H.crossTileID || u.allowVerticalPlacement && !H.placedOrientation ? null : o[H.crossTileID]; if (K) { const Q = new c.P(H.anchorX, H.anchorY), ee = { getElevation: E, width: a.width, height: a.height, pitchedLabelPlaneMatrix: h, pitchWithMap: i, transform: a, tileAnchorPoint: Q, translation: w, unwrappedTileID: I }, re = i ? xt(Q.x, Q.y, ee) : et(Q.x, Q.y, ee), oe = pe(a.cameraToCenterDistance, re.signedDistanceFromCamera); let ne = c.ah(u.textSizeData, g, H) * oe / c.au; i && (ne *= u.tilePixelRatio / f); const { width: me, height: ge, anchor: Se, textOffset: Ie, textBoxScale: Pe } = K, $e = Kc(Se, me, ge, Ie, Pe, ne), Ue = a.getPitchedTextCorrection(Q.x + w[0], Q.y + w[1], I), De = Yo(re.point, ee, e, $e, -a.bearingInRadians, Ue), tt = u.allowVerticalPlacement && H.placedOrientation === c.ag.vertical ? Math.PI / 2 : 0; for (let st = 0; st < H.numGlyphs; st++)c.an(B, De, tt); v && H.associatedIconIndex >= 0 && (q[H.associatedIconIndex] = { shiftedAnchor: De, angle: tt }) } else wi(H.numGlyphs, B) } if (v) { j.clear(); const G = u.icon.placedSymbolArray; for (let H = 0; H < G.length; H++) { const K = G.get(H); if (K.hidden) wi(K.numGlyphs, j); else { const Q = q[H]; if (Q) for (let ee = 0; ee < K.numGlyphs; ee++)c.an(j, Q.shiftedAnchor, Q.angle); else wi(K.numGlyphs, j) } } u.icon.dynamicLayoutVertexBuffer.updateData(j) } u.text.dynamicLayoutVertexBuffer.updateData(B) } function gl(u, e, i) { return i.iconsInText && e ? "symbolTextAndIcon" : u ? "symbolSDF" : "symbolIcon" } function Jc(u, e, i, o, a, h, f, g, v, w, I, E, A) { const B = u.context, j = B.gl, q = u.transform, G = g === "map", H = v === "map", K = g !== "viewport" && i.layout.get("symbol-placement") !== "point", Q = G && !H && !K, ee = !i.layout.get("symbol-sort-key").isConstant(); let re = !1; const oe = u.getDepthModeForSublayer(0, yt.ReadOnly), ne = i._unevaluatedLayout.hasValue("text-variable-anchor") || i._unevaluatedLayout.hasValue("text-variable-anchor-offset"), me = [], ge = q.getCircleRadiusCorrection(); for (const Se of o) { const Ie = e.getTile(Se), Pe = Ie.getBucket(i); if (!Pe) continue; const $e = a ? Pe.text : Pe.icon; if (!$e || !$e.segments.get().length || !$e.hasVisibleVertices) continue; const Ue = $e.programConfigurations.get(i.id), De = a || Pe.sdfIcons, tt = a ? Pe.textSizeData : Pe.iconSizeData, st = H || q.pitch !== 0, Ot = u.useProgram(gl(De, a, Pe), Ue), Jt = c.af(tt, q.zoom), $t = u.style.map.terrain && u.style.map.terrain.getTerrainData(Se); let oi, ei, jt, Gt, Li = [0, 0], Fi = null; if (a) ei = Ie.glyphAtlasTexture, jt = j.LINEAR, oi = Ie.glyphAtlasTexture.size, Pe.iconsInText && (Li = Ie.imageAtlasTexture.size, Fi = Ie.imageAtlasTexture, Gt = st || u.options.rotating || u.options.zooming || tt.kind === "composite" || tt.kind === "camera" ? j.LINEAR : j.NEAREST); else { const Yt = i.layout.get("icon-size").constantOr(0) !== 1 || Pe.iconsNeedLinear; ei = Ie.imageAtlasTexture, jt = De || u.options.rotating || u.options.zooming || Yt || st ? j.LINEAR : j.NEAREST, oi = Ie.imageAtlasTexture.size } const Ii = c.av(Ie, 1, u.transform.zoom), qi = ye(G, u.transform, Ii), kn = c.K(); c.ai(kn, qi); const yn = ce(H, G, u.transform, Ii), pn = c.aw(q, Ie, h, f), Ur = q.getProjectionData({ overscaledTileID: Se, applyGlobeMatrix: !A, applyTerrainMatrix: !0 }), ns = ne && Pe.hasTextData(), po = i.layout.get("icon-text-fit") !== "none" && ns && Pe.hasIconData(); if (K) { const Yt = u.style.map.terrain ? (Ci, Ei) => u.style.map.terrain.getElevation(Se, Ci, Ei) : null, Xt = i.layout.get("text-rotation-alignment") === "map"; fe(Pe, u, a, qi, kn, H, w, Xt, Se.toUnwrapped(), q.width, q.height, pn, Yt) } const ss = a && ne || po, $r = K || ss ? _l : H ? qi : u.transform.clipSpaceToPixelsMatrix, fn = De && i.paint.get(a ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0; let Jr; Jr = De ? Pe.iconsInText ? No(tt.kind, Jt, Q, H, K, ss, u, $r, yn, pn, oi, Li, ge) : ll(tt.kind, Jt, Q, H, K, ss, u, $r, yn, pn, a, oi, 0, ge) : Vo(tt.kind, Jt, Q, H, K, ss, u, $r, yn, pn, a, oi, ge); const mn = { program: Ot, buffers: $e, uniformValues: Jr, projectionData: Ur, atlasTexture: ei, atlasTextureIcon: Fi, atlasInterpolation: jt, atlasInterpolationIcon: Gt, isSDF: De, hasHalo: fn }; if (ee && Pe.canOverlap) { re = !0; const Yt = $e.segments.get(); for (const Xt of Yt) me.push({ segments: new c.aF([Xt]), sortKey: Xt.sortKey, state: mn, terrainData: $t }) } else me.push({ segments: $e.segments, sortKey: 0, state: mn, terrainData: $t }) } re && me.sort((Se, Ie) => Se.sortKey - Ie.sortKey); for (const Se of me) { const Ie = Se.state; if (B.activeTexture.set(j.TEXTURE0), Ie.atlasTexture.bind(Ie.atlasInterpolation, j.CLAMP_TO_EDGE), Ie.atlasTextureIcon && (B.activeTexture.set(j.TEXTURE1), Ie.atlasTextureIcon && Ie.atlasTextureIcon.bind(Ie.atlasInterpolationIcon, j.CLAMP_TO_EDGE)), Ie.isSDF) { const Pe = Ie.uniformValues; Ie.hasHalo && (Pe.u_is_halo = 1, ea(Ie.buffers, Se.segments, i, u, Ie.program, oe, I, E, Pe, Ie.projectionData, Se.terrainData)), Pe.u_is_halo = 0 } ea(Ie.buffers, Se.segments, i, u, Ie.program, oe, I, E, Ie.uniformValues, Ie.projectionData, Se.terrainData) } } function ea(u, e, i, o, a, h, f, g, v, w, I) { const E = o.context; a.draw(E, E.gl.TRIANGLES, h, f, g, Ct.backCCW, v, I, w, i.id, u.layoutVertexBuffer, u.indexBuffer, e, i.paint, o.transform.zoom, u.programConfigurations.get(i.id), u.dynamicLayoutVertexBuffer, u.opacityVertexBuffer) } function Ph(u, e, i, o, a) { const h = u.context, f = h.gl, g = zt.disabled, v = new ni([f.ONE, f.ONE], c.b6.transparent, [!0, !0, !0, !0]), w = e.getBucket(i); if (!w) return; const I = o.key; let E = i.heatmapFbos.get(I); E || (E = io(h, e.tileSize, e.tileSize), i.heatmapFbos.set(I, E)), h.bindFramebuffer.set(E.framebuffer), h.viewport.set([0, 0, e.tileSize, e.tileSize]), h.clear({ color: c.b6.transparent }); const A = w.programConfigurations.get(i.id), B = u.useProgram("heatmap", A, !a), j = u.transform.getProjectionData({ overscaledTileID: e.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), q = u.style.map.terrain.getTerrainData(o); B.draw(h, f.TRIANGLES, yt.disabled, g, v, Ct.disabled, sl(e, u.transform.zoom, i.paint.get("heatmap-intensity"), 1), q, j, i.id, w.layoutVertexBuffer, w.indexBuffer, w.segments, i.paint, u.transform.zoom, A) } function Yc(u, e, i, o, a) { const h = u.context, f = h.gl, g = u.transform; h.setColorMode(u.colorModeForRenderPass()); const v = ta(h, e), w = i.key, I = e.heatmapFbos.get(w); if (!I) return; h.activeTexture.set(f.TEXTURE0), f.bindTexture(f.TEXTURE_2D, I.colorAttachment.get()), h.activeTexture.set(f.TEXTURE1), v.bind(f.LINEAR, f.CLAMP_TO_EDGE); const E = g.getProjectionData({ overscaledTileID: i, applyTerrainMatrix: a, applyGlobeMatrix: !o }); u.useProgram("heatmapTexture").draw(h, f.TRIANGLES, yt.disabled, zt.disabled, u.colorModeForRenderPass(), Ct.disabled, ol(u, e, 0, 1), null, E, e.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments, e.paint, g.zoom), I.destroy(), e.heatmapFbos.delete(w) } function io(u, e, i) { var o, a; const h = u.gl, f = h.createTexture(); h.bindTexture(h.TEXTURE_2D, f), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR); const g = (o = u.HALF_FLOAT) !== null && o !== void 0 ? o : h.UNSIGNED_BYTE, v = (a = u.RGBA16F) !== null && a !== void 0 ? a : h.RGBA; h.texImage2D(h.TEXTURE_2D, 0, v, e, i, 0, h.RGBA, g, null); const w = u.createFramebuffer(e, i, !1, !1); return w.colorAttachment.set(f), w } function ta(u, e) { return e.colorRampTexture || (e.colorRampTexture = new Nt(u, e.colorRamp, u.gl.RGBA)), e.colorRampTexture } function yl(u, e, i, o, a) { if (!i || !o || !o.imageAtlas) return; const h = o.imageAtlas.patternPositions; let f = h[i.to.toString()], g = h[i.from.toString()]; if (!f && g && (f = g), !g && f && (g = f), !f || !g) { const v = a.getPaintProperty(e); f = h[v], g = h[v] } f && g && u.setConstantPatternPositions(f, g) } function xl(u, e, i, o, a, h, f, g) { const v = u.context.gl, w = "fill-pattern", I = i.paint.get(w), E = I && I.constantOr(1), A = i.getCrossfadeParameters(); let B, j, q, G, H; const K = u.transform, Q = i.paint.get("fill-translate"), ee = i.paint.get("fill-translate-anchor"); f ? (j = E && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", B = v.LINES) : (j = E ? "fillPattern" : "fill", B = v.TRIANGLES); const re = I.constantOr(null); for (const oe of o) { const ne = e.getTile(oe); if (E && !ne.patternsLoaded()) continue; const me = ne.getBucket(i); if (!me) continue; const ge = me.programConfigurations.get(i.id), Se = u.useProgram(j, ge), Ie = u.style.map.terrain && u.style.map.terrain.getTerrainData(oe); E && (u.context.activeTexture.set(v.TEXTURE0), ne.imageAtlasTexture.bind(v.LINEAR, v.CLAMP_TO_EDGE), ge.updatePaintBuffers(A)), yl(ge, w, re, ne, i); const Pe = K.getProjectionData({ overscaledTileID: oe, applyGlobeMatrix: !g, applyTerrainMatrix: !0 }), $e = c.aw(K, ne, Q, ee); if (f) { G = me.indexBuffer2, H = me.segments2; const De = [v.drawingBufferWidth, v.drawingBufferHeight]; q = j === "fillOutlinePattern" && E ? ph(u, A, ne, De, $e) : kc(De, $e) } else G = me.indexBuffer, H = me.segments, q = E ? zc(u, A, ne, $e) : { u_fill_translate: $e }; let Ue; if (u.renderPass === "translucent" && g) { const [De] = u.getStencilConfigForOverlapAndUpdateStencilID(o); Ue = De[oe.overscaledZ] } else Ue = u.stencilModeForClipping(oe); Se.draw(u.context, B, a, Ue, h, Ct.backCCW, q, Ie, Pe, i.id, me.layoutVertexBuffer, G, H, i.paint, u.transform.zoom, ge) } } function Ss(u, e, i, o, a, h, f, g) { const v = u.context, w = v.gl, I = "fill-extrusion-pattern", E = i.paint.get(I), A = E.constantOr(1), B = i.getCrossfadeParameters(), j = i.paint.get("fill-extrusion-opacity"), q = E.constantOr(null), G = u.transform; for (const H of o) { const K = e.getTile(H), Q = K.getBucket(i); if (!Q) continue; const ee = u.style.map.terrain && u.style.map.terrain.getTerrainData(H), re = Q.programConfigurations.get(i.id), oe = u.useProgram(A ? "fillExtrusionPattern" : "fillExtrusion", re); A && (u.context.activeTexture.set(w.TEXTURE0), K.imageAtlasTexture.bind(w.LINEAR, w.CLAMP_TO_EDGE), re.updatePaintBuffers(B)); const ne = G.getProjectionData({ overscaledTileID: H, applyGlobeMatrix: !g, applyTerrainMatrix: !0 }); yl(re, I, q, K, i); const me = c.aw(G, K, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")), ge = i.paint.get("fill-extrusion-vertical-gradient"), Se = A ? bs(u, ge, j, me, H, B, K) : Ac(u, ge, j, me); oe.draw(v, v.gl.TRIANGLES, a, h, f, Ct.backCCW, Se, ee, ne, i.id, Q.layoutVertexBuffer, Q.indexBuffer, Q.segments, i.paint, u.transform.zoom, re, u.style.map.terrain && Q.centroidVertexBuffer) } } function ro(u, e, i, o, a, h, f, g, v) { var w; const I = u.style.projection, E = u.context, A = u.transform, B = E.gl, j = u.useProgram("hillshade"), q = !u.options.moving; for (const G of o) { const H = e.getTile(G), K = H.fbo; if (!K) continue; const Q = I.getMeshFromTileID(E, G.canonical, g, !0, "raster"), ee = (w = u.style.map.terrain) === null || w === void 0 ? void 0 : w.getTerrainData(G); E.activeTexture.set(B.TEXTURE0), B.bindTexture(B.TEXTURE_2D, K.colorAttachment.get()); const re = A.getProjectionData({ overscaledTileID: G, aligned: q, applyGlobeMatrix: !v, applyTerrainMatrix: !0 }); j.draw(E, B.TRIANGLES, h, a[G.overscaledZ], f, Ct.backCCW, qn(u, H, i), ee, re, i.id, Q.vertexBuffer, Q.indexBuffer, Q.segments) } } const vl = [new c.P(0, 0), new c.P(c.Z, 0), new c.P(c.Z, c.Z), new c.P(0, c.Z)]; function no(u, e, i, o, a, h, f, g, v = !1, w = !1) { const I = o[o.length - 1].overscaledZ, E = u.context, A = E.gl, B = u.useProgram("raster"), j = u.transform, q = u.style.projection, G = u.colorModeForRenderPass(), H = !u.options.moving; for (const K of o) { const Q = u.getDepthModeForSublayer(K.overscaledZ - I, i.paint.get("raster-opacity") === 1 ? yt.ReadWrite : yt.ReadOnly, A.LESS), ee = e.getTile(K); ee.registerFadeDuration(i.paint.get("raster-fade-duration")); const re = e.findLoadedParent(K, 0), oe = e.findLoadedSibling(K), ne = _i(ee, re || oe || null, e, i, u.transform, u.style.map.terrain); let me, ge; const Se = i.paint.get("raster-resampling") === "nearest" ? A.NEAREST : A.LINEAR; E.activeTexture.set(A.TEXTURE0), ee.texture.bind(Se, A.CLAMP_TO_EDGE, A.LINEAR_MIPMAP_NEAREST), E.activeTexture.set(A.TEXTURE1), re ? (re.texture.bind(Se, A.CLAMP_TO_EDGE, A.LINEAR_MIPMAP_NEAREST), me = Math.pow(2, re.tileID.overscaledZ - ee.tileID.overscaledZ), ge = [ee.tileID.canonical.x * me % 1, ee.tileID.canonical.y * me % 1]) : ee.texture.bind(Se, A.CLAMP_TO_EDGE, A.LINEAR_MIPMAP_NEAREST), ee.texture.useMipmap && E.extTextureFilterAnisotropic && u.transform.pitch > 20 && A.texParameterf(A.TEXTURE_2D, E.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, E.extTextureFilterAnisotropicMax); const Ie = u.style.map.terrain && u.style.map.terrain.getTerrainData(K), Pe = j.getProjectionData({ overscaledTileID: K, aligned: H, applyGlobeMatrix: !w, applyTerrainMatrix: !0 }), $e = Oc(ge || [0, 0], me || 1, ne, i, g), Ue = q.getMeshFromTileID(E, K.canonical, h, f, "raster"); B.draw(E, A.TRIANGLES, Q, a ? a[K.overscaledZ] : zt.disabled, G, v ? Ct.frontCCW : Ct.backCCW, $e, Ie, Pe, i.id, Ue.vertexBuffer, Ue.indexBuffer, Ue.segments) } } function _i(u, e, i, o, a, h) { const f = o.paint.get("raster-fade-duration"); if (!h && f > 0) { const g = Le.now(), v = (g - u.timeAdded) / f, w = e ? (g - e.timeAdded) / f : -1, I = i.getSource(), E = Rr(a, { tileSize: I.tileSize, roundZoom: I.roundZoom }), A = !e || Math.abs(e.tileID.overscaledZ - E) > Math.abs(u.tileID.overscaledZ - E), B = A && u.refreshedUponExpiration ? 1 : c.ad(A ? v : 1 - w, 0, 1); return u.refreshedUponExpiration && v >= 1 && (u.refreshedUponExpiration = !1), e ? { opacity: 1, mix: 1 - B } : { opacity: B, mix: 0 } } return { opacity: 1, mix: 0 } } const Qn = new c.b6(1, 0, 0, 1), Nr = new c.b6(0, 1, 0, 1), bl = new c.b6(0, 0, 1, 1), wl = new c.b6(1, 0, 1, 1), Qc = new c.b6(0, 1, 1, 1); function es(u, e, i, o) { Is(u, 0, e + i / 2, u.transform.width, i, o) } function Ms(u, e, i, o) { Is(u, e - i / 2, 0, i, u.transform.height, o) } function Is(u, e, i, o, a, h) { const f = u.context, g = f.gl; g.enable(g.SCISSOR_TEST), g.scissor(e * u.pixelRatio, i * u.pixelRatio, o * u.pixelRatio, a * u.pixelRatio), f.clear({ color: h }), g.disable(g.SCISSOR_TEST) } function eu(u, e, i) { const o = u.context, a = o.gl, h = u.useProgram("debug"), f = yt.disabled, g = zt.disabled, v = u.colorModeForRenderPass(), w = "$debug", I = u.style.map.terrain && u.style.map.terrain.getTerrainData(i); o.activeTexture.set(a.TEXTURE0); const E = e.getTileByID(i.key).latestRawTileData, A = Math.floor((E && E.byteLength || 0) / 1024), B = e.getTile(i).tileSize, j = 512 / Math.min(B, 512) * (i.overscaledZ / u.transform.zoom) * .5; let q = i.canonical.toString(); i.overscaledZ !== i.canonical.z && (q += ` => ${i.overscaledZ}`), function (H, K) { H.initDebugOverlayCanvas(); const Q = H.debugOverlayCanvas, ee = H.context.gl, re = H.debugOverlayCanvas.getContext("2d"); re.clearRect(0, 0, Q.width, Q.height), re.shadowColor = "white", re.shadowBlur = 2, re.lineWidth = 1.5, re.strokeStyle = "white", re.textBaseline = "top", re.font = "bold 36px Open Sans, sans-serif", re.fillText(K, 5, 5), re.strokeText(K, 5, 5), H.debugOverlayTexture.update(Q), H.debugOverlayTexture.bind(ee.LINEAR, ee.CLAMP_TO_EDGE) }(u, `${q} ${A}kB`); const G = u.transform.getProjectionData({ overscaledTileID: i, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }); h.draw(o, a.TRIANGLES, f, g, ni.alphaBlended, Ct.disabled, nl(c.b6.transparent, j), null, G, w, u.debugBuffer, u.quadTriangleIndexBuffer, u.debugSegments), h.draw(o, a.LINE_STRIP, f, g, v, Ct.disabled, nl(c.b6.red), I, G, w, u.debugBuffer, u.tileBorderIndexBuffer, u.debugSegments) } function Tl(u, e, i, o) { const { isRenderingGlobe: a } = o, h = u.context, f = h.gl, g = u.transform, v = u.colorModeForRenderPass(), w = u.getDepthModeFor3D(), I = u.useProgram("terrain"); h.bindFramebuffer.set(null), h.viewport.set([0, 0, u.width, u.height]); for (const E of i) { const A = e.getTerrainMesh(E.tileID), B = u.renderToTexture.getTexture(E), j = e.getTerrainData(E.tileID); h.activeTexture.set(f.TEXTURE0), f.bindTexture(f.TEXTURE_2D, B.texture); const q = e.getMeshFrameDelta(g.zoom), G = g.calculateFogMatrix(E.tileID.toUnwrapped()), H = il(q, G, u.style.sky, g.pitch, a), K = g.getProjectionData({ overscaledTileID: E.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }); I.draw(h, f.TRIANGLES, w, zt.disabled, v, Ct.backCCW, H, j, K, "terrain", A.vertexBuffer, A.indexBuffer, A.segments) } } function Pl(u, e) { if (!e.mesh) { const i = new c.aE; i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1); const o = new c.aG; o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), e.mesh = new vr(u.createVertexBuffer(i, Lr.members), u.createIndexBuffer(o), c.aF.simpleSegment(0, 0, i.length, o.length)) } return e.mesh } class tu {
          constructor(e, i) { this.context = new Ko(e), this.transform = i, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: c.as(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = C.maxUnderzooming + C.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Wa } resize(e, i, o) { if (this.width = Math.floor(e * o), this.height = Math.floor(i * o), this.pixelRatio = o, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const a of this.style._order) this.style._layers[a].resize() } setup() { const e = this.context, i = new c.aE; i.emplaceBack(0, 0), i.emplaceBack(c.Z, 0), i.emplaceBack(0, c.Z), i.emplaceBack(c.Z, c.Z), this.tileExtentBuffer = e.createVertexBuffer(i, Lr.members), this.tileExtentSegments = c.aF.simpleSegment(0, 0, 4, 2); const o = new c.aE; o.emplaceBack(0, 0), o.emplaceBack(c.Z, 0), o.emplaceBack(0, c.Z), o.emplaceBack(c.Z, c.Z), this.debugBuffer = e.createVertexBuffer(o, Lr.members), this.debugSegments = c.aF.simpleSegment(0, 0, 4, 5); const a = new c.bV; a.emplaceBack(0, 0, 0, 0), a.emplaceBack(c.Z, 0, c.Z, 0), a.emplaceBack(0, c.Z, 0, c.Z), a.emplaceBack(c.Z, c.Z, c.Z, c.Z), this.rasterBoundsBuffer = e.createVertexBuffer(a, cn.members), this.rasterBoundsSegments = c.aF.simpleSegment(0, 0, 4, 2); const h = new c.aE; h.emplaceBack(0, 0), h.emplaceBack(c.Z, 0), h.emplaceBack(0, c.Z), h.emplaceBack(c.Z, c.Z), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(h, Lr.members), this.rasterBoundsSegmentsPosOnly = c.aF.simpleSegment(0, 0, 4, 5); const f = new c.aE; f.emplaceBack(0, 0), f.emplaceBack(1, 0), f.emplaceBack(0, 1), f.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(f, Lr.members), this.viewportSegments = c.aF.simpleSegment(0, 0, 4, 2); const g = new c.bW; g.emplaceBack(0), g.emplaceBack(1), g.emplaceBack(3), g.emplaceBack(2), g.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(g); const v = new c.aG; v.emplaceBack(1, 0, 2), v.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(v); const w = this.context.gl; this.stencilClearMode = new zt({ func: w.ALWAYS, mask: 0 }, 0, 255, w.ZERO, w.ZERO, w.ZERO), this.tileExtentMesh = new vr(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments) } clearStencil() { const e = this.context, i = e.gl; this.nextStencilID = 1, this.currentStencilSource = void 0; const o = c.K(); c.bN(o, 0, this.width, this.height, 0, 0, 1), c.M(o, o, [i.drawingBufferWidth, i.drawingBufferHeight, 0]); const a = { mainMatrix: o, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: o }; this.useProgram("clippingMask", null, !0).draw(e, i.TRIANGLES, yt.disabled, this.stencilClearMode, ni.disabled, Ct.disabled, null, null, a, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments) } _renderTileClippingMasks(e, i, o) { if (this.currentStencilSource === e.source || !e.isTileClipped() || !i || !i.length) return; this.currentStencilSource = e.source, this.nextStencilID + i.length > 256 && this.clearStencil(); const a = this.context; a.setColorMode(ni.disabled), a.setDepthMode(yt.disabled); const h = {}; for (const f of i) h[f.key] = this.nextStencilID++; this._renderTileMasks(h, i, o, !0), this._renderTileMasks(h, i, o, !1), this._tileClippingMaskIDs = h } _renderTileMasks(e, i, o, a) { const h = this.context, f = h.gl, g = this.style.projection, v = this.transform, w = this.useProgram("clippingMask"); for (const I of i) { const E = e[I.key], A = this.style.map.terrain && this.style.map.terrain.getTerrainData(I), B = g.getMeshFromTileID(this.context, I.canonical, a, !0, "stencil"), j = v.getProjectionData({ overscaledTileID: I, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }); w.draw(h, f.TRIANGLES, yt.disabled, new zt({ func: f.ALWAYS, mask: 0 }, E, 255, f.KEEP, f.KEEP, f.REPLACE), ni.disabled, o ? Ct.disabled : Ct.backCCW, null, A, j, "$clipping", B.vertexBuffer, B.indexBuffer, B.segments) } } _renderTilesDepthBuffer() { const e = this.context, i = e.gl, o = this.style.projection, a = this.transform, h = this.useProgram("depth"), f = this.getDepthModeFor3D(), g = ue(a, { tileSize: a.tileSize }); for (const v of g) { const w = this.style.map.terrain && this.style.map.terrain.getTerrainData(v), I = o.getMeshFromTileID(this.context, v.canonical, !0, !0, "raster"), E = a.getProjectionData({ overscaledTileID: v, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }); h.draw(e, i.TRIANGLES, f, zt.disabled, ni.disabled, Ct.backCCW, null, w, E, "$clipping", I.vertexBuffer, I.indexBuffer, I.segments) } } stencilModeFor3D() { this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil(); const e = this.nextStencilID++, i = this.context.gl; return new zt({ func: i.NOTEQUAL, mask: 255 }, e, 255, i.KEEP, i.KEEP, i.REPLACE) } stencilModeForClipping(e) { const i = this.context.gl; return new zt({ func: i.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, i.KEEP, i.KEEP, i.REPLACE) } getStencilConfigForOverlapAndUpdateStencilID(e) { const i = this.context.gl, o = e.sort((f, g) => g.overscaledZ - f.overscaledZ), a = o[o.length - 1].overscaledZ, h = o[0].overscaledZ - a + 1; if (h > 1) { this.currentStencilSource = void 0, this.nextStencilID + h > 256 && this.clearStencil(); const f = {}; for (let g = 0; g < h; g++)f[g + a] = new zt({ func: i.GEQUAL, mask: 255 }, g + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE); return this.nextStencilID += h, [f, o] } return [{ [a]: zt.disabled }, o] } stencilConfigForOverlapTwoPass(e) { const i = this.context.gl, o = e.sort((f, g) => g.overscaledZ - f.overscaledZ), a = o[o.length - 1].overscaledZ, h = o[0].overscaledZ - a + 1; if (this.clearStencil(), h > 1) { const f = {}, g = {}; for (let v = 0; v < h; v++)f[v + a] = new zt({ func: i.GREATER, mask: 255 }, h + 1 + v, 255, i.KEEP, i.KEEP, i.REPLACE), g[v + a] = new zt({ func: i.GREATER, mask: 255 }, 1 + v, 255, i.KEEP, i.KEEP, i.REPLACE); return this.nextStencilID = 2 * h + 1, [f, g, o] } return this.nextStencilID = 3, [{ [a]: new zt({ func: i.GREATER, mask: 255 }, 2, 255, i.KEEP, i.KEEP, i.REPLACE) }, { [a]: new zt({ func: i.GREATER, mask: 255 }, 1, 255, i.KEEP, i.KEEP, i.REPLACE) }, o] } colorModeForRenderPass() { const e = this.context.gl; return this._showOverdrawInspector ? new ni([e.CONSTANT_COLOR, e.ONE], new c.b6(.125, .125, .125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? ni.unblended : ni.alphaBlended } getDepthModeForSublayer(e, i, o) { if (!this.opaquePassEnabledForLayer()) return yt.disabled; const a = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon; return new yt(o || this.context.gl.LEQUAL, i, [a, a]) } getDepthModeFor3D() { return new yt(this.context.gl.LEQUAL, yt.ReadWrite, this.depthRangeFor3D) } opaquePassEnabledForLayer() { return this.currentLayer < this.opaquePassCutoff } render(e, i) { var o, a; this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(Le.now()), this.imageManager.beginFrame(); const h = this.style._order, f = this.style.sourceCaches, g = {}, v = {}, w = {}, I = { isRenderingToTexture: !1, isRenderingGlobe: ((o = e.projection) === null || o === void 0 ? void 0 : o.transitionState) > 0 }; for (const A in f) { const B = f[A]; B.used && B.prepare(this.context), g[A] = B.getVisibleCoordinates(!1), v[A] = g[A].slice().reverse(), w[A] = B.getVisibleCoordinates(!0).reverse() } this.opaquePassCutoff = 1 / 0; for (let A = 0; A < h.length; A++)if (this.style._layers[h[A]].is3D()) { this.opaquePassCutoff = A; break } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen"; for (const A of h) { const B = this.style._layers[A]; if (!B.hasOffscreenPass() || B.isHidden(this.transform.zoom)) continue; const j = v[B.source]; (B.type === "custom" || j.length) && this.renderLayer(this, f[B.source], B, j, I) } if ((a = this.style.projection) === null || a === void 0 || a.updateGPUdependent({ context: this.context, useProgram: A => this.useProgram(A) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: i.showOverdrawInspector ? c.b6.black : c.b6.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function (A, B) { const j = A.context, q = j.gl, G = ((oe, ne, me) => { const ge = Math.cos(ne.rollInRadians), Se = Math.sin(ne.rollInRadians), Ie = Di(ne), Pe = ne.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition; return { u_sky_color: oe.properties.get("sky-color"), u_horizon_color: oe.properties.get("horizon-color"), u_horizon: [(ne.width / 2 - Ie * Se) * me, (ne.height / 2 + Ie * ge) * me], u_horizon_normal: [-Se, ge], u_sky_horizon_blend: oe.properties.get("sky-horizon-blend") * ne.height / 2 * me, u_sky_blend: Pe } })(B, A.style.map.transform, A.pixelRatio), H = new yt(q.LEQUAL, yt.ReadWrite, [0, 1]), K = zt.disabled, Q = A.colorModeForRenderPass(), ee = A.useProgram("sky"), re = Pl(j, B); ee.draw(j, q.TRIANGLES, H, K, Q, Ct.disabled, G, null, void 0, "sky", re.vertexBuffer, re.indexBuffer, re.segments) }(this, this.style.sky), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = h.length - 1; this.currentLayer >= 0; this.currentLayer--) { const A = this.style._layers[h[this.currentLayer]], B = f[A.source], j = g[A.source]; this._renderTileClippingMasks(A, j, !1), this.renderLayer(this, B, A, j, I) } this.renderPass = "translucent"; let E = !1; for (this.currentLayer = 0; this.currentLayer < h.length; this.currentLayer++) { const A = this.style._layers[h[this.currentLayer]], B = f[A.source]; if (this.renderToTexture && this.renderToTexture.renderLayer(A, I)) continue; this.opaquePassEnabledForLayer() || E || (E = !0, I.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer()); const j = (A.type === "symbol" ? w : v)[A.source]; this._renderTileClippingMasks(A, g[A.source], !1), this.renderLayer(this, B, A, j, I) } if (I.isRenderingGlobe && function (A, B, j) { const q = A.context, G = q.gl, H = A.useProgram("atmosphere"), K = new yt(G.LEQUAL, yt.ReadOnly, [0, 1]), Q = A.transform, ee = function (Pe, $e) { const Ue = Pe.properties.get("position"), De = [-Ue.x, -Ue.y, -Ue.z], tt = c.as(new Float64Array(16)); return Pe.properties.get("anchor") === "map" && (c.aZ(tt, tt, $e.rollInRadians), c.a_(tt, tt, -$e.pitchInRadians), c.aZ(tt, tt, $e.bearingInRadians), c.a_(tt, tt, $e.center.lat * Math.PI / 180), c.bl(tt, tt, -$e.center.lng * Math.PI / 180)), c.bU(De, De, tt), De }(j, A.transform), re = Q.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), oe = B.properties.get("atmosphere-blend") * re.projectionTransition; if (oe === 0) return; const ne = Qi(Q.worldSize, Q.center.lat), me = Q.inverseProjectionMatrix, ge = new Float64Array(4); ge[3] = 1, c.ao(ge, ge, Q.modelViewProjectionMatrix), ge[0] /= ge[3], ge[1] /= ge[3], ge[2] /= ge[3], ge[3] = 1, c.ao(ge, ge, me), ge[0] /= ge[3], ge[1] /= ge[3], ge[2] /= ge[3], ge[3] = 1; const Se = ((Pe, $e, Ue, De, tt) => ({ u_sun_pos: Pe, u_atmosphere_blend: $e, u_globe_position: Ue, u_globe_radius: De, u_inv_proj_matrix: tt }))(ee, oe, [ge[0], ge[1], ge[2]], ne, me), Ie = Pl(q, B); H.draw(q, G.TRIANGLES, K, zt.disabled, ni.alphaBlended, Ct.disabled, Se, null, null, "atmosphere", Ie.vertexBuffer, Ie.indexBuffer, Ie.segments) }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) { const A = function (B, j) { let q = null; const G = Object.values(B._layers).flatMap(ee => ee.source && !ee.isHidden(j) ? [B.sourceCaches[ee.source]] : []), H = G.filter(ee => ee.getSource().type === "vector"), K = G.filter(ee => ee.getSource().type !== "vector"), Q = ee => { (!q || q.getSource().maxzoom < ee.getSource().maxzoom) && (q = ee) }; return H.forEach(ee => Q(ee)), q || K.forEach(ee => Q(ee)), q }(this.style, this.transform.zoom); A && function (B, j, q) { for (let G = 0; G < q.length; G++)eu(B, j, q[G]) }(this, A, A.getVisibleCoordinates()) } this.options.showPadding && function (A) { const B = A.transform.padding; es(A, A.transform.height - (B.top || 0), 3, Qn), es(A, B.bottom || 0, 3, Nr), Ms(A, B.left || 0, 3, bl), Ms(A, A.transform.width - (B.right || 0), 3, wl); const j = A.transform.centerPoint; (function (q, G, H, K) { Is(q, G - 1, H - 10, 2, 20, K), Is(q, G - 10, H - 1, 20, 2, K) })(A, j.x, A.transform.height - j.y, Qc) }(this), this.context.setDefault() } maybeDrawDepthAndCoords(e) { if (!this.style || !this.style.map || !this.style.map.terrain) return; const i = this.terrainFacilitator.matrix, o = this.transform.modelViewProjectionMatrix; let a = this.terrainFacilitator.dirty; a || (a = e ? !c.bX(i, o) : !c.bY(i, o)), a || (a = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), a && (c.bZ(i, o), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function (h, f) { const g = h.context, v = g.gl, w = h.transform, I = ni.unblended, E = new yt(v.LEQUAL, yt.ReadWrite, [0, 1]), A = f.sourceCache.getRenderableTiles(), B = h.useProgram("terrainDepth"); g.bindFramebuffer.set(f.getFramebuffer("depth").framebuffer), g.viewport.set([0, 0, h.width / devicePixelRatio, h.height / devicePixelRatio]), g.clear({ color: c.b6.transparent, depth: 1 }); for (const j of A) { const q = f.getTerrainMesh(j.tileID), G = f.getTerrainData(j.tileID), H = w.getProjectionData({ overscaledTileID: j.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), K = { u_ele_delta: f.getMeshFrameDelta(w.zoom) }; B.draw(g, v.TRIANGLES, E, zt.disabled, I, Ct.backCCW, K, G, H, "terrain", q.vertexBuffer, q.indexBuffer, q.segments) } g.bindFramebuffer.set(null), g.viewport.set([0, 0, h.width, h.height]) }(this, this.style.map.terrain), function (h, f) { const g = h.context, v = g.gl, w = h.transform, I = ni.unblended, E = new yt(v.LEQUAL, yt.ReadWrite, [0, 1]), A = f.getCoordsTexture(), B = f.sourceCache.getRenderableTiles(), j = h.useProgram("terrainCoords"); g.bindFramebuffer.set(f.getFramebuffer("coords").framebuffer), g.viewport.set([0, 0, h.width / devicePixelRatio, h.height / devicePixelRatio]), g.clear({ color: c.b6.transparent, depth: 1 }), f.coordsIndex = []; for (const q of B) { const G = f.getTerrainMesh(q.tileID), H = f.getTerrainData(q.tileID); g.activeTexture.set(v.TEXTURE0), v.bindTexture(v.TEXTURE_2D, A.texture); const K = { u_terrain_coords_id: (255 - f.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: f.getMeshFrameDelta(w.zoom) }, Q = w.getProjectionData({ overscaledTileID: q.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }); j.draw(g, v.TRIANGLES, E, zt.disabled, I, Ct.backCCW, K, H, Q, "terrain", G.vertexBuffer, G.indexBuffer, G.segments), f.coordsIndex.push(q.tileID.key) } g.bindFramebuffer.set(null), g.viewport.set([0, 0, h.width, h.height]) }(this, this.style.map.terrain)) } renderLayer(e, i, o, a, h) {
            o.isHidden(this.transform.zoom) || (o.type === "background" || o.type === "custom" || (a || []).length) && (this.id = o.id, c.b_(o) ? function (f, g, v, w, I, E) { if (f.renderPass !== "translucent") return; const { isRenderingToTexture: A } = E, B = zt.disabled, j = f.colorModeForRenderPass(); (v._unevaluatedLayout.hasValue("text-variable-anchor") || v._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function (q, G, H, K, Q, ee, re, oe, ne) { const me = G.transform, ge = G.style.map.terrain, Se = Q === "map", Ie = ee === "map"; for (const Pe of q) { const $e = K.getTile(Pe), Ue = $e.getBucket(H); if (!Ue || !Ue.text || !Ue.text.segments.get().length) continue; const De = c.af(Ue.textSizeData, me.zoom), tt = c.av($e, 1, G.transform.zoom), st = ye(Se, G.transform, tt), Ot = H.layout.get("icon-text-fit") !== "none" && Ue.hasIconData(); if (De) { const Jt = Math.pow(2, me.zoom - $e.tileID.overscaledZ), $t = ge ? (oi, ei) => ge.getElevation(Pe, oi, ei) : null; Qo(Ue, Se, Ie, ne, me, st, Jt, De, Ot, c.aw(me, $e, re, oe), Pe.toUnwrapped(), $t) } } }(w, f, v, g, v.layout.get("text-rotation-alignment"), v.layout.get("text-pitch-alignment"), v.paint.get("text-translate"), v.paint.get("text-translate-anchor"), I), v.paint.get("icon-opacity").constantOr(1) !== 0 && Jc(f, g, v, w, !1, v.paint.get("icon-translate"), v.paint.get("icon-translate-anchor"), v.layout.get("icon-rotation-alignment"), v.layout.get("icon-pitch-alignment"), v.layout.get("icon-keep-upright"), B, j, A), v.paint.get("text-opacity").constantOr(1) !== 0 && Jc(f, g, v, w, !0, v.paint.get("text-translate"), v.paint.get("text-translate-anchor"), v.layout.get("text-rotation-alignment"), v.layout.get("text-pitch-alignment"), v.layout.get("text-keep-upright"), B, j, A), g.map.showCollisionBoxes && (Jo(f, g, v, w, !0), Jo(f, g, v, w, !1)) }(e, i, o, a, this.style.placement.variableOffsets, h) : c.b$(o) ? function (f, g, v, w, I) { if (f.renderPass !== "translucent") return; const { isRenderingToTexture: E } = I, A = v.paint.get("circle-opacity"), B = v.paint.get("circle-stroke-width"), j = v.paint.get("circle-stroke-opacity"), q = !v.layout.get("circle-sort-key").isConstant(); if (A.constantOr(1) === 0 && (B.constantOr(1) === 0 || j.constantOr(1) === 0)) return; const G = f.context, H = G.gl, K = f.transform, Q = f.getDepthModeForSublayer(0, yt.ReadOnly), ee = zt.disabled, re = f.colorModeForRenderPass(), oe = [], ne = K.getCircleRadiusCorrection(); for (let me = 0; me < w.length; me++) { const ge = w[me], Se = g.getTile(ge), Ie = Se.getBucket(v); if (!Ie) continue; const Pe = v.paint.get("circle-translate"), $e = v.paint.get("circle-translate-anchor"), Ue = c.aw(K, Se, Pe, $e), De = Ie.programConfigurations.get(v.id), tt = f.useProgram("circle", De), st = Ie.layoutVertexBuffer, Ot = Ie.indexBuffer, Jt = f.style.map.terrain && f.style.map.terrain.getTerrainData(ge), $t = { programConfiguration: De, program: tt, layoutVertexBuffer: st, indexBuffer: Ot, uniformValues: Dc(f, Se, v, Ue, ne), terrainData: Jt, projectionData: K.getProjectionData({ overscaledTileID: ge, applyGlobeMatrix: !E, applyTerrainMatrix: !0 }) }; if (q) { const oi = Ie.segments.get(); for (const ei of oi) oe.push({ segments: new c.aF([ei]), sortKey: ei.sortKey, state: $t }) } else oe.push({ segments: Ie.segments, sortKey: 0, state: $t }) } q && oe.sort((me, ge) => me.sortKey - ge.sortKey); for (const me of oe) { const { programConfiguration: ge, program: Se, layoutVertexBuffer: Ie, indexBuffer: Pe, uniformValues: $e, terrainData: Ue, projectionData: De } = me.state; Se.draw(G, H.TRIANGLES, Q, ee, re, Ct.backCCW, $e, Ue, De, v.id, Ie, Pe, me.segments, v.paint, f.transform.zoom, ge) } }(e, i, o, a, h) : c.c0(o) ? function (f, g, v, w, I) { if (v.paint.get("heatmap-opacity") === 0) return; const E = f.context, { isRenderingToTexture: A, isRenderingGlobe: B } = I; if (f.style.map.terrain) { for (const j of w) { const q = g.getTile(j); g.hasRenderableParent(j) || (f.renderPass === "offscreen" ? Ph(f, q, v, j, B) : f.renderPass === "translucent" && Yc(f, v, j, A, B)) } E.viewport.set([0, 0, f.width, f.height]) } else f.renderPass === "offscreen" ? function (j, q, G, H) { const K = j.context, Q = K.gl, ee = j.transform, re = zt.disabled, oe = new ni([Q.ONE, Q.ONE], c.b6.transparent, [!0, !0, !0, !0]); (function (ne, me, ge) { const Se = ne.gl; ne.activeTexture.set(Se.TEXTURE1), ne.viewport.set([0, 0, me.width / 4, me.height / 4]); let Ie = ge.heatmapFbos.get(c.bR); Ie ? (Se.bindTexture(Se.TEXTURE_2D, Ie.colorAttachment.get()), ne.bindFramebuffer.set(Ie.framebuffer)) : (Ie = io(ne, me.width / 4, me.height / 4), ge.heatmapFbos.set(c.bR, Ie)) })(K, j, G), K.clear({ color: c.b6.transparent }); for (let ne = 0; ne < H.length; ne++) { const me = H[ne]; if (q.hasRenderableParent(me)) continue; const ge = q.getTile(me), Se = ge.getBucket(G); if (!Se) continue; const Ie = Se.programConfigurations.get(G.id), Pe = j.useProgram("heatmap", Ie), $e = ee.getProjectionData({ overscaledTileID: me, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), Ue = ee.getCircleRadiusCorrection(); Pe.draw(K, Q.TRIANGLES, yt.disabled, re, oe, Ct.backCCW, sl(ge, ee.zoom, G.paint.get("heatmap-intensity"), Ue), null, $e, G.id, Se.layoutVertexBuffer, Se.indexBuffer, Se.segments, G.paint, ee.zoom, Ie) } K.viewport.set([0, 0, j.width, j.height]) }(f, g, v, w) : f.renderPass === "translucent" && function (j, q) { const G = j.context, H = G.gl; G.setColorMode(j.colorModeForRenderPass()); const K = q.heatmapFbos.get(c.bR); K && (G.activeTexture.set(H.TEXTURE0), H.bindTexture(H.TEXTURE_2D, K.colorAttachment.get()), G.activeTexture.set(H.TEXTURE1), ta(G, q).bind(H.LINEAR, H.CLAMP_TO_EDGE), j.useProgram("heatmapTexture").draw(G, H.TRIANGLES, yt.disabled, zt.disabled, j.colorModeForRenderPass(), Ct.disabled, ol(j, q, 0, 1), null, null, q.id, j.viewportBuffer, j.quadTriangleIndexBuffer, j.viewportSegments, q.paint, j.transform.zoom)) }(f, v) }(e, i, o, a, h) : c.c1(o) ? function (f, g, v, w, I) { if (f.renderPass !== "translucent") return; const { isRenderingToTexture: E } = I, A = v.paint.get("line-opacity"), B = v.paint.get("line-width"); if (A.constantOr(1) === 0 || B.constantOr(1) === 0) return; const j = f.getDepthModeForSublayer(0, yt.ReadOnly), q = f.colorModeForRenderPass(), G = v.paint.get("line-dasharray"), H = v.paint.get("line-pattern"), K = H.constantOr(1), Q = v.paint.get("line-gradient"), ee = v.getCrossfadeParameters(), re = K ? "linePattern" : G ? "lineSDF" : Q ? "lineGradient" : "line", oe = f.context, ne = oe.gl, me = f.transform; let ge = !0; for (const Se of w) { const Ie = g.getTile(Se); if (K && !Ie.patternsLoaded()) continue; const Pe = Ie.getBucket(v); if (!Pe) continue; const $e = Pe.programConfigurations.get(v.id), Ue = f.context.program.get(), De = f.useProgram(re, $e), tt = ge || De.program !== Ue, st = f.style.map.terrain && f.style.map.terrain.getTerrainData(Se), Ot = H.constantOr(null); if (Ot && Ie.imageAtlas) { const jt = Ie.imageAtlas, Gt = jt.patternPositions[Ot.to.toString()], Li = jt.patternPositions[Ot.from.toString()]; Gt && Li && $e.setConstantPatternPositions(Gt, Li) } const Jt = me.getProjectionData({ overscaledTileID: Se, applyGlobeMatrix: !E, applyTerrainMatrix: !0 }), $t = me.getPixelScale(), oi = K ? jo(f, Ie, v, $t, ee) : G ? mh(f, Ie, v, $t, G, ee) : Q ? fh(f, Ie, v, $t, Pe.lineClipsArray.length) : Hn(f, Ie, v, $t); if (K) oe.activeTexture.set(ne.TEXTURE0), Ie.imageAtlasTexture.bind(ne.LINEAR, ne.CLAMP_TO_EDGE), $e.updatePaintBuffers(ee); else if (G && (tt || f.lineAtlas.dirty)) oe.activeTexture.set(ne.TEXTURE0), f.lineAtlas.bind(oe); else if (Q) { const jt = Pe.gradients[v.id]; let Gt = jt.texture; if (v.gradientVersion !== jt.version) { let Li = 256; if (v.stepInterpolant) { const Fi = g.getSource().maxzoom, Ii = Se.canonical.z === Fi ? Math.ceil(1 << f.transform.maxZoom - Se.canonical.z) : 1; Li = c.ad(c.bS(Pe.maxLineLength / c.Z * 1024 * Ii), 256, oe.maxTextureSize) } jt.gradient = c.bT({ expression: v.gradientExpression(), evaluationKey: "lineProgress", resolution: Li, image: jt.gradient || void 0, clips: Pe.lineClipsArray }), jt.texture ? jt.texture.update(jt.gradient) : jt.texture = new Nt(oe, jt.gradient, ne.RGBA), jt.version = v.gradientVersion, Gt = jt.texture } oe.activeTexture.set(ne.TEXTURE0), Gt.bind(v.stepInterpolant ? ne.NEAREST : ne.LINEAR, ne.CLAMP_TO_EDGE) } let ei; if (E) { const [jt] = f.getStencilConfigForOverlapAndUpdateStencilID(w); ei = jt[Se.overscaledZ] } else ei = f.stencilModeForClipping(Se); De.draw(oe, ne.TRIANGLES, j, ei, q, Ct.disabled, oi, st, Jt, v.id, Pe.layoutVertexBuffer, Pe.indexBuffer, Pe.segments, v.paint, f.transform.zoom, $e, Pe.layoutVertexBuffer2), ge = !1 } }(e, i, o, a, h) : c.c2(o) ? function (f, g, v, w, I) { const E = v.paint.get("fill-color"), A = v.paint.get("fill-opacity"); if (A.constantOr(1) === 0) return; const { isRenderingToTexture: B } = I, j = f.colorModeForRenderPass(), q = v.paint.get("fill-pattern"), G = f.opaquePassEnabledForLayer() && !q.constantOr(1) && E.constantOr(c.b6.transparent).a === 1 && A.constantOr(0) === 1 ? "opaque" : "translucent"; if (f.renderPass === G) { const H = f.getDepthModeForSublayer(1, f.renderPass === "opaque" ? yt.ReadWrite : yt.ReadOnly); xl(f, g, v, w, H, j, !1, B) } if (f.renderPass === "translucent" && v.paint.get("fill-antialias")) { const H = f.getDepthModeForSublayer(v.getPaintProperty("fill-outline-color") ? 2 : 0, yt.ReadOnly); xl(f, g, v, w, H, j, !0, B) } }(e, i, o, a, h) : c.c3(o) ? function (f, g, v, w, I) { const E = v.paint.get("fill-extrusion-opacity"); if (E === 0) return; const { isRenderingToTexture: A } = I; if (f.renderPass === "translucent") { const B = new yt(f.context.gl.LEQUAL, yt.ReadWrite, f.depthRangeFor3D); if (E !== 1 || v.paint.get("fill-extrusion-pattern").constantOr(1)) Ss(f, g, v, w, B, zt.disabled, ni.disabled, A), Ss(f, g, v, w, B, f.stencilModeFor3D(), f.colorModeForRenderPass(), A); else { const j = f.colorModeForRenderPass(); Ss(f, g, v, w, B, zt.disabled, j, A) } } }(e, i, o, a, h) : c.c4(o) ? function (f, g, v, w, I) { if (f.renderPass !== "offscreen" && f.renderPass !== "translucent") return; const { isRenderingToTexture: E } = I, A = f.context, B = f.style.projection.useSubdivision, j = f.getDepthModeForSublayer(0, yt.ReadOnly), q = f.colorModeForRenderPass(); if (f.renderPass === "offscreen") (function (G, H, K, Q, ee, re, oe) { const ne = G.context, me = ne.gl; for (const ge of K) { const Se = H.getTile(ge), Ie = Se.dem; if (!Ie || !Ie.data || !Se.needsHillshadePrepare) continue; const Pe = Ie.dim, $e = Ie.stride, Ue = Ie.getPixels(); if (ne.activeTexture.set(me.TEXTURE1), ne.pixelStoreUnpackPremultiplyAlpha.set(!1), Se.demTexture = Se.demTexture || G.getTileTexture($e), Se.demTexture) { const tt = Se.demTexture; tt.update(Ue, { premultiply: !1 }), tt.bind(me.NEAREST, me.CLAMP_TO_EDGE) } else Se.demTexture = new Nt(ne, Ue, me.RGBA, { premultiply: !1 }), Se.demTexture.bind(me.NEAREST, me.CLAMP_TO_EDGE); ne.activeTexture.set(me.TEXTURE0); let De = Se.fbo; if (!De) { const tt = new Nt(ne, { width: Pe, height: Pe, data: null }, me.RGBA); tt.bind(me.LINEAR, me.CLAMP_TO_EDGE), De = Se.fbo = ne.createFramebuffer(Pe, Pe, !0, !1), De.colorAttachment.set(tt.texture) } ne.bindFramebuffer.set(De.framebuffer), ne.viewport.set([0, 0, Pe, Pe]), G.useProgram("hillshadePrepare").draw(ne, me.TRIANGLES, ee, re, oe, Ct.disabled, Lc(Se.tileID, Ie), null, null, Q.id, G.rasterBoundsBuffer, G.quadTriangleIndexBuffer, G.rasterBoundsSegments), Se.needsHillshadePrepare = !1 } })(f, g, w, v, j, zt.disabled, q), A.viewport.set([0, 0, f.width, f.height]); else if (f.renderPass === "translucent") if (B) { const [G, H, K] = f.stencilConfigForOverlapTwoPass(w); ro(f, g, v, K, G, j, q, !1, E), ro(f, g, v, K, H, j, q, !0, E) } else { const [G, H] = f.getStencilConfigForOverlapAndUpdateStencilID(w); ro(f, g, v, H, G, j, q, !1, E) } }(e, i, o, a, h) : c.c5(o) ? function (f, g, v, w, I) { if (f.renderPass !== "translucent" || v.paint.get("raster-opacity") === 0 || !w.length) return; const { isRenderingToTexture: E } = I, A = g.getSource(), B = f.style.projection.useSubdivision; if (A instanceof qe) no(f, g, v, w, null, !1, !1, A.tileCoords, A.flippedWindingOrder, E); else if (B) { const [j, q, G] = f.stencilConfigForOverlapTwoPass(w); no(f, g, v, G, j, !1, !0, vl, !1, E), no(f, g, v, G, q, !0, !0, vl, !1, E) } else { const [j, q] = f.getStencilConfigForOverlapAndUpdateStencilID(w); no(f, g, v, q, j, !1, !0, vl, !1, E) } }(e, i, o, a, h) : c.c6(o) ? function (f, g, v, w, I) { const E = v.paint.get("background-color"), A = v.paint.get("background-opacity"); if (A === 0) return; const { isRenderingToTexture: B } = I, j = f.context, q = j.gl, G = f.style.projection, H = f.transform, K = H.tileSize, Q = v.paint.get("background-pattern"); if (f.isPatternMissing(Q)) return; const ee = !Q && E.a === 1 && A === 1 && f.opaquePassEnabledForLayer() ? "opaque" : "translucent"; if (f.renderPass !== ee) return; const re = zt.disabled, oe = f.getDepthModeForSublayer(0, ee === "opaque" ? yt.ReadWrite : yt.ReadOnly), ne = f.colorModeForRenderPass(), me = f.useProgram(Q ? "backgroundPattern" : "background"), ge = w || ue(H, { tileSize: K, terrain: f.style.map.terrain }); Q && (j.activeTexture.set(q.TEXTURE0), f.imageManager.bind(f.context)); const Se = v.getCrossfadeParameters(); for (const Ie of ge) { const Pe = H.getProjectionData({ overscaledTileID: Ie, applyGlobeMatrix: !B, applyTerrainMatrix: !0 }), $e = Q ? cl(A, f, Q, { tileID: Ie, tileSize: K }, Se) : _n(A, E), Ue = f.style.map.terrain && f.style.map.terrain.getTerrainData(Ie), De = G.getMeshFromTileID(j, Ie.canonical, !1, !0, "raster"); me.draw(j, q.TRIANGLES, oe, re, ne, Ct.backCCW, $e, Ue, Pe, v.id, De.vertexBuffer, De.indexBuffer, De.segments) } }(e, 0, o, a, h) : c.c7(o) && function (f, g, v, w) {
              const { isRenderingGlobe: I } = w, E = f.context, A = v.implementation, B = f.style.projection, j = f.transform, q = j.getProjectionDataForCustomLayer(I), G = {
                farZ: j.farZ, nearZ: j.nearZ, fov: j.fov * Math.PI / 180, modelViewProjectionMatrix: j.modelViewProjectionMatrix, projectionMatrix: j.projectionMatrix, shaderData: {
                  variantName: B.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${B.shaderPreludeCode.vertexSource}`, define: B.shaderDefine
                }, defaultProjectionData: q
              }, H = A.renderingMode ? A.renderingMode : "2d"; if (f.renderPass === "offscreen") { const K = A.prerender; K && (f.setCustomLayerDefaults(), E.setColorMode(f.colorModeForRenderPass()), K.call(A, E.gl, G), E.setDirty(), f.setBaseState()) } else if (f.renderPass === "translucent") { f.setCustomLayerDefaults(), E.setColorMode(f.colorModeForRenderPass()), E.setStencilMode(zt.disabled); const K = H === "3d" ? f.getDepthModeFor3D() : f.getDepthModeForSublayer(0, yt.ReadOnly); E.setDepthMode(K), A.render(E.gl, G), E.setDirty(), f.setBaseState(), E.bindFramebuffer.set(null) }
            }(e, 0, o, h))
          } saveTileTexture(e) { const i = this._tileTextures[e.size[0]]; i ? i.push(e) : this._tileTextures[e.size[0]] = [e] } getTileTexture(e) { const i = this._tileTextures[e]; return i && i.length > 0 ? i.pop() : null } isPatternMissing(e) { if (!e) return !1; if (!e.from || !e.to) return !0; const i = this.imageManager.getPattern(e.from.toString()), o = this.imageManager.getPattern(e.to.toString()); return !i || !o } useProgram(e, i, o = !1) { this.cache = this.cache || {}; const a = !!this.style.map.terrain, h = this.style.projection, f = e + (i ? i.cacheKey : "") + `/${o ? Co : h.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (a ? "/terrain" : ""); return this.cache[f] || (this.cache[f] = new dh(this.context, Wr[e], i, ul[e], this._showOverdrawInspector, a, o ? Wr.projectionMercator : h.shaderPreludeCode, o ? Lt : h.shaderDefine)), this.cache[f] } setCustomLayerDefaults() { this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault() } setBaseState() { const e = this.context.gl; this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD) } initDebugOverlayCanvas() { this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new Nt(this.context, this.debugOverlayCanvas, this.context.gl.RGBA)) } destroy() { this.debugOverlayTexture && this.debugOverlayTexture.destroy() } overLimit() { const { drawingBufferWidth: e, drawingBufferHeight: i } = this.context.gl; return this.width !== e || this.height !== i }
        } function Sl(u, e) { let i, o = !1, a = null, h = null; const f = () => { a = null, o && (u.apply(h, i), a = setTimeout(f, e), o = !1) }; return (...g) => (o = !0, h = this, i = g, a || f(), a) } class Cn { constructor(e) { this._getCurrentHash = () => { const i = window.location.hash.replace("#", ""); if (this._hashName) { let o; return i.split("&").map(a => a.split("=")).forEach(a => { a[0] === this._hashName && (o = a) }), (o && o[1] || "").split("/") } return i.split("/") }, this._onHashChange = () => { const i = this._getCurrentHash(); if (!this._isValidHash(i)) return !1; const o = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(i[3] || 0) : this._map.getBearing(); return this._map.jumpTo({ center: [+i[2], +i[1]], zoom: +i[0], bearing: o, pitch: +(i[4] || 0) }), !0 }, this._updateHashUnthrottled = () => { const i = window.location.href.replace(/(#.*)?$/, this.getHashString()); window.history.replaceState(window.history.state, null, i) }, this._removeHash = () => { const i = this._getCurrentHash(); if (i.length === 0) return; const o = i.join("/"); let a = o; a.split("&").length > 0 && (a = a.split("&")[0]), this._hashName && (a = `${this._hashName}=${o}`); let h = window.location.hash.replace(a, ""); h.startsWith("#&") ? h = h.slice(0, 1) + h.slice(2) : h === "#" && (h = ""); let f = window.location.href.replace(/(#.+)?$/, h); f = f.replace("&&", "&"), window.history.replaceState(window.history.state, null, f) }, this._updateHash = Sl(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e) } addTo(e) { return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this } remove() { return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this } getHashString(e) { const i = this._map.getCenter(), o = Math.round(100 * this._map.getZoom()) / 100, a = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), h = Math.pow(10, a), f = Math.round(i.lng * h) / h, g = Math.round(i.lat * h) / h, v = this._map.getBearing(), w = this._map.getPitch(); let I = ""; if (I += e ? `/${f}/${g}/${o}` : `${o}/${g}/${f}`, (v || w) && (I += "/" + Math.round(10 * v) / 10), w && (I += `/${Math.round(w)}`), this._hashName) { const E = this._hashName; let A = !1; const B = window.location.hash.slice(1).split("&").map(j => { const q = j.split("=")[0]; return q === E ? (A = !0, `${q}=${I}`) : j }).filter(j => j); return A || B.push(`${E}=${I}`), `#${B.join("&")}` } return `#${I}` } _isValidHash(e) { if (e.length < 3 || e.some(isNaN)) return !1; try { new c.Q(+e[2], +e[1]) } catch { return !1 } const i = +e[0], o = +(e[3] || 0), a = +(e[4] || 0); return i >= this._map.getMinZoom() && i <= this._map.getMaxZoom() && o >= -180 && o <= 180 && a >= this._map.getMinPitch() && a <= this._map.getMaxPitch() } } const Cs = { linearity: .3, easing: c.c8(0, 0, .3, 1) }, iu = c.e({ deceleration: 2500, maxSpeed: 1400 }, Cs), ru = c.e({ deceleration: 20, maxSpeed: 1400 }, Cs), nu = c.e({ deceleration: 1e3, maxSpeed: 360 }, Cs), su = c.e({ deceleration: 1e3, maxSpeed: 90 }, Cs), ou = c.e({ deceleration: 1e3, maxSpeed: 360 }, Cs); class au { constructor(e) { this._map = e, this.clear() } clear() { this._inertiaBuffer = [] } record(e) { this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: Le.now(), settings: e }) } _drainInertiaBuffer() { const e = this._inertiaBuffer, i = Le.now(); for (; e.length > 0 && i - e[0].time > 160;)e.shift() } _onMoveEnd(e) { if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return; const i = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new c.P(0, 0), pinchAround: void 0, around: void 0 }; for (const { settings: h } of this._inertiaBuffer) i.zoom += h.zoomDelta || 0, i.bearing += h.bearingDelta || 0, i.pitch += h.pitchDelta || 0, i.roll += h.rollDelta || 0, h.panDelta && i.pan._add(h.panDelta), h.around && (i.around = h.around), h.pinchAround && (i.pinchAround = h.pinchAround); const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a = {}; if (i.pan.mag()) { const h = Es(i.pan.mag(), o, c.e({}, iu, e || {})), f = i.pan.mult(h.amount / i.pan.mag()), g = this._map.cameraHelper.handlePanInertia(f, this._map.transform); a.center = g.easingCenter, a.offset = g.easingOffset, En(a, h) } if (i.zoom) { const h = Es(i.zoom, o, ru); a.zoom = this._map.transform.zoom + h.amount, En(a, h) } if (i.bearing) { const h = Es(i.bearing, o, nu); a.bearing = this._map.transform.bearing + c.ad(h.amount, -179, 179), En(a, h) } if (i.pitch) { const h = Es(i.pitch, o, su); a.pitch = this._map.transform.pitch + h.amount, En(a, h) } if (i.roll) { const h = Es(i.roll, o, ou); a.roll = this._map.transform.roll + c.ad(h.amount, -179, 179), En(a, h) } if (a.zoom || a.bearing) { const h = i.pinchAround === void 0 ? i.around : i.pinchAround; a.around = h ? this._map.unproject(h) : this._map.getCenter() } return this.clear(), c.e(a, { noMoveStart: !0 }) } } function En(u, e) { (!u.duration || u.duration < e.duration) && (u.duration = e.duration, u.easing = e.easing) } function Es(u, e, i) { const { maxSpeed: o, linearity: a, deceleration: h } = i, f = c.ad(u * a / (e / 1e3), -o, o), g = Math.abs(f) / (h * a); return { easing: i.easing, duration: 1e3 * g, amount: f * (g / 2) } } class di extends c.l { preventDefault() { this._defaultPrevented = !0 } get defaultPrevented() { return this._defaultPrevented } constructor(e, i, o, a = {}) { const h = ae.mousePos(i.getCanvas(), o), f = i.unproject(h); super(e, c.e({ point: h, lngLat: f, originalEvent: o }, a)), this._defaultPrevented = !1, this.target = i } } class fr extends c.l { preventDefault() { this._defaultPrevented = !0 } get defaultPrevented() { return this._defaultPrevented } constructor(e, i, o) { const a = e === "touchend" ? o.changedTouches : o.touches, h = ae.touchPos(i.getCanvasContainer(), a), f = h.map(v => i.unproject(v)), g = h.reduce((v, w, I, E) => v.add(w.div(E.length)), new c.P(0, 0)); super(e, { points: h, point: g, lngLats: f, lngLat: i.unproject(g), originalEvent: o }), this._defaultPrevented = !1 } } class Ml extends c.l { preventDefault() { this._defaultPrevented = !0 } get defaultPrevented() { return this._defaultPrevented } constructor(e, i, o) { super(e, { originalEvent: o }), this._defaultPrevented = !1 } } class un { constructor(e, i) { this._map = e, this._clickTolerance = i.clickTolerance } reset() { delete this._mousedownPos } wheel(e) { return this._firePreventable(new Ml(e.type, this._map, e)) } mousedown(e, i) { return this._mousedownPos = i, this._firePreventable(new di(e.type, this._map, e)) } mouseup(e) { this._map.fire(new di(e.type, this._map, e)) } click(e, i) { this._mousedownPos && this._mousedownPos.dist(i) >= this._clickTolerance || this._map.fire(new di(e.type, this._map, e)) } dblclick(e) { return this._firePreventable(new di(e.type, this._map, e)) } mouseover(e) { this._map.fire(new di(e.type, this._map, e)) } mouseout(e) { this._map.fire(new di(e.type, this._map, e)) } touchstart(e) { return this._firePreventable(new fr(e.type, this._map, e)) } touchmove(e) { this._map.fire(new fr(e.type, this._map, e)) } touchend(e) { this._map.fire(new fr(e.type, this._map, e)) } touchcancel(e) { this._map.fire(new fr(e.type, this._map, e)) } _firePreventable(e) { if (this._map.fire(e), e.defaultPrevented) return {} } isEnabled() { return !0 } isActive() { return !1 } enable() { } disable() { } } class As { constructor(e) { this._map = e } reset() { this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent } mousemove(e) { this._map.fire(new di(e.type, this._map, e)) } mousedown() { this._delayContextMenu = !0, this._ignoreContextMenu = !1 } mouseup() { this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new di("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent) } contextmenu(e) { this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new di(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault() } isEnabled() { return !0 } isActive() { return !1 } enable() { } disable() { } } class so { constructor(e) { this._map = e } get transform() { return this._map._requestedCameraState || this._map.transform } get center() { return { lng: this.transform.center.lng, lat: this.transform.center.lat } } get zoom() { return this.transform.zoom } get pitch() { return this.transform.pitch } get bearing() { return this.transform.bearing } unproject(e) { return this.transform.screenPointToLocation(c.P.convert(e), this._map.terrain) } } class lu { constructor(e, i) { this._map = e, this._tr = new so(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = i.clickTolerance || 1 } isEnabled() { return !!this._enabled } isActive() { return !!this._active } enable() { this.isEnabled() || (this._enabled = !0) } disable() { this.isEnabled() && (this._enabled = !1) } mousedown(e, i) { this.isEnabled() && e.shiftKey && e.button === 0 && (ae.disableDrag(), this._startPos = this._lastPos = i, this._active = !0) } mousemoveWindow(e, i) { if (!this._active) return; const o = i; if (this._lastPos.equals(o) || !this._box && o.dist(this._startPos) < this._clickTolerance) return; const a = this._startPos; this._lastPos = o, this._box || (this._box = ae.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e)); const h = Math.min(a.x, o.x), f = Math.max(a.x, o.x), g = Math.min(a.y, o.y), v = Math.max(a.y, o.y); ae.setTransform(this._box, `translate(${h}px,${g}px)`), this._box.style.width = f - h + "px", this._box.style.height = v - g + "px" } mouseupWindow(e, i) { if (!this._active || e.button !== 0) return; const o = this._startPos, a = i; if (this.reset(), ae.suppressClick(), o.x !== a.x || o.y !== a.y) return this._map.fire(new c.l("boxzoomend", { originalEvent: e })), { cameraAnimation: h => h.fitScreenCoordinates(o, a, this._tr.bearing, { linear: !0 }) }; this._fireEvent("boxzoomcancel", e) } keydown(e) { this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e)) } reset() { this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (ae.remove(this._box), this._box = null), ae.enableDrag(), delete this._startPos, delete this._lastPos } _fireEvent(e, i) { return this._map.fire(new c.l(e, { originalEvent: i })) } } function Il(u, e) { if (u.length !== e.length) throw new Error(`The number of touches and points are not equal - touches ${u.length}, points ${e.length}`); const i = {}; for (let o = 0; o < u.length; o++)i[u[o].identifier] = e[o]; return i } class Sh { constructor(e) { this.reset(), this.numTouches = e.numTouches } reset() { delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1 } touchstart(e, i, o) { (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), o.length === this.numTouches && (this.centroid = function (a) { const h = new c.P(0, 0); for (const f of a) h._add(f); return h.div(a.length) }(i), this.touches = Il(o, i))) } touchmove(e, i, o) { if (this.aborted || !this.centroid) return; const a = Il(o, i); for (const h in this.touches) { const f = a[h]; (!f || f.dist(this.touches[h]) > 30) && (this.aborted = !0) } } touchend(e, i, o) { if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), o.length === 0) { const a = !this.aborted && this.centroid; if (this.reset(), a) return a } } } class ia { constructor(e) { this.singleTap = new Sh(e), this.numTaps = e.numTaps, this.reset() } reset() { this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset() } touchstart(e, i, o) { this.singleTap.touchstart(e, i, o) } touchmove(e, i, o) { this.singleTap.touchmove(e, i, o) } touchend(e, i, o) { const a = this.singleTap.touchend(e, i, o); if (a) { const h = e.timeStamp - this.lastTime < 500, f = !this.lastTap || this.lastTap.dist(a) < 30; if (h && f || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = a, this.count === this.numTaps) return this.reset(), a } } } class oo { constructor(e) { this._tr = new so(e), this._zoomIn = new ia({ numTouches: 1, numTaps: 2 }), this._zoomOut = new ia({ numTouches: 2, numTaps: 1 }), this.reset() } reset() { this._active = !1, this._zoomIn.reset(), this._zoomOut.reset() } touchstart(e, i, o) { this._zoomIn.touchstart(e, i, o), this._zoomOut.touchstart(e, i, o) } touchmove(e, i, o) { this._zoomIn.touchmove(e, i, o), this._zoomOut.touchmove(e, i, o) } touchend(e, i, o) { const a = this._zoomIn.touchend(e, i, o), h = this._zoomOut.touchend(e, i, o), f = this._tr; return a ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: g => g.easeTo({ duration: 300, zoom: f.zoom + 1, around: f.unproject(a) }, { originalEvent: e }) }) : h ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: g => g.easeTo({ duration: 300, zoom: f.zoom - 1, around: f.unproject(h) }, { originalEvent: e }) }) : void 0 } touchcancel() { this.reset() } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } class wr { constructor(e) { this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset() } reset(e) { this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e) } _move(...e) { const i = this._moveFunction(...e); if (i.bearingDelta || i.pitchDelta || i.rollDelta || i.around || i.panDelta) return this._active = !0, i } dragStart(e, i) { this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(i) ? i[0] : i, this._activateOnStart && this._lastPoint && (this._active = !0)) } dragMove(e, i) { if (!this.isEnabled()) return; const o = this._lastPoint; if (!o) return; if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e); const a = Array.isArray(i) ? i[0] : i; return !this._moved && a.dist(o) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = a, this._move(o, a)) } dragEnd(e) { this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && ae.suppressClick(), this.reset(e)) } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } getClickTolerance() { return this._clickTolerance } } const Je = { 0: 1, 2: 2 }; class zs { constructor(e) { this._correctEvent = e.checkCorrectEvent } startMove(e) { const i = ae.mouseButton(e); this._eventButton = i } endMove(e) { delete this._eventButton } isValidStartEvent(e) { return this._correctEvent(e) } isValidMoveEvent(e) { return !function (i, o) { const a = Je[o]; return i.buttons === void 0 || (i.buttons & a) !== a }(e, this._eventButton) } isValidEndEvent(e) { return ae.mouseButton(e) === this._eventButton } } class Cl { constructor() { this._firstTouch = void 0 } _isOneFingerTouch(e) { return e.targetTouches.length === 1 } _isSameTouchEvent(e) { return e.targetTouches[0].identifier === this._firstTouch } startMove(e) { this._firstTouch = e.targetTouches[0].identifier } endMove(e) { delete this._firstTouch } isValidStartEvent(e) { return this._isOneFingerTouch(e) } isValidMoveEvent(e) { return this._isOneFingerTouch(e) && this._isSameTouchEvent(e) } isValidEndEvent(e) { return this._isOneFingerTouch(e) && this._isSameTouchEvent(e) } } class cu { constructor(e = new zs({ checkCorrectEvent: () => !0 }), i = new Cl) { this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = i } _executeRelevantHandler(e, i, o) { return e instanceof MouseEvent ? i(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? o(e) : void 0 } startMove(e) { this._executeRelevantHandler(e, i => this.mouseMoveStateManager.startMove(i), i => this.oneFingerTouchMoveStateManager.startMove(i)) } endMove(e) { this._executeRelevantHandler(e, i => this.mouseMoveStateManager.endMove(i), i => this.oneFingerTouchMoveStateManager.endMove(i)) } isValidStartEvent(e) { return this._executeRelevantHandler(e, i => this.mouseMoveStateManager.isValidStartEvent(i), i => this.oneFingerTouchMoveStateManager.isValidStartEvent(i)) } isValidMoveEvent(e) { return this._executeRelevantHandler(e, i => this.mouseMoveStateManager.isValidMoveEvent(i), i => this.oneFingerTouchMoveStateManager.isValidMoveEvent(i)) } isValidEndEvent(e) { return this._executeRelevantHandler(e, i => this.mouseMoveStateManager.isValidEndEvent(i), i => this.oneFingerTouchMoveStateManager.isValidEndEvent(i)) } } const An = u => { u.mousedown = u.dragStart, u.mousemoveWindow = u.dragMove, u.mouseup = u.dragEnd, u.contextmenu = e => { e.preventDefault() } }; class ao { constructor(e, i) { this._clickTolerance = e.clickTolerance || 1, this._map = i, this.reset() } reset() { this._active = !1, this._touches = {}, this._sum = new c.P(0, 0) } _shouldBePrevented(e) { return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1) } touchstart(e, i, o) { return this._calculateTransform(e, i, o) } touchmove(e, i, o) { if (this._active) { if (!this._shouldBePrevented(o.length)) return e.preventDefault(), this._calculateTransform(e, i, o); this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e) } } touchend(e, i, o) { this._calculateTransform(e, i, o), this._active && this._shouldBePrevented(o.length) && this.reset() } touchcancel() { this.reset() } _calculateTransform(e, i, o) { o.length > 0 && (this._active = !0); const a = Il(o, i), h = new c.P(0, 0), f = new c.P(0, 0); let g = 0; for (const w in a) { const I = a[w], E = this._touches[w]; E && (h._add(I), f._add(I.sub(E)), g++, a[w] = I) } if (this._touches = a, this._shouldBePrevented(g) || !f.mag()) return; const v = f.div(g); return this._sum._add(v), this._sum.mag() < this._clickTolerance ? void 0 : { around: h.div(g), panDelta: v } } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } class ra { constructor() { this.reset() } reset() { this._active = !1, delete this._firstTwoTouches } touchstart(e, i, o) { this._firstTwoTouches || o.length < 2 || (this._firstTwoTouches = [o[0].identifier, o[1].identifier], this._start([i[0], i[1]])) } touchmove(e, i, o) { if (!this._firstTwoTouches) return; e.preventDefault(); const [a, h] = this._firstTwoTouches, f = wt(o, i, a), g = wt(o, i, h); if (!f || !g) return; const v = this._aroundCenter ? null : f.add(g).div(2); return this._move([f, g], v, e) } touchend(e, i, o) { if (!this._firstTwoTouches) return; const [a, h] = this._firstTwoTouches, f = wt(o, i, a), g = wt(o, i, h); f && g || (this._active && ae.suppressClick(), this.reset()) } touchcancel() { this.reset() } enable(e) { this._enabled = !0, this._aroundCenter = !!e && e.around === "center" } disable() { this._enabled = !1, this.reset() } isEnabled() { return !!this._enabled } isActive() { return !!this._active } } function wt(u, e, i) { for (let o = 0; o < u.length; o++)if (u[o].identifier === i) return e[o] } function na(u, e) { return Math.log(u / e) / Math.LN2 } class uu extends ra { reset() { super.reset(), delete this._distance, delete this._startDistance } _start(e) { this._startDistance = this._distance = e[0].dist(e[1]) } _move(e, i) { const o = this._distance; if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(na(this._distance, this._startDistance)) < .1)) return this._active = !0, { zoomDelta: na(this._distance, o), pinchAround: i } } } function sa(u, e) { return 180 * u.angleWith(e) / Math.PI } class hu extends ra { reset() { super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector } _start(e) { this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]) } _move(e, i, o) { const a = this._vector; if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: sa(this._vector, a), pinchAround: i } } _isBelowThreshold(e) { this._minDiameter = Math.min(this._minDiameter, e.mag()); const i = 25 / (Math.PI * this._minDiameter) * 360, o = sa(e, this._startVector); return Math.abs(o) < i } } function El(u) { return Math.abs(u.y) > Math.abs(u.x) } class Al extends ra { constructor(e) { super(), this._currentTouchCount = 0, this._map = e } reset() { super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints } touchstart(e, i, o) { super.touchstart(e, i, o), this._currentTouchCount = o.length } _start(e) { this._lastPoints = e, El(e[0].sub(e[1])) && (this._valid = !1) } _move(e, i, o) { if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return; const a = e[0].sub(this._lastPoints[0]), h = e[1].sub(this._lastPoints[1]); return this._valid = this.gestureBeginsVertically(a, h, o.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, { pitchDelta: (a.y + h.y) / 2 * -.5 }) : void 0 } gestureBeginsVertically(e, i, o) { if (this._valid !== void 0) return this._valid; const a = e.mag() >= 2, h = i.mag() >= 2; if (!a && !h) return; if (!a || !h) return this._firstMove === void 0 && (this._firstMove = o), o - this._firstMove < 100 && void 0; const f = e.y > 0 == i.y > 0; return El(e) && El(i) && f } } const zl = { panStep: 100, bearingStep: 15, pitchStep: 10 }; class kl { constructor(e) { this._tr = new so(e); const i = zl; this._panStep = i.panStep, this._bearingStep = i.bearingStep, this._pitchStep = i.pitchStep, this._rotationDisabled = !1 } reset() { this._active = !1 } keydown(e) { if (e.altKey || e.ctrlKey || e.metaKey) return; let i = 0, o = 0, a = 0, h = 0, f = 0; switch (e.keyCode) { case 61: case 107: case 171: case 187: i = 1; break; case 189: case 109: case 173: i = -1; break; case 37: e.shiftKey ? o = -1 : (e.preventDefault(), h = -1); break; case 39: e.shiftKey ? o = 1 : (e.preventDefault(), h = 1); break; case 38: e.shiftKey ? a = 1 : (e.preventDefault(), f = -1); break; case 40: e.shiftKey ? a = -1 : (e.preventDefault(), f = 1); break; default: return }return this._rotationDisabled && (o = 0, a = 0), { cameraAnimation: g => { const v = this._tr; g.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Mh, zoom: i ? Math.round(v.zoom) + i * (e.shiftKey ? 2 : 1) : v.zoom, bearing: v.bearing + o * this._bearingStep, pitch: v.pitch + a * this._pitchStep, offset: [-h * this._panStep, -f * this._panStep], center: v.center }, { originalEvent: e }) } } } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } disableRotation() { this._rotationDisabled = !0 } enableRotation() { this._rotationDisabled = !1 } } function Mh(u) { return u * (2 - u) } const Dl = 4.000244140625; class du { constructor(e, i) { this._onTimeout = o => { this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(o) }, this._map = e, this._tr = new so(e), this._triggerRenderFrame = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222 } setZoomRate(e) { this._defaultZoomRate = e } setWheelZoomRate(e) { this._wheelZoomRate = e } isEnabled() { return !!this._enabled } isActive() { return !!this._active || this._finishTimeout !== void 0 } isZooming() { return !!this._zooming } enable(e) { this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center") } disable() { this.isEnabled() && (this._enabled = !1) } _shouldBePrevented(e) { return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e)) } wheel(e) { if (!this.isEnabled()) return; if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e); let i = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY; const o = Le.now(), a = o - (this._lastWheelEventTime || 0); this._lastWheelEventTime = o, i !== 0 && i % Dl == 0 ? this._type = "wheel" : i !== 0 && Math.abs(i) < 4 ? this._type = "trackpad" : a > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(a * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), e.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = e, this._delta -= i, this._active || this._start(e)), e.preventDefault() } _start(e) { if (!this._delta) return; this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout); const i = ae.mousePos(this._map.getCanvas(), e), o = this._tr; this._aroundPoint = this._aroundCenter ? o.transform.locationToScreenPoint(c.Q.convert(o.center)) : i, this._frameId || (this._frameId = !0, this._triggerRenderFrame()) } renderFrame() { if (!this._frameId || (this._frameId = null, !this.isActive())) return; const e = this._tr.transform; if (typeof this._lastExpectedZoom == "number") { const g = e.zoom - this._lastExpectedZoom; typeof this._startZoom == "number" && (this._startZoom += g), typeof this._targetZoom == "number" && (this._targetZoom += g) } if (this._delta !== 0) { const g = this._type === "wheel" && Math.abs(this._delta) > Dl ? this._wheelZoomRate : this._defaultZoomRate; let v = 2 / (1 + Math.exp(-Math.abs(this._delta * g))); this._delta < 0 && v !== 0 && (v = 1 / v); const w = typeof this._targetZoom != "number" ? e.scale : c.aH(this._targetZoom); this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, c.aa(w * v))), this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0 } const i = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom, o = this._startZoom, a = this._easing; let h, f = !1; if (this._type === "wheel" && o && a) { const g = Le.now() - this._lastWheelEventTime, v = Math.min((g + 5) / 200, 1), w = a(v); h = c.B.number(o, i, w), v < 1 ? this._frameId || (this._frameId = !0) : f = !0 } else h = i, f = !0; return this._active = !0, f && (this._active = !1, this._finishTimeout = setTimeout(() => { this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout }, 200)), this._lastExpectedZoom = h, { noInertia: !0, needsRenderFrame: !f, zoomDelta: h - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent } } _smoothOutEasing(e) { let i = c.ca; if (this._prevEase) { const o = this._prevEase, a = (Le.now() - o.start) / o.duration, h = o.easing(a + .01) - o.easing(a), f = .27 / Math.sqrt(h * h + 1e-4) * .01, g = Math.sqrt(.0729 - f * f); i = c.c8(f, g, .25, 1) } return this._prevEase = { start: Le.now(), duration: e, easing: i }, i } reset() { this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout) } } class pu { constructor(e, i) { this._clickZoom = e, this._tapZoom = i } enable() { this._clickZoom.enable(), this._tapZoom.enable() } disable() { this._clickZoom.disable(), this._tapZoom.disable() } isEnabled() { return this._clickZoom.isEnabled() && this._tapZoom.isEnabled() } isActive() { return this._clickZoom.isActive() || this._tapZoom.isActive() } } class zn { constructor(e) { this._tr = new so(e), this.reset() } reset() { this._active = !1 } dblclick(e, i) { return e.preventDefault(), { cameraAnimation: o => { o.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(i) }, { originalEvent: e }) } } } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } class si { constructor() { this._tap = new ia({ numTouches: 1, numTaps: 1 }), this.reset() } reset() { this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset() } touchstart(e, i, o) { if (!this._swipePoint) if (this._tapTime) { const a = i[0], h = e.timeStamp - this._tapTime < 500, f = this._tapPoint.dist(a) < 30; h && f ? o.length > 0 && (this._swipePoint = a, this._swipeTouch = o[0].identifier) : this.reset() } else this._tap.touchstart(e, i, o) } touchmove(e, i, o) { if (this._tapTime) { if (this._swipePoint) { if (o[0].identifier !== this._swipeTouch) return; const a = i[0], h = a.y - this._swipePoint.y; return this._swipePoint = a, e.preventDefault(), this._active = !0, { zoomDelta: h / 128 } } } else this._tap.touchmove(e, i, o) } touchend(e, i, o) { if (this._tapTime) this._swipePoint && o.length === 0 && this.reset(); else { const a = this._tap.touchend(e, i, o); a && (this._tapTime = e.timeStamp, this._tapPoint = a) } } touchcancel() { this.reset() } enable() { this._enabled = !0 } disable() { this._enabled = !1, this.reset() } isEnabled() { return this._enabled } isActive() { return this._active } } class lo { constructor(e, i, o) { this._el = e, this._mousePan = i, this._touchPan = o } enable(e) { this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan") } disable() { this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan") } isEnabled() { return this._mousePan.isEnabled() && this._touchPan.isEnabled() } isActive() { return this._mousePan.isActive() || this._touchPan.isActive() } } class oa { constructor(e, i, o, a) { this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = i, this._mousePitch = o, this._mouseRoll = a } enable() { this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable() } disable() { this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable() } isEnabled() { return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled()) } isActive() { return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive() } } class Rl { constructor(e, i, o, a) { this._el = e, this._touchZoom = i, this._touchRotate = o, this._tapDragZoom = a, this._rotationDisabled = !1, this._enabled = !0 } enable(e) { this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate") } disable() { this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate") } isEnabled() { return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled() } isActive() { return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive() } disableRotation() { this._rotationDisabled = !0, this._touchRotate.disable() } enableRotation() { this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable() } } class Ll { constructor(e, i) { this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = e, this._options = i, this._enabled = !1 } isActive() { return !1 } reset() { } _setupUI() { if (this._container) return; const e = this._map.getCanvasContainer(); e.classList.add("maplibregl-cooperative-gestures"), this._container = ae.create("div", "maplibregl-cooperative-gesture-screen", e); let i = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText"); this._bypassKey === "metaKey" && (i = this._map._getUIString("CooperativeGesturesHandler.MacHelpText")); const o = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), a = document.createElement("div"); a.className = "maplibregl-desktop-message", a.textContent = i, this._container.appendChild(a); const h = document.createElement("div"); h.className = "maplibregl-mobile-message", h.textContent = o, this._container.appendChild(h), this._container.setAttribute("aria-hidden", "true") } _destroyUI() { this._container && (ae.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container } enable() { this._setupUI(), this._enabled = !0 } disable() { this._enabled = !1, this._destroyUI() } isEnabled() { return this._enabled } isBypassed(e) { return e[this._bypassKey] } notifyGestureBlocked(e, i) { this._enabled && (this._map.fire(new c.l("cooperativegestureprevented", { gestureType: e, originalEvent: i })), this._container.classList.add("maplibregl-show"), setTimeout(() => { this._container.classList.remove("maplibregl-show") }, 100)) } } const co = u => u.zoom || u.drag || u.roll || u.pitch || u.rotate; class Ih extends c.l { } function Zr(u) { return u.panDelta && u.panDelta.mag() || u.zoomDelta || u.bearingDelta || u.pitchDelta || u.rollDelta } class aa { constructor(e, i) { this.handleWindowEvent = a => { this.handleEvent(a, `${a.type}Window`) }, this.handleEvent = (a, h) => { if (a.type === "blur") return void this.stop(!0); this._updatingCamera = !0; const f = a.type === "renderFrame" ? void 0 : a, g = { needsRenderFrame: !1 }, v = {}, w = {}, I = a.touches, E = I ? this._getMapTouches(I) : void 0, A = E ? ae.touchPos(this._map.getCanvas(), E) : ae.mousePos(this._map.getCanvas(), a); for (const { handlerName: q, handler: G, allowed: H } of this._handlers) { if (!G.isEnabled()) continue; let K; this._blockedByActive(w, H, q) ? G.reset() : G[h || a.type] && (K = G[h || a.type](a, A, E), this.mergeHandlerResult(g, v, K, q, f), K && K.needsRenderFrame && this._triggerRenderFrame()), (K || G.isActive()) && (w[q] = G) } const B = {}; for (const q in this._previousActiveHandlers) w[q] || (B[q] = f); this._previousActiveHandlers = w, (Object.keys(B).length || Zr(g)) && (this._changes.push([g, v, B]), this._triggerRenderFrame()), (Object.keys(w).length || Zr(g)) && this._map._stop(!0), this._updatingCamera = !1; const { cameraAnimation: j } = g; j && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], j(this._map)) }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new au(e), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i); const o = this._el; this._listeners = [[o, "touchstart", { passive: !0 }], [o, "touchmove", { passive: !1 }], [o, "touchend", void 0], [o, "touchcancel", void 0], [o, "mousedown", void 0], [o, "mousemove", void 0], [o, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [o, "mouseover", void 0], [o, "mouseout", void 0], [o, "dblclick", void 0], [o, "click", void 0], [o, "keydown", { capture: !1 }], [o, "keyup", void 0], [o, "wheel", { passive: !1 }], [o, "contextmenu", void 0], [window, "blur", void 0]]; for (const [a, h, f] of this._listeners) ae.addEventListener(a, h, a === document ? this.handleWindowEvent : this.handleEvent, f) } destroy() { for (const [e, i, o] of this._listeners) ae.removeEventListener(e, i, e === document ? this.handleWindowEvent : this.handleEvent, o) } _addDefaultHandlers(e) { const i = this._map, o = i.getCanvasContainer(); this._add("mapEvent", new un(i, e)); const a = i.boxZoom = new lu(i, e); this._add("boxZoom", a), e.interactive && e.boxZoom && a.enable(); const h = i.cooperativeGestures = new Ll(i, e.cooperativeGestures); this._add("cooperativeGestures", h), e.cooperativeGestures && h.enable(); const f = new oo(i), g = new zn(i); i.doubleClickZoom = new pu(g, f), this._add("tapZoom", f), this._add("clickZoom", g), e.interactive && e.doubleClickZoom && i.doubleClickZoom.enable(); const v = new si; this._add("tapDragZoom", v); const w = i.touchPitch = new Al(i); this._add("touchPitch", w), e.interactive && e.touchPitch && i.touchPitch.enable(e.touchPitch); const I = () => i.project(i.getCenter()), E = function ({ enable: ee, clickTolerance: re, aroundCenter: oe = !0, minPixelCenterThreshold: ne = 100, rotateDegreesPerPixelMoved: me = .8 }, ge) { const Se = new zs({ checkCorrectEvent: Ie => ae.mouseButton(Ie) === 0 && Ie.ctrlKey || ae.mouseButton(Ie) === 2 && !Ie.ctrlKey }); return new wr({ clickTolerance: re, move: (Ie, Pe) => { const $e = ge(); if (oe && Math.abs($e.y - Ie.y) > ne) return { bearingDelta: c.c9(new c.P(Ie.x, Pe.y), Pe, $e) }; let Ue = (Pe.x - Ie.x) * me; return oe && Pe.y < $e.y && (Ue = -Ue), { bearingDelta: Ue } }, moveStateManager: Se, enable: ee, assignEvents: An }) }(e, I), A = function ({ enable: ee, clickTolerance: re, pitchDegreesPerPixelMoved: oe = -.5 }) { const ne = new zs({ checkCorrectEvent: me => ae.mouseButton(me) === 0 && me.ctrlKey || ae.mouseButton(me) === 2 }); return new wr({ clickTolerance: re, move: (me, ge) => ({ pitchDelta: (ge.y - me.y) * oe }), moveStateManager: ne, enable: ee, assignEvents: An }) }(e), B = function ({ enable: ee, clickTolerance: re, rollDegreesPerPixelMoved: oe = .3 }, ne) { const me = new zs({ checkCorrectEvent: ge => ae.mouseButton(ge) === 2 && ge.ctrlKey }); return new wr({ clickTolerance: re, move: (ge, Se) => { const Ie = ne(); let Pe = (Se.x - ge.x) * oe; return Se.y < Ie.y && (Pe = -Pe), { rollDelta: Pe } }, moveStateManager: me, enable: ee, assignEvents: An }) }(e, I); i.dragRotate = new oa(e, E, A, B), this._add("mouseRotate", E, ["mousePitch"]), this._add("mousePitch", A, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", B, ["mousePitch"]), e.interactive && e.dragRotate && i.dragRotate.enable(); const j = function ({ enable: ee, clickTolerance: re }) { const oe = new zs({ checkCorrectEvent: ne => ae.mouseButton(ne) === 0 && !ne.ctrlKey }); return new wr({ clickTolerance: re, move: (ne, me) => ({ around: me, panDelta: me.sub(ne) }), activateOnStart: !0, moveStateManager: oe, enable: ee, assignEvents: An }) }(e), q = new ao(e, i); i.dragPan = new lo(o, j, q), this._add("mousePan", j), this._add("touchPan", q, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && i.dragPan.enable(e.dragPan); const G = new hu, H = new uu; i.touchZoomRotate = new Rl(o, H, G, v), this._add("touchRotate", G, ["touchPan", "touchZoom"]), this._add("touchZoom", H, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && i.touchZoomRotate.enable(e.touchZoomRotate); const K = i.scrollZoom = new du(i, () => this._triggerRenderFrame()); this._add("scrollZoom", K, ["mousePan"]), e.interactive && e.scrollZoom && i.scrollZoom.enable(e.scrollZoom); const Q = i.keyboard = new kl(i); this._add("keyboard", Q), e.interactive && e.keyboard && i.keyboard.enable(), this._add("blockableMapEvent", new As(i)) } _add(e, i, o) { this._handlers.push({ handlerName: e, handler: i, allowed: o }), this._handlersById[e] = i } stop(e) { if (!this._updatingCamera) { for (const { handler: i } of this._handlers) i.reset(); this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [] } } isActive() { for (const { handler: e } of this._handlers) if (e.isActive()) return !0; return !1 } isZooming() { return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming() } isRotating() { return !!this._eventsInProgress.rotate } isMoving() { return !!co(this._eventsInProgress) || this.isZooming() } _blockedByActive(e, i, o) { for (const a in e) if (a !== o && (!i || i.indexOf(a) < 0)) return !0; return !1 } _getMapTouches(e) { const i = []; for (const o of e) this._el.contains(o.target) && i.push(o); return i } mergeHandlerResult(e, i, o, a, h) { if (!o) return; c.e(e, o); const f = { handlerName: a, originalEvent: o.originalEvent || h }; o.zoomDelta !== void 0 && (i.zoom = f), o.panDelta !== void 0 && (i.drag = f), o.rollDelta !== void 0 && (i.roll = f), o.pitchDelta !== void 0 && (i.pitch = f), o.bearingDelta !== void 0 && (i.rotate = f) } _applyChanges() { const e = {}, i = {}, o = {}; for (const [a, h, f] of this._changes) a.panDelta && (e.panDelta = (e.panDelta || new c.P(0, 0))._add(a.panDelta)), a.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + a.zoomDelta), a.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + a.bearingDelta), a.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + a.pitchDelta), a.rollDelta && (e.rollDelta = (e.rollDelta || 0) + a.rollDelta), a.around !== void 0 && (e.around = a.around), a.pinchAround !== void 0 && (e.pinchAround = a.pinchAround), a.noInertia && (e.noInertia = a.noInertia), c.e(i, h), c.e(o, f); this._updateMapTransform(e, i, o), this._changes = [] } _updateMapTransform(e, i, o) { const a = this._map, h = a._getTransformForUpdate(), f = a.terrain; if (!(Zr(e) || f && this._terrainMovement)) return this._fireEvents(i, o, !0); a._stop(!0); let { panDelta: g, zoomDelta: v, bearingDelta: w, pitchDelta: I, rollDelta: E, around: A, pinchAround: B } = e; B !== void 0 && (A = B), A = A || a.transform.centerPoint, f && !h.isPointOnMapSurface(A) && (A = h.centerPoint); const j = { panDelta: g, zoomDelta: v, rollDelta: E, pitchDelta: I, bearingDelta: w, around: A }; this._map.cameraHelper.useGlobeControls && !h.isPointOnMapSurface(A) && (A = h.centerPoint); const q = A.distSqr(h.centerPoint) < .01 ? h.center : h.screenPointToLocation(g ? A.sub(g) : A); f ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(j, h), this._terrainMovement || !i.drag && !i.zoom ? i.drag && this._terrainMovement ? h.setCenter(h.screenPointToLocation(h.centerPoint.sub(g))) : this._map.cameraHelper.handleMapControlsPan(j, h, q) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(j, h, q))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(j, h), this._map.cameraHelper.handleMapControlsPan(j, h, q)), a._applyUpdatedTransform(h), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(i, o, !0) } _fireEvents(e, i, o) { const a = co(this._eventsInProgress), h = co(e), f = {}; for (const E in e) { const { originalEvent: A } = e[E]; this._eventsInProgress[E] || (f[`${E}start`] = A), this._eventsInProgress[E] = e[E] } !a && h && this._fireEvent("movestart", h.originalEvent); for (const E in f) this._fireEvent(E, f[E]); h && this._fireEvent("move", h.originalEvent); for (const E in e) { const { originalEvent: A } = e[E]; this._fireEvent(E, A) } const g = {}; let v; for (const E in this._eventsInProgress) { const { handlerName: A, originalEvent: B } = this._eventsInProgress[E]; this._handlersById[A].isActive() || (delete this._eventsInProgress[E], v = i[A] || B, g[`${E}end`] = v) } for (const E in g) this._fireEvent(E, g[E]); const w = co(this._eventsInProgress), I = (a || h) && !w; if (I && this._terrainMovement) { this._map._elevationFreeze = !1, this._terrainMovement = !1; const E = this._map._getTransformForUpdate(); this._map.getCenterClampedToGround() && E.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(E) } if (o && I) { this._updatingCamera = !0; const E = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), A = B => B !== 0 && -this._bearingSnap < B && B < this._bearingSnap; !E || !E.essential && Le.prefersReducedMotion ? (this._map.fire(new c.l("moveend", { originalEvent: v })), A(this._map.getBearing()) && this._map.resetNorth()) : (A(E.bearing || this._map.getBearing()) && (E.bearing = 0), E.freezeElevation = !0, this._map.easeTo(E, { originalEvent: v })), this._updatingCamera = !1 } } _fireEvent(e, i) { this._map.fire(new c.l(e, i ? { originalEvent: i } : {})) } _requestFrame() { return this._map.triggerRepaint(), this._map._renderTaskQueue.add(e => { delete this._frameId, this.handleEvent(new Ih("renderFrame", { timeStamp: e })), this._applyChanges() }) } _triggerRenderFrame() { this._frameId === void 0 && (this._frameId = this._requestFrame()) } } class nt extends c.E { constructor(e, i, o) { super(), this._renderFrameCallback = () => { const a = Math.min((Le.now() - this._easeStart) / this._easeOptions.duration, 1); this._onEaseFrame(this._easeOptions.easing(a)), a < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop() }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = o.bearingSnap, this.cameraHelper = i, this.on("moveend", () => { delete this._requestedCameraState }) } migrateProjection(e, i) { e.apply(this.transform), this.transform = e, this.cameraHelper = i } getCenter() { return new c.Q(this.transform.center.lng, this.transform.center.lat) } setCenter(e, i) { return this.jumpTo({ center: e }, i) } getCenterElevation() { return this.transform.elevation } setCenterElevation(e, i) { return this.jumpTo({ elevation: e }, i), this } getCenterClampedToGround() { return this._centerClampedToGround } setCenterClampedToGround(e) { this._centerClampedToGround = e } panBy(e, i, o) { return e = c.P.convert(e).mult(-1), this.panTo(this.transform.center, c.e({ offset: e }, i), o) } panTo(e, i, o) { return this.easeTo(c.e({ center: e }, i), o) } getZoom() { return this.transform.zoom } setZoom(e, i) { return this.jumpTo({ zoom: e }, i), this } zoomTo(e, i, o) { return this.easeTo(c.e({ zoom: e }, i), o) } zoomIn(e, i) { return this.zoomTo(this.getZoom() + 1, e, i), this } zoomOut(e, i) { return this.zoomTo(this.getZoom() - 1, e, i), this } getVerticalFieldOfView() { return this.transform.fov } setVerticalFieldOfView(e, i) { return e != this.transform.fov && (this.transform.setFov(e), this.fire(new c.l("movestart", i)).fire(new c.l("move", i)).fire(new c.l("moveend", i))), this } getBearing() { return this.transform.bearing } setBearing(e, i) { return this.jumpTo({ bearing: e }, i), this } getPadding() { return this.transform.padding } setPadding(e, i) { return this.jumpTo({ padding: e }, i), this } rotateTo(e, i, o) { return this.easeTo(c.e({ bearing: e }, i), o) } resetNorth(e, i) { return this.rotateTo(0, c.e({ duration: 1e3 }, e), i), this } resetNorthPitch(e, i) { return this.easeTo(c.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), i), this } snapToNorth(e, i) { return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, i) : this } getPitch() { return this.transform.pitch } setPitch(e, i) { return this.jumpTo({ pitch: e }, i), this } getRoll() { return this.transform.roll } setRoll(e, i) { return this.jumpTo({ roll: e }, i), this } cameraForBounds(e, i) { e = we.convert(e).adjustAntiMeridian(); const o = i && i.bearing || 0; return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), o, i) } _cameraForBoxAndBearing(e, i, o, a) { const h = { top: 0, bottom: 0, right: 0, left: 0 }; if (typeof (a = c.e({ padding: h, offset: [0, 0], maxZoom: this.transform.maxZoom }, a)).padding == "number") { const w = a.padding; a.padding = { top: w, bottom: w, right: w, left: w } } const f = c.e(h, a.padding); a.padding = f; const g = this.transform, v = new we(e, i); return this.cameraHelper.cameraForBoxAndBearing(a, f, v, o, g) } fitBounds(e, i, o) { return this._fitInternal(this.cameraForBounds(e, i), i, o) } fitScreenCoordinates(e, i, o, a, h) { return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(c.P.convert(e)), this.transform.screenPointToLocation(c.P.convert(i)), o, a), a, h) } _fitInternal(e, i, o) { return e ? (delete (i = c.e(e, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this } jumpTo(e, i) { this.stop(); const o = this._getTransformForUpdate(); let a = !1, h = !1, f = !1; const g = o.zoom; this.cameraHelper.handleJumpToCenterZoom(o, e); const v = o.zoom !== g; return "elevation" in e && o.elevation !== +e.elevation && o.setElevation(+e.elevation), "bearing" in e && o.bearing !== +e.bearing && (a = !0, o.setBearing(+e.bearing)), "pitch" in e && o.pitch !== +e.pitch && (h = !0, o.setPitch(+e.pitch)), "roll" in e && o.roll !== +e.roll && (f = !0, o.setRoll(+e.roll)), e.padding == null || o.isPaddingEqual(e.padding) || o.setPadding(e.padding), this._applyUpdatedTransform(o), this.fire(new c.l("movestart", i)).fire(new c.l("move", i)), v && this.fire(new c.l("zoomstart", i)).fire(new c.l("zoom", i)).fire(new c.l("zoomend", i)), a && this.fire(new c.l("rotatestart", i)).fire(new c.l("rotate", i)).fire(new c.l("rotateend", i)), h && this.fire(new c.l("pitchstart", i)).fire(new c.l("pitch", i)).fire(new c.l("pitchend", i)), f && this.fire(new c.l("rollstart", i)).fire(new c.l("roll", i)).fire(new c.l("rollend", i)), this.fire(new c.l("moveend", i)) } calculateCameraOptionsFromTo(e, i, o, a = 0) { const h = c.$.fromLngLat(e, i), f = c.$.fromLngLat(o, a), g = f.x - h.x, v = f.y - h.y, w = f.z - h.z, I = Math.hypot(g, v, w); if (I === 0) throw new Error("Can't calculate camera options with same From and To"); const E = Math.hypot(g, v), A = c.aa(this.transform.cameraToCenterDistance / I / this.transform.tileSize), B = 180 * Math.atan2(g, -v) / Math.PI; let j = 180 * Math.acos(E / I) / Math.PI; return j = w < 0 ? 90 - j : 90 + j, { center: f.toLngLat(), elevation: a, zoom: A, pitch: j, bearing: B } } calculateCameraOptionsFromCameraLngLatAltRotation(e, i, o, a, h) { const f = this.transform.calculateCenterFromCameraLngLatAlt(e, i, o, a); return { center: f.center, elevation: f.elevation, zoom: f.zoom, bearing: o, pitch: a, roll: h } } easeTo(e, i) { this._stop(!1, e.easeId), ((e = c.e({ offset: [0, 0], duration: 500, easing: c.ca }, e)).animate === !1 || !e.essential && Le.prefersReducedMotion) && (e.duration = 0); const o = this._getTransformForUpdate(), a = this.getBearing(), h = o.pitch, f = o.roll, g = "bearing" in e ? this._normalizeBearing(e.bearing, a) : a, v = "pitch" in e ? +e.pitch : h, w = "roll" in e ? this._normalizeBearing(e.roll, f) : f, I = "padding" in e ? e.padding : o.padding, E = c.P.convert(e.offset); let A, B; e.around && (A = c.Q.convert(e.around), B = o.locationToScreenPoint(A)); const j = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, q = this.cameraHelper.handleEaseTo(o, { bearing: g, pitch: v, roll: w, padding: I, around: A, aroundPoint: B, offsetAsPoint: E, offset: e.offset, zoom: e.zoom, center: e.center }); return this._rotating = this._rotating || a !== g, this._pitching = this._pitching || v !== h, this._rolling = this._rolling || w !== f, this._padding = !o.isPaddingEqual(I), this._zooming = this._zooming || q.isZooming, this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, j), this.terrain && this._prepareElevation(q.elevationCenter), this._ease(G => { q.easeFunc(G), this.terrain && !e.freezeElevation && this._updateElevation(G), this._applyUpdatedTransform(o), this._fireMoveEvents(i) }, G => { this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i, G) }, e), this } _prepareEase(e, i, o = {}) { this._moving = !0, i || o.moving || this.fire(new c.l("movestart", e)), this._zooming && !o.zooming && this.fire(new c.l("zoomstart", e)), this._rotating && !o.rotating && this.fire(new c.l("rotatestart", e)), this._pitching && !o.pitching && this.fire(new c.l("pitchstart", e)), this._rolling && !o.rolling && this.fire(new c.l("rollstart", e)) } _prepareElevation(e) { this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0 } _updateElevation(e) { this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom)); const i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom); if (e < 1 && i !== this._elevationTarget) { const o = this._elevationTarget - this._elevationStart; this._elevationStart += e * (o - (i - (o * e + this._elevationStart)) / (1 - e)), this._elevationTarget = i } this.transform.setElevation(c.B.number(this._elevationStart, this._elevationTarget, e)) } _finalizeElevation() { this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain) } _getTransformForUpdate() { return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform } _elevateCameraIfInsideTerrain(e) { if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {}; const i = e.getCameraLngLat(), o = e.getCameraAltitude(), a = this.terrain ? this.terrain.getElevationForLngLatZoom(i, e.zoom) : 0; if (o < a) { const h = this.calculateCameraOptionsFromTo(i, a, e.center, e.elevation); return { pitch: h.pitch, zoom: h.zoom } } return {} } _applyUpdatedTransform(e) { const i = []; if (i.push(a => this._elevateCameraIfInsideTerrain(a)), this.transformCameraUpdate && i.push(a => this.transformCameraUpdate(a)), !i.length) return; const o = e.clone(); for (const a of i) { const h = o.clone(), { center: f, zoom: g, roll: v, pitch: w, bearing: I, elevation: E } = a(h); f && h.setCenter(f), E !== void 0 && h.setElevation(E), g !== void 0 && h.setZoom(g), v !== void 0 && h.setRoll(v), w !== void 0 && h.setPitch(w), I !== void 0 && h.setBearing(I), o.apply(h) } this.transform.apply(o) } _fireMoveEvents(e) { this.fire(new c.l("move", e)), this._zooming && this.fire(new c.l("zoom", e)), this._rotating && this.fire(new c.l("rotate", e)), this._pitching && this.fire(new c.l("pitch", e)), this._rolling && this.fire(new c.l("roll", e)) } _afterEase(e, i) { if (this._easeId && i && this._easeId === i) return; delete this._easeId; const o = this._zooming, a = this._rotating, h = this._pitching, f = this._rolling; this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, o && this.fire(new c.l("zoomend", e)), a && this.fire(new c.l("rotateend", e)), h && this.fire(new c.l("pitchend", e)), f && this.fire(new c.l("rollend", e)), this.fire(new c.l("moveend", e)) } flyTo(e, i) { if (!e.essential && Le.prefersReducedMotion) { const Pe = c.O(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]); return this.jumpTo(Pe, i) } this.stop(), e = c.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: c.ca }, e); const o = this._getTransformForUpdate(), a = o.bearing, h = o.pitch, f = o.roll, g = o.padding, v = "bearing" in e ? this._normalizeBearing(e.bearing, a) : a, w = "pitch" in e ? +e.pitch : h, I = "roll" in e ? this._normalizeBearing(e.roll, f) : f, E = "padding" in e ? e.padding : o.padding, A = c.P.convert(e.offset); let B = o.centerPoint.add(A); const j = o.screenPointToLocation(B), q = this.cameraHelper.handleFlyTo(o, { bearing: v, pitch: w, roll: I, padding: E, locationAtOffset: j, offsetAsPoint: A, center: e.center, minZoom: e.minZoom, zoom: e.zoom }); let G = e.curve; const H = Math.max(o.width, o.height), K = H / q.scaleOfZoom, Q = q.pixelPathLength; typeof q.scaleOfMinZoom == "number" && (G = Math.sqrt(H / q.scaleOfMinZoom / Q * 2)); const ee = G * G; function re(Pe) { const $e = (K * K - H * H + (Pe ? -1 : 1) * ee * ee * Q * Q) / (2 * (Pe ? K : H) * ee * Q); return Math.log(Math.sqrt($e * $e + 1) - $e) } function oe(Pe) { return (Math.exp(Pe) - Math.exp(-Pe)) / 2 } function ne(Pe) { return (Math.exp(Pe) + Math.exp(-Pe)) / 2 } const me = re(!1); let ge = function (Pe) { return ne(me) / ne(me + G * Pe) }, Se = function (Pe) { return H * ((ne(me) * (oe($e = me + G * Pe) / ne($e)) - oe(me)) / ee) / Q; var $e }, Ie = (re(!0) - me) / G; if (Math.abs(Q) < 2e-6 || !isFinite(Ie)) { if (Math.abs(H - K) < 1e-6) return this.easeTo(e, i); const Pe = K < H ? -1 : 1; Ie = Math.abs(Math.log(K / H)) / G, Se = () => 0, ge = $e => Math.exp(Pe * G * $e) } return e.duration = "duration" in e ? +e.duration : 1e3 * Ie / ("screenSpeed" in e ? +e.screenSpeed / G : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = a !== v, this._pitching = w !== h, this._rolling = I !== f, this._padding = !o.isPaddingEqual(E), this._prepareEase(i, !1), this.terrain && this._prepareElevation(q.targetCenter), this._ease(Pe => { const $e = Pe * Ie, Ue = 1 / ge($e), De = Se($e); this._rotating && o.setBearing(c.B.number(a, v, Pe)), this._pitching && o.setPitch(c.B.number(h, w, Pe)), this._rolling && o.setRoll(c.B.number(f, I, Pe)), this._padding && (o.interpolatePadding(g, E, Pe), B = o.centerPoint.add(A)), q.easeFunc(Pe, Ue, De, B), this.terrain && !e.freezeElevation && this._updateElevation(Pe), this._applyUpdatedTransform(o), this._fireMoveEvents(i) }, () => { this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i) }, e), this } isEasing() { return !!this._easeFrameId } stop() { return this._stop() } _stop(e, i) { var o; if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) { const a = this._onEaseEnd; delete this._onEaseEnd, a.call(this, i) } return e || (o = this.handlers) === null || o === void 0 || o.stop(!1), this } _ease(e, i, o) { o.animate === !1 || o.duration === 0 ? (e(1), i()) : (this._easeStart = Le.now(), this._easeOptions = o, this._onEaseFrame = e, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback)) } _normalizeBearing(e, i) { e = c.aK(e, -180, 180); const o = Math.abs(e - i); return Math.abs(e - 360 - i) < o && (e -= 360), Math.abs(e + 360 - i) < o && (e += 360), e } queryTerrainElevation(e) { return this.terrain ? this.terrain.getElevationForLngLatZoom(c.Q.convert(e), this.transform.tileZoom) : null } } const ht = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' }; class uo { constructor(e = ht) { this._toggleAttribution = () => { this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open"))) }, this._updateData = i => { !i || i.sourceDataType !== "metadata" && i.sourceDataType !== "visibility" && i.dataType !== "style" && i.type !== "terrain" || this._updateAttributions() }, this._updateCompact = () => { this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show")) }, this._updateCompactMinimize = () => { this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show") }, this.options = e } getDefaultPosition() { return "bottom-right" } onAdd(e) { return this._map = e, this._compact = this.options.compact, this._container = ae.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = ae.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = ae.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container } onRemove() { ae.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._sanitizedAttributionHTML = void 0 } _setElementTitle(e, i) { const o = this._map._getUIString(`AttributionControl.${i}`); e.title = o, e.setAttribute("aria-label", o) } _updateAttributions() { if (!this._map.style) return; let e = []; if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map(a => typeof a != "string" ? "" : a)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) { const a = this._map.style.stylesheet; this.styleOwner = a.owner, this.styleId = a.id } const i = this._map.style.sourceCaches; for (const a in i) { const h = i[a]; if (h.used || h.usedForTerrain) { const f = h.getSource(); f.attribution && e.indexOf(f.attribution) < 0 && e.push(f.attribution) } } e = e.filter(a => String(a).trim()), e.sort((a, h) => a.length - h.length), e = e.filter((a, h) => { for (let f = h + 1; f < e.length; f++)if (e[f].indexOf(a) >= 0) return !1; return !0 }); const o = e.join(" | "); o !== this._sanitizedAttributionHTML && (this._sanitizedAttributionHTML = ae.sanitize(o), e.length ? (this._innerContainer.innerHTML = this._sanitizedAttributionHTML, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null) } } class la { constructor(e = {}) { this._updateCompact = () => { const i = this._container.children; if (i.length) { const o = i[0]; this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && o.classList.add("maplibregl-compact") : o.classList.remove("maplibregl-compact") } }, this.options = e } getDefaultPosition() { return "bottom-left" } onAdd(e) { this._map = e, this._compact = this.options && this.options.compact, this._container = ae.create("div", "maplibregl-ctrl"); const i = ae.create("a", "maplibregl-ctrl-logo"); return i.target = "_blank", i.rel = "noopener nofollow", i.href = "https://maplibre.org/", i.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), i.setAttribute("rel", "noopener nofollow"), this._container.appendChild(i), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container } onRemove() { ae.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0 } } class Fl { constructor() { this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1 } add(e) { const i = ++this._id; return this._queue.push({ callback: e, id: i, cancelled: !1 }), i } remove(e) { const i = this._currentlyRunning, o = i ? this._queue.concat(i) : this._queue; for (const a of o) if (a.id === e) return void (a.cancelled = !0) } run(e = 0) { if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running."); const i = this._currentlyRunning = this._queue; this._queue = []; for (const o of i) if (!o.cancelled && (o.callback(e), this._cleared)) break; this._cleared = !1, this._currentlyRunning = !1 } clear() { this._currentlyRunning && (this._cleared = !0), this._queue = [] } } var mr = c.aC([{ name: "a_pos3d", type: "Int16", components: 3 }]); class fu extends c.E { constructor(e) { super(), this._lastTilesetChange = Le.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize } destruct() { this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null } update(e, i) { this.sourceCache.update(e, i), this._renderableTilesKeys = []; const o = {}; for (const a of ue(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: i, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) o[a.key] = !0, this._renderableTilesKeys.push(a.key), this._tiles[a.key] || (a.terrainRttPosMatrix32f = new Float64Array(16), c.bN(a.terrainRttPosMatrix32f, 0, c.Z, c.Z, 0, 0, 1), this._tiles[a.key] = new mi(a, this.tileSize), this._lastTilesetChange = Le.now()); for (const a in this._tiles) o[a] || delete this._tiles[a] } freeRtt(e) { for (const i in this._tiles) { const o = this._tiles[i]; (!e || o.tileID.equals(e) || o.tileID.isChildOf(e) || e.isChildOf(o.tileID)) && (o.rtt = []) } } getRenderableTiles() { return this._renderableTilesKeys.map(e => this.getTileByID(e)) } getTileByID(e) { return this._tiles[e] } getTerrainCoords(e) { const i = {}; for (const o of this._renderableTilesKeys) { const a = this._tiles[o].tileID, h = e.clone(), f = c.b1(); if (a.canonical.equals(e.canonical)) c.bN(f, 0, c.Z, c.Z, 0, 0, 1); else if (a.canonical.isChildOf(e.canonical)) { const g = a.canonical.z - e.canonical.z, v = a.canonical.x - (a.canonical.x >> g << g), w = a.canonical.y - (a.canonical.y >> g << g), I = c.Z >> g; c.bN(f, 0, I, I, 0, 0, 1), c.L(f, f, [-v * I, -w * I, 0]) } else { if (!e.canonical.isChildOf(a.canonical)) continue; { const g = e.canonical.z - a.canonical.z, v = e.canonical.x - (e.canonical.x >> g << g), w = e.canonical.y - (e.canonical.y >> g << g), I = c.Z >> g; c.bN(f, 0, c.Z, c.Z, 0, 0, 1), c.L(f, f, [v * I, w * I, 0]), c.M(f, f, [1 / 2 ** g, 1 / 2 ** g, 0]) } } h.terrainRttPosMatrix32f = new Float32Array(f), i[o] = h } return i } getSourceTile(e, i) { const o = this.sourceCache._source; let a = e.overscaledZ - this.deltaZoom; if (a > o.maxzoom && (a = o.maxzoom), a < o.minzoom) return null; this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(a).key); let h = this.sourceCache.getTileByID(this._sourceTileCache[e.key]); if ((!h || !h.dem) && i) for (; a >= o.minzoom && (!h || !h.dem);)h = this.sourceCache.getTileByID(e.scaledTo(a--).key); return h } anyTilesAfterTime(e = Date.now()) { return this._lastTilesetChange >= e } } class hn { constructor(e, i, o) { this._meshCache = {}, this.painter = e, this.sourceCache = new fu(i), this.options = o, this.exaggeration = typeof o.exaggeration == "number" ? o.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024 } getDEMElevation(e, i, o, a = c.Z) { var h; if (!(i >= 0 && i < a && o >= 0 && o < a)) return 0; const f = this.getTerrainData(e), g = (h = f.tile) === null || h === void 0 ? void 0 : h.dem; if (!g) return 0; const v = c.cb([], [i / a * c.Z, o / a * c.Z], f.u_terrain_matrix), w = [v[0] * g.dim, v[1] * g.dim], I = Math.floor(w[0]), E = Math.floor(w[1]), A = w[0] - I, B = w[1] - E; return g.get(I, E) * (1 - A) * (1 - B) + g.get(I + 1, E) * A * (1 - B) + g.get(I, E + 1) * (1 - A) * B + g.get(I + 1, E + 1) * A * B } getElevationForLngLatZoom(e, i) { if (!c.cc(i, e.wrap())) return 0; const { tileID: o, mercatorX: a, mercatorY: h } = this._getOverscaledTileIDFromLngLatZoom(e, i); return this.getElevation(o, a % c.Z, h % c.Z, c.Z) } getElevation(e, i, o, a = c.Z) { return this.getDEMElevation(e, i, o, a) * this.exaggeration } getTerrainData(e) { if (!this._emptyDemTexture) { const a = this.painter.context, h = new c.R({ width: 1, height: 1 }, new Uint8Array(4)); this._emptyDepthTexture = new Nt(a, h, a.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new Nt(a, new c.R({ width: 1, height: 1 }), a.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(a.gl.NEAREST, a.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = c.as([]) } const i = this.sourceCache.getSourceTile(e, !0); if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) { const a = this.painter.context; i.demTexture = this.painter.getTileTexture(i.dem.stride), i.demTexture ? i.demTexture.update(i.dem.getPixels(), { premultiply: !1 }) : i.demTexture = new Nt(a, i.dem.getPixels(), a.gl.RGBA, { premultiply: !1 }), i.demTexture.bind(a.gl.NEAREST, a.gl.CLAMP_TO_EDGE), i.needsTerrainPrepare = !1 } const o = i && i + i.tileID.key + e.key; if (o && !this._demMatrixCache[o]) { const a = this.sourceCache.sourceCache._source.maxzoom; let h = e.canonical.z - i.tileID.canonical.z; e.overscaledZ > e.canonical.z && (e.canonical.z >= a ? h = e.canonical.z - a : c.w("cannot calculate elevation if elevation maxzoom > source.maxzoom")); const f = e.canonical.x - (e.canonical.x >> h << h), g = e.canonical.y - (e.canonical.y >> h << h), v = c.cd(new Float64Array(16), [1 / (c.Z << h), 1 / (c.Z << h), 0]); c.L(v, v, [f * c.Z, g * c.Z, 0]), this._demMatrixCache[e.key] = { matrix: v, coord: e } } return { u_depth: 2, u_terrain: 3, u_terrain_dim: i && i.dem && i.dem.dim || 1, u_terrain_matrix: o ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i && i.dem && i.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i && i.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i } } getFramebuffer(e) { const i = this.painter, o = i.width / devicePixelRatio, a = i.height / devicePixelRatio; return !this._fbo || this._fbo.width === o && this._fbo.height === a || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new Nt(i.context, { width: o, height: a, data: null }, i.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new Nt(i.context, { width: o, height: a, data: null }, i.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = i.context.createFramebuffer(o, a, !0, !1), this._fbo.depthAttachment.set(i.context.createRenderbuffer(i.context.gl.DEPTH_COMPONENT16, o, a))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo } getCoordsTexture() { const e = this.painter.context; if (this._coordsTexture) return this._coordsTexture; const i = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4); for (let h = 0, f = 0; h < this._coordsTextureSize; h++)for (let g = 0; g < this._coordsTextureSize; g++, f += 4)i[f + 0] = 255 & g, i[f + 1] = 255 & h, i[f + 2] = g >> 8 << 4 | h >> 8, i[f + 3] = 0; const o = new c.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i.buffer)), a = new Nt(e, o, e.gl.RGBA, { premultiply: !1 }); return a.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = a, a } pointCoordinate(e) { this.painter.maybeDrawDepthAndCoords(!0); const i = new Uint8Array(4), o = this.painter.context, a = o.gl, h = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), f = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), g = Math.round(this.painter.height / devicePixelRatio); o.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), a.readPixels(h, g - f - 1, 1, 1, a.RGBA, a.UNSIGNED_BYTE, i), o.bindFramebuffer.set(null); const v = i[0] + (i[2] >> 4 << 8), w = i[1] + ((15 & i[2]) << 8), I = this.coordsIndex[255 - i[3]], E = I && this.sourceCache.getTileByID(I); if (!E) return null; const A = this._coordsTextureSize, B = (1 << E.tileID.canonical.z) * A; return new c.$((E.tileID.canonical.x * A + v) / B + E.tileID.wrap, (E.tileID.canonical.y * A + w) / B, this.getElevation(E.tileID, v, w, A)) } depthAtPoint(e) { const i = new Uint8Array(4), o = this.painter.context, a = o.gl; return o.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), a.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, a.RGBA, a.UNSIGNED_BYTE, i), o.bindFramebuffer.set(null), (i[0] / 16777216 + i[1] / 65536 + i[2] / 256 + i[3]) / 256 } getTerrainMesh(e) { var i; const o = ((i = this.painter.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0, a = o && e.canonical.y === 0, h = o && e.canonical.y === (1 << e.canonical.z) - 1, f = `m_${a ? "n" : ""}_${h ? "s" : ""}`; if (this._meshCache[f]) return this._meshCache[f]; const g = this.painter.context, v = new c.ce, w = new c.aG, I = this.meshSize, E = c.Z / I, A = I * I; for (let ne = 0; ne <= I; ne++)for (let me = 0; me <= I; me++)v.emplaceBack(me * E, ne * E, 0); for (let ne = 0; ne < A; ne += I + 1)for (let me = 0; me < I; me++)w.emplaceBack(me + ne, I + me + ne + 1, I + me + ne + 2), w.emplaceBack(me + ne, I + me + ne + 2, me + ne + 1); const B = v.length, j = B + (I + 1), q = (I + 1) * I, G = a ? c.b8 : 0, H = a ? 0 : 1, K = h ? c.b9 : c.Z, Q = h ? 0 : 1; for (let ne = 0; ne <= I; ne++)v.emplaceBack(ne * E, G, H); for (let ne = 0; ne <= I; ne++)v.emplaceBack(ne * E, K, Q); for (let ne = 0; ne < I; ne++)w.emplaceBack(q + ne, j + ne, j + ne + 1), w.emplaceBack(q + ne, j + ne + 1, q + ne + 1), w.emplaceBack(0 + ne, B + ne + 1, B + ne), w.emplaceBack(0 + ne, 0 + ne + 1, B + ne + 1); const ee = v.length, re = ee + 2 * (I + 1); for (const ne of [0, 1]) for (let me = 0; me <= I; me++)for (const ge of [0, 1]) v.emplaceBack(ne * c.Z, me * E, ge); for (let ne = 0; ne < 2 * I; ne += 2)w.emplaceBack(ee + ne, ee + ne + 1, ee + ne + 3), w.emplaceBack(ee + ne, ee + ne + 3, ee + ne + 2), w.emplaceBack(re + ne, re + ne + 3, re + ne + 1), w.emplaceBack(re + ne, re + ne + 2, re + ne + 3); const oe = new vr(g.createVertexBuffer(v, mr.members), g.createIndexBuffer(w), c.aF.simpleSegment(0, 0, v.length, w.length)); return this._meshCache[f] = oe, oe } getMeshFrameDelta(e) { return 2 * Math.PI * c.bq / Math.pow(2, Math.max(e, 0)) / 5 } getMinTileElevationForLngLatZoom(e, i) { var o; const { tileID: a } = this._getOverscaledTileIDFromLngLatZoom(e, i); return (o = this.getMinMaxElevation(a).minElevation) !== null && o !== void 0 ? o : 0 } getMinMaxElevation(e) { const i = this.getTerrainData(e).tile, o = { minElevation: null, maxElevation: null }; return i && i.dem && (o.minElevation = i.dem.min * this.exaggeration, o.maxElevation = i.dem.max * this.exaggeration), o } _getOverscaledTileIDFromLngLatZoom(e, i) { const o = c.$.fromLngLat(e.wrap()), a = (1 << i) * c.Z, h = o.x * a, f = o.y * a, g = Math.floor(h / c.Z), v = Math.floor(f / c.Z); return { tileID: new c.Y(i, 0, i, g, v), mercatorX: h, mercatorY: f } } } class Ch { constructor(e, i, o) { this._context = e, this._size = i, this._tileSize = o, this._objects = [], this._recentlyUsed = [], this._stamp = 0 } destruct() { for (const e of this._objects) e.texture.destroy(), e.fbo.destroy() } _createObject(e) { const i = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), o = new Nt(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA); return o.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), i.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), i.colorAttachment.set(o.texture), { id: e, fbo: i, texture: o, stamp: -1, inUse: !1 } } getObjectForId(e) { return this._objects[e] } useObject(e) { e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(i => e.id !== i), this._recentlyUsed.push(e.id) } stampObject(e) { e.stamp = ++this._stamp } getOrCreateFreeObject() { for (const i of this._recentlyUsed) if (!this._objects[i].inUse) return this._objects[i]; if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!"); const e = this._createObject(this._objects.length); return this._objects.push(e), e } freeObject(e) { e.inUse = !1 } freeAllObjects() { for (const e of this._objects) this.freeObject(e) } isFull() { return !(this._objects.length < this._size) && this._objects.some(e => !e.inUse) === !1 } } const dn = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 }; class pi { constructor(e, i) { this.painter = e, this.terrain = i, this.pool = new Ch(e.context, 30, i.sourceCache.tileSize * i.qualityFactor) } destruct() { this.pool.destruct() } getTexture(e) { return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture } prepareForRender(e, i) { this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter(o => !e._layers[o].isHidden(i)), this._coordsAscending = {}; for (const o in e.sourceCaches) { this._coordsAscending[o] = {}; const a = e.sourceCaches[o].getVisibleCoordinates(); for (const h of a) { const f = this.terrain.sourceCache.getTerrainCoords(h); for (const g in f) this._coordsAscending[o][g] || (this._coordsAscending[o][g] = []), this._coordsAscending[o][g].push(f[g]) } } this._coordsAscendingStr = {}; for (const o of e._order) { const a = e._layers[o], h = a.source; if (dn[a.type] && !this._coordsAscendingStr[h]) { this._coordsAscendingStr[h] = {}; for (const f in this._coordsAscending[h]) this._coordsAscendingStr[h][f] = this._coordsAscending[h][f].map(g => g.key).sort().join() } } for (const o of this._renderableTiles) for (const a in this._coordsAscendingStr) { const h = this._coordsAscendingStr[a][o.tileID.key]; h && h !== o.rttCoords[a] && (o.rtt = []) } } renderLayer(e, i) { if (e.isHidden(this.painter.transform.zoom)) return !1; const o = Object.assign(Object.assign({}, i), { isRenderingToTexture: !0 }), a = e.type, h = this.painter, f = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id; if (dn[a] && (this._prevType && dn[this._prevType] || this._stacks.push([]), this._prevType = a, this._stacks[this._stacks.length - 1].push(e.id), !f)) return !0; if (dn[this._prevType] || dn[a] && f) { this._prevType = a; const g = this._stacks.length - 1, v = this._stacks[g] || []; for (const w of this._renderableTiles) { if (this.pool.isFull() && (Tl(this.painter, this.terrain, this._rttTiles, o), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(w), w.rtt[g]) { const E = this.pool.getObjectForId(w.rtt[g].id); if (E.stamp === w.rtt[g].stamp) { this.pool.useObject(E); continue } } const I = this.pool.getOrCreateFreeObject(); this.pool.useObject(I), this.pool.stampObject(I), w.rtt[g] = { id: I.id, stamp: I.stamp }, h.context.bindFramebuffer.set(I.fbo.framebuffer), h.context.clear({ color: c.b6.transparent, stencil: 0 }), h.currentStencilSource = void 0; for (let E = 0; E < v.length; E++) { const A = h.style._layers[v[E]], B = A.source ? this._coordsAscending[A.source][w.tileID.key] : [w.tileID]; h.context.viewport.set([0, 0, I.fbo.width, I.fbo.height]), h._renderTileClippingMasks(A, B, !0), h.renderLayer(h, h.style.sourceCaches[A.source], A, B, o), A.source && (w.rttCoords[A.source] = this._coordsAscendingStr[A.source][w.tileID.key]) } } return Tl(this.painter, this.terrain, this._rttTiles, o), this._rttTiles = [], this.pool.freeAllObjects(), dn[a] } return !1 } } const xi = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, mu = de, ks = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: ht, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: c.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0 }, ca = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 }; class Bl { constructor(e, i, o = !1) { this.mousedown = h => { this.startMove(h, ae.mousePos(this.element, h)), ae.addEventListener(window, "mousemove", this.mousemove), ae.addEventListener(window, "mouseup", this.mouseup) }, this.mousemove = h => { this.move(h, ae.mousePos(this.element, h)) }, this.mouseup = h => { this._rotatePitchHanlder.dragEnd(h), this.offTemp() }, this.touchstart = h => { h.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = ae.touchPos(this.element, h.targetTouches)[0], this.startMove(h, this._startPos), ae.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ae.addEventListener(window, "touchend", this.touchend)) }, this.touchmove = h => { h.targetTouches.length !== 1 ? this.reset() : (this._lastPos = ae.touchPos(this.element, h.targetTouches)[0], this.move(h, this._lastPos)) }, this.touchend = h => { h.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp() }, this.reset = () => { this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp() }, this._clickTolerance = 10, this.element = i; const a = new cu; this._rotatePitchHanlder = new wr({ clickTolerance: 3, move: (h, f) => { const g = i.getBoundingClientRect(), v = new c.P((g.bottom - g.top) / 2, (g.right - g.left) / 2); return { bearingDelta: c.c9(new c.P(h.x, f.y), f, v), pitchDelta: o ? -.5 * (f.y - h.y) : void 0 } }, moveStateManager: a, enable: !0, assignEvents: () => { } }), this.map = e, ae.addEventListener(i, "mousedown", this.mousedown), ae.addEventListener(i, "touchstart", this.touchstart, { passive: !1 }), ae.addEventListener(i, "touchcancel", this.reset) } startMove(e, i) { this._rotatePitchHanlder.dragStart(e, i), ae.disableDrag() } move(e, i) { const o = this.map, { bearingDelta: a, pitchDelta: h } = this._rotatePitchHanlder.dragMove(e, i) || {}; a && o.setBearing(o.getBearing() + a), h && o.setPitch(o.getPitch() + h) } off() { const e = this.element; ae.removeEventListener(e, "mousedown", this.mousedown), ae.removeEventListener(e, "touchstart", this.touchstart, { passive: !1 }), ae.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ae.removeEventListener(window, "touchend", this.touchend), ae.removeEventListener(e, "touchcancel", this.reset), this.offTemp() } offTemp() { ae.enableDrag(), ae.removeEventListener(window, "mousemove", this.mousemove), ae.removeEventListener(window, "mouseup", this.mouseup), ae.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), ae.removeEventListener(window, "touchend", this.touchend) } } let gn; function ua(u, e, i) { const o = new c.Q(u.lng, u.lat); if (u = new c.Q(u.lng, u.lat), e) { const a = new c.Q(u.lng - 360, u.lat), h = new c.Q(u.lng + 360, u.lat), f = i.locationToScreenPoint(u).distSqr(e); i.locationToScreenPoint(a).distSqr(e) < f ? u = a : i.locationToScreenPoint(h).distSqr(e) < f && (u = h) } for (; Math.abs(u.lng - i.center.lng) > 180;) { const a = i.locationToScreenPoint(u); if (a.x >= 0 && a.y >= 0 && a.x <= i.width && a.y <= i.height) break; u.lng > i.center.lng ? u.lng -= 360 : u.lng += 360 } return u.lng !== o.lng && i.isPointOnMapSurface(i.locationToScreenPoint(u)) ? u : o } const ts = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }; function ha(u, e, i) { const o = u.classList; for (const a in ts) o.remove(`maplibregl-${i}-anchor-${a}`); o.add(`maplibregl-${i}-anchor-${e}`) } class ho extends c.E { constructor(e) { if (super(), this._onKeyPress = i => { const o = i.code, a = i.charCode || i.keyCode; o !== "Space" && o !== "Enter" && a !== 32 && a !== 13 || this.togglePopup() }, this._onMapClick = i => { const o = i.originalEvent.target, a = this._element; this._popup && (o === a || a.contains(o)) && this.togglePopup() }, this._update = i => { var o; if (!this._map) return; const a = this._map.loaded() && !this._map.isMoving(); ((i == null ? void 0 : i.type) === "terrain" || (i == null ? void 0 : i.type) === "render" && !a) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? ua(this._lngLat, this._flatPos, this._map.transform) : (o = this._lngLat) === null || o === void 0 ? void 0 : o.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset)); let h = ""; this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? h = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (h = `rotateZ(${this._rotation - this._map.getBearing()}deg)`); let f = ""; this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? f = "rotateX(0deg)" : this._pitchAlignment === "map" && (f = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || i && i.type !== "moveend" || (this._pos = this._pos.round()), ae.setTransform(this._element, `${ts[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${f} ${h}`), Le.frameAsync(new AbortController).then(() => { this._updateOpacity(i && i.type === "moveend") }).catch(() => { }) }, this._onMove = i => { if (!this._isDragging) { const o = this._clickTolerance || this._map._clickTolerance; this._isDragging = i.point.dist(this._pointerdownPos) >= o } this._isDragging && (this._pos = i.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new c.l("dragstart"))), this.fire(new c.l("drag"))) }, this._onUp = () => { this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new c.l("dragend")), this._state = "inactive" }, this._addDragHandler = i => { this._element.contains(i.originalEvent.target) && (i.preventDefault(), this._positionDelta = i.point.sub(this._pos).add(this._offset), this._pointerdownPos = i.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp)) }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e == null ? void 0 : e.opacity, e == null ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = c.P.convert(e && e.offset || [0, 0]); else { this._defaultMarker = !0, this._element = ae.create("div"); const i = ae.createNS("http://www.w3.org/2000/svg", "svg"), o = 41, a = 27; i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", `${o}px`), i.setAttributeNS(null, "width", `${a}px`), i.setAttributeNS(null, "viewBox", `0 0 ${a} ${o}`); const h = ae.createNS("http://www.w3.org/2000/svg", "g"); h.setAttributeNS(null, "stroke", "none"), h.setAttributeNS(null, "stroke-width", "1"), h.setAttributeNS(null, "fill", "none"), h.setAttributeNS(null, "fill-rule", "evenodd"); const f = ae.createNS("http://www.w3.org/2000/svg", "g"); f.setAttributeNS(null, "fill-rule", "nonzero"); const g = ae.createNS("http://www.w3.org/2000/svg", "g"); g.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), g.setAttributeNS(null, "fill", "#000000"); const v = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; for (const H of v) { const K = ae.createNS("http://www.w3.org/2000/svg", "ellipse"); K.setAttributeNS(null, "opacity", "0.04"), K.setAttributeNS(null, "cx", "10.5"), K.setAttributeNS(null, "cy", "5.80029008"), K.setAttributeNS(null, "rx", H.rx), K.setAttributeNS(null, "ry", H.ry), g.appendChild(K) } const w = ae.createNS("http://www.w3.org/2000/svg", "g"); w.setAttributeNS(null, "fill", this._color); const I = ae.createNS("http://www.w3.org/2000/svg", "path"); I.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), w.appendChild(I); const E = ae.createNS("http://www.w3.org/2000/svg", "g"); E.setAttributeNS(null, "opacity", "0.25"), E.setAttributeNS(null, "fill", "#000000"); const A = ae.createNS("http://www.w3.org/2000/svg", "path"); A.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), E.appendChild(A); const B = ae.createNS("http://www.w3.org/2000/svg", "g"); B.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), B.setAttributeNS(null, "fill", "#FFFFFF"); const j = ae.createNS("http://www.w3.org/2000/svg", "g"); j.setAttributeNS(null, "transform", "translate(8.0, 8.0)"); const q = ae.createNS("http://www.w3.org/2000/svg", "circle"); q.setAttributeNS(null, "fill", "#000000"), q.setAttributeNS(null, "opacity", "0.25"), q.setAttributeNS(null, "cx", "5.5"), q.setAttributeNS(null, "cy", "5.5"), q.setAttributeNS(null, "r", "5.4999962"); const G = ae.createNS("http://www.w3.org/2000/svg", "circle"); G.setAttributeNS(null, "fill", "#FFFFFF"), G.setAttributeNS(null, "cx", "5.5"), G.setAttributeNS(null, "cy", "5.5"), G.setAttributeNS(null, "r", "5.4999962"), j.appendChild(q), j.appendChild(G), f.appendChild(g), f.appendChild(w), f.appendChild(E), f.appendChild(B), f.appendChild(j), i.appendChild(f), i.setAttributeNS(null, "height", o * this._scale + "px"), i.setAttributeNS(null, "width", a * this._scale + "px"), this._element.appendChild(i), this._offset = c.P.convert(e && e.offset || [0, -14]) } if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", i => { i.preventDefault() }), this._element.addEventListener("mousedown", i => { i.preventDefault() }), ha(this._element, this._anchor, "marker"), e && e.className) for (const i of e.className.split(" ")) this._element.classList.add(i); this._popup = null } addTo(e) { return this.remove(), this._map = e, this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this } remove() { return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), ae.remove(this._element), this._popup && this._popup.remove(), this } getLngLat() { return this._lngLat } setLngLat(e) { return this._lngLat = c.Q.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this } getElement() { return this._element } setPopup(e) { if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) { if (!("offset" in e.options)) { const a = Math.abs(13.5) / Math.SQRT2; e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [a, -1 * (38.1 - 13.5 + a)], "bottom-right": [-a, -1 * (38.1 - 13.5 + a)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset } this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress) } return this } setSubpixelPositioning(e) { return this._subpixelPositioning = e, this } getPopup() { return this._popup } togglePopup() { const e = this._popup; return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this } _updateOpacity(e = !1) { var i, o; if (!(!((i = this._map) === null || i === void 0) && i.terrain)) { const E = this._map.transform.isLocationOccluded(this._lngLat) ? this._opacityWhenCovered : this._opacity; return void (this._element.style.opacity !== E && (this._element.style.opacity = E)) } if (e) this._opacityTimeout = null; else { if (this._opacityTimeout) return; this._opacityTimeout = setTimeout(() => { this._opacityTimeout = null }, 100) } const a = this._map, h = a.terrain.depthAtPoint(this._pos), f = a.terrain.getElevationForLngLatZoom(this._lngLat, a.transform.tileZoom); if (a.transform.lngLatToCameraDepth(this._lngLat, f) - h < .006) return void (this._element.style.opacity = this._opacity); const g = -this._offset.y / a.transform.pixelsPerMeter, v = Math.sin(a.getPitch() * Math.PI / 180) * g, w = a.terrain.depthAtPoint(new c.P(this._pos.x, this._pos.y - this._offset.y)), I = a.transform.lngLatToCameraDepth(this._lngLat, f + v) - w > .006; !((o = this._popup) === null || o === void 0) && o.isOpen() && I && this._popup.remove(), this._element.style.opacity = I ? this._opacityWhenCovered : this._opacity } getOffset() { return this._offset } setOffset(e) { return this._offset = c.P.convert(e), this._update(), this } addClassName(e) { this._element.classList.add(e) } removeClassName(e) { this._element.classList.remove(e) } toggleClassName(e) { return this._element.classList.toggle(e) } setDraggable(e) { return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this } isDraggable() { return this._draggable } setRotation(e) { return this._rotation = e || 0, this._update(), this } getRotation() { return this._rotation } setRotationAlignment(e) { return this._rotationAlignment = e || "auto", this._update(), this } getRotationAlignment() { return this._rotationAlignment } setPitchAlignment(e) { return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this } getPitchAlignment() { return this._pitchAlignment } setOpacity(e, i) { return (this._opacity === void 0 || e === void 0 && i === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), i !== void 0 && (this._opacityWhenCovered = i), this._map && this._updateOpacity(!0), this } } const Ol = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 }; let Ds = 0, is = !1; const jl = { maxWidth: 100, unit: "metric" }; function da(u, e, i) { const o = i && i.maxWidth || 100, a = u._container.clientHeight / 2, h = u._container.clientWidth / 2, f = u.unproject([h - o / 2, a]), g = u.unproject([h + o / 2, a]), v = Math.round(u.project(g).x - u.project(f).x), w = Math.min(o, v, u._container.clientWidth), I = f.distanceTo(g); if (i && i.unit === "imperial") { const E = 3.2808 * I; E > 5280 ? rs(e, w, E / 5280, u._getUIString("ScaleControl.Miles")) : rs(e, w, E, u._getUIString("ScaleControl.Feet")) } else i && i.unit === "nautical" ? rs(e, w, I / 1852, u._getUIString("ScaleControl.NauticalMiles")) : I >= 1e3 ? rs(e, w, I / 1e3, u._getUIString("ScaleControl.Kilometers")) : rs(e, w, I, u._getUIString("ScaleControl.Meters")) } function rs(u, e, i, o) { const a = function (h) { const f = Math.pow(10, `${Math.floor(h)}`.length - 1); let g = h / f; return g = g >= 10 ? 10 : g >= 5 ? 5 : g >= 3 ? 3 : g >= 2 ? 2 : g >= 1 ? 1 : function (v) { const w = Math.pow(10, Math.ceil(-Math.log(v) / Math.LN10)); return Math.round(v * w) / w }(g), f * g }(i); u.style.width = e * (a / i) + "px", u.innerHTML = `${a}&nbsp;${o}` } const pa = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1, locationOccludedOpacity: void 0 }, Vl = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "); function fa(u) { if (u) { if (typeof u == "number") { const e = Math.round(Math.abs(u) / Math.SQRT2); return { center: new c.P(0, 0), top: new c.P(0, u), "top-left": new c.P(e, e), "top-right": new c.P(-e, e), bottom: new c.P(0, -u), "bottom-left": new c.P(e, -e), "bottom-right": new c.P(-e, -e), left: new c.P(u, 0), right: new c.P(-u, 0) } } if (u instanceof c.P || Array.isArray(u)) { const e = c.P.convert(u); return { center: e, top: e, "top-left": e, "top-right": e, bottom: e, "bottom-left": e, "bottom-right": e, left: e, right: e } } return { center: c.P.convert(u.center || [0, 0]), top: c.P.convert(u.top || [0, 0]), "top-left": c.P.convert(u["top-left"] || [0, 0]), "top-right": c.P.convert(u["top-right"] || [0, 0]), bottom: c.P.convert(u.bottom || [0, 0]), "bottom-left": c.P.convert(u["bottom-left"] || [0, 0]), "bottom-right": c.P.convert(u["bottom-right"] || [0, 0]), left: c.P.convert(u.left || [0, 0]), right: c.P.convert(u.right || [0, 0]) } } return fa(new c.P(0, 0)) } const ma = de; P.AJAXError = c.ci, P.Event = c.l, P.Evented = c.E, P.LngLat = c.Q, P.MercatorCoordinate = c.$, P.Point = c.P, P.addProtocol = c.cj, P.config = c.a, P.removeProtocol = c.ck, P.AttributionControl = uo, P.BoxZoomHandler = lu, P.CanvasSource = dt, P.CooperativeGesturesHandler = Ll, P.DoubleClickZoomHandler = pu, P.DragPanHandler = lo, P.DragRotateHandler = oa, P.EdgeInsets = Ri, P.FullscreenControl = class extends c.E { constructor(u = {}) { super(), this._onFullscreenChange = () => { var e; let i = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement; for (; !((e = i == null ? void 0 : i.shadowRoot) === null || e === void 0) && e.fullscreenElement;)i = i.shadowRoot.fullscreenElement; i === this._container !== this._fullscreen && this._handleFullscreenChange() }, this._onClickFullscreen = () => { this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen() }, this._fullscreen = !1, u && u.container && (u.container instanceof HTMLElement ? this._container = u.container : c.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange") } onAdd(u) { return this._map = u, this._container || (this._container = this._map.getContainer()), this._controlContainer = ae.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer } onRemove() { ae.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange) } _setupUI() { const u = this._fullscreenButton = ae.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer); ae.create("span", "maplibregl-ctrl-icon", u).setAttribute("aria-hidden", "true"), u.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange) } _updateTitle() { const u = this._getTitle(); this._fullscreenButton.setAttribute("aria-label", u), this._fullscreenButton.title = u } _getTitle() { return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter") } _isFullscreen() { return this._fullscreen } _handleFullscreenChange() { this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new c.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new c.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable()) } _exitFullscreen() { window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen() } _requestFullscreen() { this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen() } _togglePseudoFullScreen() { this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize() } }, P.GeoJSONSource = We, P.GeolocateControl = class extends c.E { constructor(u) { super(), this._onSuccess = e => { if (this._map) { if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new c.l("outofmaxbounds", e)), this._updateMarker(), void this._finish(); if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) { case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active"); break; case "BACKGROUND": case "BACKGROUND_ERROR": this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"); break; default: throw new Error(`Unexpected watchState ${this._watchState}`) }this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new c.l("geolocate", e)), this._finish() } }, this._updateCamera = e => { const i = new c.Q(e.coords.longitude, e.coords.latitude), o = e.coords.accuracy, a = this._map.getBearing(), h = c.e({ bearing: a }, this.options.fitBoundsOptions), f = we.fromLngLat(i, o); this._map.fitBounds(f, h, { geolocateSource: !0 }) }, this._updateMarker = e => { if (e) { const i = new c.Q(e.coords.longitude, e.coords.latitude); this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius() } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove() }, this._onZoom = () => { this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius() }, this._onError = e => { if (this._map) { if (this.options.trackUserLocation) if (e.code === 1) { this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0; const i = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i), this._geolocationWatchID !== void 0 && this._clearWatch() } else { if (e.code === 3 && is) return; this._setErrorState() } this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new c.l("error", e)), this._finish() } }, this._finish = () => { this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0 }, this._setupUI = () => { this._map && (this._container.addEventListener("contextmenu", e => e.preventDefault()), this._geolocateButton = ae.create("button", "maplibregl-ctrl-geolocate", this._container), ae.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0) }, this._finishSetupUI = e => { if (this._map) { if (e === !1) { c.w("Geolocation support is not available so the GeolocateControl will be disabled."); const i = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.disabled = !0, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i) } else { const i = this._map._getUIString("GeolocateControl.FindMyLocation"); this._geolocateButton.disabled = !1, this._geolocateButton.title = i, this._geolocateButton.setAttribute("aria-label", i) } this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = ae.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ho({ element: this._dotElement }), this._circleElement = ae.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ho({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", i => { i.geolocateSource || this._watchState !== "ACTIVE_LOCK" || i.originalEvent && i.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new c.l("trackuserlocationend")), this.fire(new c.l("userlocationlostfocus"))) }) } }, this.options = c.e({}, Ol, u) } onAdd(u) { return this._map = u, this._container = ae.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function () { return c._(this, arguments, void 0, function* (e = !1) { if (gn !== void 0 && !e) return gn; if (window.navigator.permissions === void 0) return gn = !!window.navigator.geolocation, gn; try { gn = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied" } catch { gn = !!window.navigator.geolocation } return gn }) }().then(e => this._finishSetupUI(e)), this._container } onRemove() { this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), ae.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ds = 0, is = !1 } _isOutOfMapMaxBounds(u) { const e = this._map.getMaxBounds(), i = u.coords; return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth()) } _setErrorState() { switch (this._watchState) { case "WAITING_ACTIVE": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"); break; case "ACTIVE_LOCK": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"); break; case "BACKGROUND": this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"); break; case "ACTIVE_ERROR": break; default: throw new Error(`Unexpected watchState ${this._watchState}`) } } _updateCircleRadius() { const u = this._map.getBounds(), e = u.getSouthEast(), i = u.getNorthEast(), o = e.distanceTo(i), a = Math.ceil(this._accuracy / (o / this._map._container.clientHeight) * 2); this._circleElement.style.width = `${a}px`, this._circleElement.style.height = `${a}px` } trigger() { if (!this._setup) return c.w("Geolocate control triggered before added to a map"), !1; if (this.options.trackUserLocation) { switch (this._watchState) { case "OFF": this._watchState = "WAITING_ACTIVE", this.fire(new c.l("trackuserlocationstart")); break; case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": case "BACKGROUND_ERROR": Ds--, is = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new c.l("trackuserlocationend")); break; case "BACKGROUND": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new c.l("trackuserlocationstart")), this.fire(new c.l("userlocationfocus")); break; default: throw new Error(`Unexpected watchState ${this._watchState}`) }switch (this._watchState) { case "WAITING_ACTIVE": this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active"); break; case "ACTIVE_LOCK": this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active"); break; case "OFF": break; default: throw new Error(`Unexpected watchState ${this._watchState}`) }if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch(); else if (this._geolocationWatchID === void 0) { let u; this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ds++, Ds > 1 ? (u = { maximumAge: 6e5, timeout: 0 }, is = !0) : (u = this.options.positionOptions, is = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, u) } } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4); return !0 } _clearWatch() { window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null) } }, P.GlobeControl = class { constructor() { this._toggleProjection = () => { var u; const e = (u = this._map.getProjection()) === null || u === void 0 ? void 0 : u.type; this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon() }, this._updateGlobeIcon = () => { var u; this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((u = this._map.getProjection()) === null || u === void 0 ? void 0 : u.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable")) } } onAdd(u) { return this._map = u, this._container = ae.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = ae.create("button", "maplibregl-ctrl-globe", this._container), ae.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container } onRemove() { ae.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0 } }, P.Hash = Cn, P.ImageSource = qe, P.KeyboardHandler = kl, P.LngLatBounds = we, P.LogoControl = la, P.Map = class extends nt { constructor(u) { var e, i; c.cf.mark(c.cg.create); const o = Object.assign(Object.assign(Object.assign({}, ks), u), { canvasContextAttributes: Object.assign(Object.assign({}, ks.canvasContextAttributes), u.canvasContextAttributes) }); if (o.minZoom != null && o.maxZoom != null && o.minZoom > o.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom"); if (o.minPitch != null && o.maxPitch != null && o.minPitch > o.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch"); if (o.minPitch != null && o.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0"); if (o.maxPitch != null && o.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180"); const a = new Br, h = new Kr; if (o.minZoom !== void 0 && a.setMinZoom(o.minZoom), o.maxZoom !== void 0 && a.setMaxZoom(o.maxZoom), o.minPitch !== void 0 && a.setMinPitch(o.minPitch), o.maxPitch !== void 0 && a.setMaxPitch(o.maxPitch), o.renderWorldCopies !== void 0 && a.setRenderWorldCopies(o.renderWorldCopies), super(a, h, { bearingSnap: o.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Fl, this._controls = [], this._mapId = c.a3(), this._contextLost = g => { g.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new c.l("webglcontextlost", { originalEvent: g })) }, this._contextRestored = g => { this._setupPainter(), this.resize(), this._update(), this.fire(new c.l("webglcontextrestored", { originalEvent: g })) }, this._onMapScroll = g => { if (g.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1 }, this._onWindowOnline = () => { this._update() }, this._interactive = o.interactive, this._maxTileCacheSize = o.maxTileCacheSize, this._maxTileCacheZoomLevels = o.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, o.canvasContextAttributes), this._trackResize = o.trackResize === !0, this._bearingSnap = o.bearingSnap, this._centerClampedToGround = o.centerClampedToGround, this._refreshExpiredTiles = o.refreshExpiredTiles === !0, this._fadeDuration = o.fadeDuration, this._crossSourceCollisions = o.crossSourceCollisions === !0, this._collectResourceTiming = o.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, xi), o.locale), this._clickTolerance = o.clickTolerance, this._overridePixelRatio = o.pixelRatio, this._maxCanvasSize = o.maxCanvasSize, this.transformCameraUpdate = o.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = o.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = ot.addThrottleControl(() => this.isMoving()), this._requestManager = new Ht(o.transformRequest), typeof o.container == "string") { if (this._container = document.getElementById(o.container), !this._container) throw new Error(`Container '${o.container}' not found.`) } else { if (!(o.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement."); this._container = o.container } if (o.maxBounds && this.setMaxBounds(o.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => { this.painter.terrainFacilitator.dirty = !0, this._update(!0) }), this.once("idle", () => { this._idleTriggered = !0 }), typeof window < "u") { addEventListener("online", this._onWindowOnline, !1); let g = !1; const v = Sl(w => { this._trackResize && !this._removed && (this.resize(w), this.redraw()) }, 50); this._resizeObserver = new ResizeObserver(w => { g ? v(w) : g = !0 }), this._resizeObserver.observe(this._container) } this.handlers = new aa(this, o), this._hash = o.hash && new Cn(typeof o.hash == "string" && o.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: o.center, elevation: o.elevation, zoom: o.zoom, bearing: o.bearing, pitch: o.pitch, roll: o.roll }), o.bounds && (this.resize(), this.fitBounds(o.bounds, c.e({}, o.fitBoundsOptions, { duration: 0 })))); const f = typeof o.style == "string" || ((i = (e = o.style) === null || e === void 0 ? void 0 : e.projection) === null || i === void 0 ? void 0 : i.type) !== "globe"; this.resize(null, f), this._localIdeographFontFamily = o.localIdeographFontFamily, this._validateStyle = o.validateStyle, o.style && this.setStyle(o.style, { localIdeographFontFamily: o.localIdeographFontFamily }), o.attributionControl && this.addControl(new uo(typeof o.attributionControl == "boolean" ? void 0 : o.attributionControl)), o.maplibreLogo && this.addControl(new la, o.logoPosition), this.on("style.load", () => { if (f || this._resizeTransform(), this.transform.unmodified) { const g = c.O(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]); this.jumpTo(g) } }), this.on("data", g => { this._update(g.dataType === "style"), this.fire(new c.l(`${g.dataType}data`, g)) }), this.on("dataloading", g => { this.fire(new c.l(`${g.dataType}dataloading`, g)) }), this.on("dataabort", g => { this.fire(new c.l("sourcedataabort", g)) }) } _getMapId() { return this._mapId } addControl(u, e) { if (e === void 0 && (e = u.getDefaultPosition ? u.getDefaultPosition() : "top-right"), !u || !u.onAdd) return this.fire(new c.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."))); const i = u.onAdd(this); this._controls.push(u); const o = this._controlPositions[e]; return e.indexOf("bottom") !== -1 ? o.insertBefore(i, o.firstChild) : o.appendChild(i), this } removeControl(u) { if (!u || !u.onRemove) return this.fire(new c.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."))); const e = this._controls.indexOf(u); return e > -1 && this._controls.splice(e, 1), u.onRemove(this), this } hasControl(u) { return this._controls.indexOf(u) > -1 } calculateCameraOptionsFromTo(u, e, i, o) { return o == null && this.terrain && (o = this.terrain.getElevationForLngLatZoom(i, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(u, e, i, o) } resize(u, e = !0) { const [i, o] = this._containerDimensions(), a = this._getClampedPixelRatio(i, o); if (this._resizeCanvas(i, o, a), this.painter.resize(i, o, a), this.painter.overLimit()) { const f = this.painter.context.gl; this._maxCanvasSize = [f.drawingBufferWidth, f.drawingBufferHeight]; const g = this._getClampedPixelRatio(i, o); this._resizeCanvas(i, o, g), this.painter.resize(i, o, g) } this._resizeTransform(e); const h = !this._moving; return h && (this.stop(), this.fire(new c.l("movestart", u)).fire(new c.l("move", u))), this.fire(new c.l("resize", u)), h && this.fire(new c.l("moveend", u)), this } _resizeTransform(u = !0) { var e; const [i, o] = this._containerDimensions(); this.transform.resize(i, o, u), (e = this._requestedCameraState) === null || e === void 0 || e.resize(i, o, u) } _getClampedPixelRatio(u, e) { const { 0: i, 1: o } = this._maxCanvasSize, a = this.getPixelRatio(), h = u * a, f = e * a; return Math.min(h > i ? i / h : 1, f > o ? o / f : 1) * a } getPixelRatio() { var u; return (u = this._overridePixelRatio) !== null && u !== void 0 ? u : devicePixelRatio } setPixelRatio(u) { this._overridePixelRatio = u, this.resize() } getBounds() { return this.transform.getBounds() } getMaxBounds() { return this.transform.getMaxBounds() } setMaxBounds(u) { return this.transform.setMaxBounds(we.convert(u)), this._update() } setMinZoom(u) { if ((u = u ?? -2) >= -2 && u <= this.transform.maxZoom) return this.transform.setMinZoom(u), this._update(), this.getZoom() < u && this.setZoom(u), this; throw new Error("minZoom must be between -2 and the current maxZoom, inclusive") } getMinZoom() { return this.transform.minZoom } setMaxZoom(u) { if ((u = u ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(u), this._update(), this.getZoom() > u && this.setZoom(u), this; throw new Error("maxZoom must be greater than the current minZoom") } getMaxZoom() { return this.transform.maxZoom } setMinPitch(u) { if ((u = u ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0"); if (u >= 0 && u <= this.transform.maxPitch) return this.transform.setMinPitch(u), this._update(), this.getPitch() < u && this.setPitch(u), this; throw new Error("minPitch must be between 0 and the current maxPitch, inclusive") } getMinPitch() { return this.transform.minPitch } setMaxPitch(u) { if ((u = u ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180"); if (u >= this.transform.minPitch) return this.transform.setMaxPitch(u), this._update(), this.getPitch() > u && this.setPitch(u), this; throw new Error("maxPitch must be greater than the current minPitch") } getMaxPitch() { return this.transform.maxPitch } getRenderWorldCopies() { return this.transform.renderWorldCopies } setRenderWorldCopies(u) { return this.transform.setRenderWorldCopies(u), this._update() } project(u) { return this.transform.locationToScreenPoint(c.Q.convert(u), this.style && this.terrain) } unproject(u) { return this.transform.screenPointToLocation(c.P.convert(u), this.terrain) } isMoving() { var u; return this._moving || ((u = this.handlers) === null || u === void 0 ? void 0 : u.isMoving()) } isZooming() { var u; return this._zooming || ((u = this.handlers) === null || u === void 0 ? void 0 : u.isZooming()) } isRotating() { var u; return this._rotating || ((u = this.handlers) === null || u === void 0 ? void 0 : u.isRotating()) } _createDelegatedListener(u, e, i) { if (u === "mouseenter" || u === "mouseover") { let o = !1; return { layers: e, listener: i, delegates: { mousemove: h => { const f = e.filter(v => this.getLayer(v)), g = f.length !== 0 ? this.queryRenderedFeatures(h.point, { layers: f }) : []; g.length ? o || (o = !0, i.call(this, new di(u, this, h.originalEvent, { features: g }))) : o = !1 }, mouseout: () => { o = !1 } } } } if (u === "mouseleave" || u === "mouseout") { let o = !1; return { layers: e, listener: i, delegates: { mousemove: f => { const g = e.filter(v => this.getLayer(v)); (g.length !== 0 ? this.queryRenderedFeatures(f.point, { layers: g }) : []).length ? o = !0 : o && (o = !1, i.call(this, new di(u, this, f.originalEvent))) }, mouseout: f => { o && (o = !1, i.call(this, new di(u, this, f.originalEvent))) } } } } { const o = a => { const h = e.filter(g => this.getLayer(g)), f = h.length !== 0 ? this.queryRenderedFeatures(a.point, { layers: h }) : []; f.length && (a.features = f, i.call(this, a), delete a.features) }; return { layers: e, listener: i, delegates: { [u]: o } } } } _saveDelegatedListener(u, e) { this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[u] = this._delegatedListeners[u] || [], this._delegatedListeners[u].push(e) } _removeDelegatedListener(u, e, i) { if (!this._delegatedListeners || !this._delegatedListeners[u]) return; const o = this._delegatedListeners[u]; for (let a = 0; a < o.length; a++) { const h = o[a]; if (h.listener === i && h.layers.length === e.length && h.layers.every(f => e.includes(f))) { for (const f in h.delegates) this.off(f, h.delegates[f]); return void o.splice(a, 1) } } } on(u, e, i) { if (i === void 0) return super.on(u, e); const o = typeof e == "string" ? [e] : e, a = this._createDelegatedListener(u, o, i); this._saveDelegatedListener(u, a); for (const h in a.delegates) this.on(h, a.delegates[h]); return { unsubscribe: () => { this._removeDelegatedListener(u, o, i) } } } once(u, e, i) { if (i === void 0) return super.once(u, e); const o = typeof e == "string" ? [e] : e, a = this._createDelegatedListener(u, o, i); for (const h in a.delegates) { const f = a.delegates[h]; a.delegates[h] = (...g) => { this._removeDelegatedListener(u, o, i), f(...g) } } this._saveDelegatedListener(u, a); for (const h in a.delegates) this.once(h, a.delegates[h]); return this } off(u, e, i) { return i === void 0 ? super.off(u, e) : (this._removeDelegatedListener(u, typeof e == "string" ? [e] : e, i), this) } queryRenderedFeatures(u, e) { if (!this.style) return []; let i; const o = u instanceof c.P || Array.isArray(u), a = o ? u : [[0, 0], [this.transform.width, this.transform.height]]; if (e = e || (o ? {} : u) || {}, a instanceof c.P || typeof a[0] == "number") i = [c.P.convert(a)]; else { const h = c.P.convert(a[0]), f = c.P.convert(a[1]); i = [h, new c.P(f.x, h.y), f, new c.P(h.x, f.y), h] } return this.style.queryRenderedFeatures(i, e, this.transform) } querySourceFeatures(u, e) { return this.style.querySourceFeatures(u, e) } setStyle(u, e) { return (e = c.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && u ? (this._diffStyle(u, e), this) : (this._localIdeographFontFamily = e.localIdeographFontFamily, this._updateStyle(u, e)) } setTransformRequest(u) { return this._requestManager.setTransformRequest(u), this } _getUIString(u) { const e = this._locale[u]; if (e == null) throw new Error(`Missing UI string '${u}'`); return e } _updateStyle(u, e) { var i, o; if (e.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(u, e)); const a = this.style && e.transformStyle ? this.style.serialize() : void 0; return this.style && (this.style.setEventedParent(null), this.style._remove(!u)), u ? (this.style = new Ys(this, e || {}), this.style.setEventedParent(this, { style: this.style }), typeof u == "string" ? this.style.loadURL(u, e, a) : this.style.loadJSON(u, e, a), this) : ((o = (i = this.style) === null || i === void 0 ? void 0 : i.projection) === null || o === void 0 || o.destroy(), delete this.style, this) } _lazyInitEmptyStyle() { this.style || (this.style = new Ys(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty()) } _diffStyle(u, e) { if (typeof u == "string") { const i = this._requestManager.transformRequest(u, "Style"); c.j(i, new AbortController).then(o => { this._updateDiff(o.data, e) }).catch(o => { o && this.fire(new c.k(o)) }) } else typeof u == "object" && this._updateDiff(u, e) } _updateDiff(u, e) { try { this.style.setState(u, e) && this._update(!0) } catch (i) { c.w(`Unable to perform style diff: ${i.message || i.error || i}.  Rebuilding the style from scratch.`), this._updateStyle(u, e) } } getStyle() { if (this.style) return this.style.serialize() } isStyleLoaded() { return this.style ? this.style.loaded() : c.w("There is no style added to the map.") } addSource(u, e) { return this._lazyInitEmptyStyle(), this.style.addSource(u, e), this._update(!0) } isSourceLoaded(u) { const e = this.style && this.style.sourceCaches[u]; if (e !== void 0) return e.loaded(); this.fire(new c.k(new Error(`There is no source with ID '${u}'`))) } setTerrain(u) { if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), u) { const e = this.style.sourceCaches[u.source]; if (!e) throw new Error(`cannot load terrain, because there exists no source with ID: ${u.source}`); this.terrain === null && e.reload(); for (const i in this.style._layers) { const o = this.style._layers[i]; o.type === "hillshade" && o.source === u.source && c.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.") } this.terrain = new hn(this.painter, e, u), this.painter.renderToTexture = new pi(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = i => { i.dataType === "style" ? this.terrain.sourceCache.freeRtt() : i.dataType === "source" && i.tile && (i.sourceId !== u.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), this.terrain.sourceCache.freeRtt(i.tile.tileID)) }, this.style.on("data", this._terrainDataCallback) } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0); return this.fire(new c.l("terrain", { terrain: u })), this } getTerrain() { var u, e; return (e = (u = this.terrain) === null || u === void 0 ? void 0 : u.options) !== null && e !== void 0 ? e : null } areTilesLoaded() { const u = this.style && this.style.sourceCaches; for (const e in u) { const i = u[e]._tiles; for (const o in i) { const a = i[o]; if (a.state !== "loaded" && a.state !== "errored") return !1 } } return !0 } removeSource(u) { return this.style.removeSource(u), this._update(!0) } getSource(u) { return this.style.getSource(u) } addImage(u, e, i = {}) { const { pixelRatio: o = 1, sdf: a = !1, stretchX: h, stretchY: f, content: g, textFitWidth: v, textFitHeight: w } = i; if (this._lazyInitEmptyStyle(), !(e instanceof HTMLImageElement || c.b(e))) { if (e.width === void 0 || e.height === void 0) return this.fire(new c.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))); { const { width: I, height: E, data: A } = e, B = e; return this.style.addImage(u, { data: new c.R({ width: I, height: E }, new Uint8Array(A)), pixelRatio: o, stretchX: h, stretchY: f, content: g, textFitWidth: v, textFitHeight: w, sdf: a, version: 0, userImage: B }), B.onAdd && B.onAdd(this, u), this } } { const { width: I, height: E, data: A } = Le.getImageData(e); this.style.addImage(u, { data: new c.R({ width: I, height: E }, A), pixelRatio: o, stretchX: h, stretchY: f, content: g, textFitWidth: v, textFitHeight: w, sdf: a, version: 0 }) } } updateImage(u, e) { const i = this.style.getImage(u); if (!i) return this.fire(new c.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead."))); const o = e instanceof HTMLImageElement || c.b(e) ? Le.getImageData(e) : e, { width: a, height: h, data: f } = o; if (a === void 0 || h === void 0) return this.fire(new c.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))); if (a !== i.data.width || h !== i.data.height) return this.fire(new c.k(new Error("The width and height of the updated image must be that same as the previous version of the image"))); const g = !(e instanceof HTMLImageElement || c.b(e)); return i.data.replace(f, g), this.style.updateImage(u, i), this } getImage(u) { return this.style.getImage(u) } hasImage(u) { return u ? !!this.style.getImage(u) : (this.fire(new c.k(new Error("Missing required image id"))), !1) } removeImage(u) { this.style.removeImage(u) } loadImage(u) { return ot.getImage(this._requestManager.transformRequest(u, "Image"), new AbortController) } listImages() { return this.style.listImages() } addLayer(u, e) { return this._lazyInitEmptyStyle(), this.style.addLayer(u, e), this._update(!0) } moveLayer(u, e) { return this.style.moveLayer(u, e), this._update(!0) } removeLayer(u) { return this.style.removeLayer(u), this._update(!0) } getLayer(u) { return this.style.getLayer(u) } getLayersOrder() { return this.style.getLayersOrder() } setLayerZoomRange(u, e, i) { return this.style.setLayerZoomRange(u, e, i), this._update(!0) } setFilter(u, e, i = {}) { return this.style.setFilter(u, e, i), this._update(!0) } getFilter(u) { return this.style.getFilter(u) } setPaintProperty(u, e, i, o = {}) { return this.style.setPaintProperty(u, e, i, o), this._update(!0) } getPaintProperty(u, e) { return this.style.getPaintProperty(u, e) } setLayoutProperty(u, e, i, o = {}) { return this.style.setLayoutProperty(u, e, i, o), this._update(!0) } getLayoutProperty(u, e) { return this.style.getLayoutProperty(u, e) } setGlyphs(u, e = {}) { return this._lazyInitEmptyStyle(), this.style.setGlyphs(u, e), this._update(!0) } getGlyphs() { return this.style.getGlyphsUrl() } addSprite(u, e, i = {}) { return this._lazyInitEmptyStyle(), this.style.addSprite(u, e, i, o => { o || this._update(!0) }), this } removeSprite(u) { return this._lazyInitEmptyStyle(), this.style.removeSprite(u), this._update(!0) } getSprite() { return this.style.getSprite() } setSprite(u, e = {}) { return this._lazyInitEmptyStyle(), this.style.setSprite(u, e, i => { i || this._update(!0) }), this } setLight(u, e = {}) { return this._lazyInitEmptyStyle(), this.style.setLight(u, e), this._update(!0) } getLight() { return this.style.getLight() } setSky(u, e = {}) { return this._lazyInitEmptyStyle(), this.style.setSky(u, e), this._update(!0) } getSky() { return this.style.getSky() } setFeatureState(u, e) { return this.style.setFeatureState(u, e), this._update() } removeFeatureState(u, e) { return this.style.removeFeatureState(u, e), this._update() } getFeatureState(u) { return this.style.getFeatureState(u) } getContainer() { return this._container } getCanvasContainer() { return this._canvasContainer } getCanvas() { return this._canvas } _containerDimensions() { let u = 0, e = 0; return this._container && (u = this._container.clientWidth || 400, e = this._container.clientHeight || 300), [u, e] } _setupContainer() { const u = this._container; u.classList.add("maplibregl-map"); const e = this._canvasContainer = ae.create("div", "maplibregl-canvas-container", u); this._interactive && e.classList.add("maplibregl-interactive"), this._canvas = ae.create("canvas", "maplibregl-canvas", e), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"); const i = this._containerDimensions(), o = this._getClampedPixelRatio(i[0], i[1]); this._resizeCanvas(i[0], i[1], o); const a = this._controlContainer = ae.create("div", "maplibregl-control-container", u), h = this._controlPositions = {};["top-left", "top-right", "bottom-left", "bottom-right"].forEach(f => { h[f] = ae.create("div", `maplibregl-ctrl-${f} `, a) }), this._container.addEventListener("scroll", this._onMapScroll, !1) } _resizeCanvas(u, e, i) { this._canvas.width = Math.floor(i * u), this._canvas.height = Math.floor(i * e), this._canvas.style.width = `${u}px`, this._canvas.style.height = `${e}px` } _setupPainter() { const u = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 }); let e = null; this._canvas.addEventListener("webglcontextcreationerror", o => { e = { requestedAttributes: u }, o && (e.statusMessage = o.statusMessage, e.type = o.type) }, { once: !0 }); let i = null; if (i = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, u) : this._canvas.getContext("webgl2", u) || this._canvas.getContext("webgl", u), !i) { const o = "Failed to initialize WebGL"; throw e ? (e.message = o, new Error(JSON.stringify(e))) : new Error(o) } this.painter = new tu(i, this.transform), Ge.testSupport(i) } migrateProjection(u, e) { super.migrateProjection(u, e), this.painter.transform = u, this.fire(new c.l("projectiontransition", { newProjection: this.style.projection.name })) } loaded() { return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded() } _update(u) { return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || u, this._sourcesDirty = !0, this.triggerRepaint(), this) : this } _requestRenderFrame(u) { return this._update(), this._renderTaskQueue.add(u) } _cancelRenderFrame(u) { this._renderTaskQueue.remove(u) } _render(u) { var e, i, o, a, h; const f = this._idleTriggered ? this._fadeDuration : 0, g = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0; if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(u), this._removed) return; let v = !1; if (this.style && this._styleDirty) { this._styleDirty = !1; const E = this.transform.zoom, A = Le.now(); this.style.zoomHistory.update(E, A); const B = new c.C(E, { now: A, fadeDuration: f, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), j = B.crossFadingFactor(); j === 1 && j === this._crossFadingFactor || (v = !0, this._crossFadingFactor = j), this.style.update(B) } const w = ((i = this.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0 !== g; (o = this.style.projection) === null || o === void 0 || o.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState, (h = this.style.projection) === null || h === void 0 ? void 0 : h.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || w) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, f, this._crossSourceCollisions, w), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: f, showPadding: this.showPadding }), this.fire(new c.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, c.cf.mark(c.cg.load), this.fire(new c.l("load"))), this.style && (this.style.hasTransitions() || v) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(); const I = this._sourcesDirty || this._styleDirty || this._placementDirty; return I || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new c.l("idle")), !this._loaded || this._fullyLoaded || I || (this._fullyLoaded = !0, c.cf.mark(c.cg.fullLoad)), this } redraw() { return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this } remove() { var u; this._hash && this._hash.remove(); for (const i of this._controls) i.onRemove(this); this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), ot.removeThrottleControl(this._imageQueueHandle), (u = this._resizeObserver) === null || u === void 0 || u.disconnect(); const e = this.painter.context.gl.getExtension("WEBGL_lose_context"); e != null && e.loseContext && e.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), ae.remove(this._canvasContainer), ae.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), c.cf.clearMetrics(), this._removed = !0, this.fire(new c.l("remove")) } triggerRepaint() { this.style && !this._frameRequest && (this._frameRequest = new AbortController, Le.frame(this._frameRequest, u => { c.cf.frame(u), this._frameRequest = null; try { this._render(u) } catch (e) { if (!c.ch(e) && !function (i) { return i.message === Xc }(e)) throw e } }, () => { })) } get showTileBoundaries() { return !!this._showTileBoundaries } set showTileBoundaries(u) { this._showTileBoundaries !== u && (this._showTileBoundaries = u, this._update()) } get showPadding() { return !!this._showPadding } set showPadding(u) { this._showPadding !== u && (this._showPadding = u, this._update()) } get showCollisionBoxes() { return !!this._showCollisionBoxes } set showCollisionBoxes(u) { this._showCollisionBoxes !== u && (this._showCollisionBoxes = u, u ? this.style._generateCollisionBoxes() : this._update()) } get showOverdrawInspector() { return !!this._showOverdrawInspector } set showOverdrawInspector(u) { this._showOverdrawInspector !== u && (this._showOverdrawInspector = u, this._update()) } get repaint() { return !!this._repaint } set repaint(u) { this._repaint !== u && (this._repaint = u, this.triggerRepaint()) } get vertices() { return !!this._vertices } set vertices(u) { this._vertices = u, this._update() } get version() { return mu } getCameraTargetElevation() { return this.transform.elevation } getProjection() { return this.style.getProjection() } setProjection(u) { return this._lazyInitEmptyStyle(), this.style.setProjection(u), this._update(!0) } }, P.MapMouseEvent = di, P.MapTouchEvent = fr, P.MapWheelEvent = Ml, P.Marker = ho, P.NavigationControl = class { constructor(u) { this._updateZoomButtons = () => { const e = this._map.getZoom(), i = e === this._map.getMaxZoom(), o = e === this._map.getMinZoom(); this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString()) }, this._rotateCompassArrow = () => { this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)` }, this._setButtonTitle = (e, i) => { const o = this._map._getUIString(`NavigationControl.${i}`); e.title = o, e.setAttribute("aria-label", o) }, this.options = c.e({}, ca, u), this._container = ae.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", e => e.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", e => this._map.zoomIn({}, { originalEvent: e })), ae.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", e => this._map.zoomOut({}, { originalEvent: e })), ae.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", e => { this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e }) }), this._compassIcon = ae.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true")) } onAdd(u) { return this._map = u, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Bl(this._map, this._compass, this.options.visualizePitch)), this._container } onRemove() { ae.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map } _createButton(u, e) { const i = ae.create("button", u, this._container); return i.type = "button", i.addEventListener("click", e), i } }, P.Popup = class extends c.E { constructor(u) { super(), this._updateOpacity = () => { this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : void 0) }, this.remove = () => (this._content && ae.remove(this._content), this._container && (ae.remove(this._container), delete this._container), this._closeButton && this._closeButton.removeEventListener("click", this._onClose), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new c.l("close"))), this), this._onMouseUp = e => { this._update(e.point) }, this._onMouseMove = e => { this._update(e.point) }, this._onDrag = e => { this._update(e.point) }, this._update = e => { var i; if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return; if (!this._container) { if (this._container = ae.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = ae.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const g of this.options.className.split(" ")) this._container.classList.add(g); this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer") } if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? ua(this._lngLat, this._flatPos, this._map.transform) : (i = this._lngLat) === null || i === void 0 ? void 0 : i.wrap(), this._trackPointer && !e) return; const o = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat); this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat)); let a = this.options.anchor; const h = fa(this.options.offset); if (!a) { const g = this._container.offsetWidth, v = this._container.offsetHeight; let w; w = o.y + h.bottom.y < v ? ["top"] : o.y > this._map.transform.height - v ? ["bottom"] : [], o.x < g / 2 ? w.push("left") : o.x > this._map.transform.width - g / 2 && w.push("right"), a = w.length === 0 ? "bottom" : w.join("-") } let f = o.add(h[a]); this.options.subpixelPositioning || (f = f.round()), ae.setTransform(this._container, `${ts[a]} translate(${f.x}px,${f.y}px)`), ha(this._container, a, "popup"), this._updateOpacity() }, this._onClose = () => { this.remove() }, this.options = c.e(Object.create(pa), u) } addTo(u) { return this._map && this.remove(), this._map = u, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new c.l("open")), this } isOpen() { return !!this._map } getLngLat() { return this._lngLat } setLngLat(u) { return this._lngLat = c.Q.convert(u), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this } trackPointer() { return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this } getElement() { return this._container } setText(u) { return this.setDOMContent(document.createTextNode(u)) } setHTML(u) { const e = document.createDocumentFragment(), i = document.createElement("body"); let o; for (i.innerHTML = u; o = i.firstChild, o;)e.appendChild(o); return this.setDOMContent(e) } getMaxWidth() { var u; return (u = this._container) === null || u === void 0 ? void 0 : u.style.maxWidth } setMaxWidth(u) { return this.options.maxWidth = u, this._update(), this } setDOMContent(u) { if (this._content) for (; this._content.hasChildNodes();)this._content.firstChild && this._content.removeChild(this._content.firstChild); else this._content = ae.create("div", "maplibregl-popup-content", this._container); return this._content.appendChild(u), this._createCloseButton(), this._update(), this._focusFirstElement(), this } addClassName(u) { return this._container && this._container.classList.add(u), this } removeClassName(u) { return this._container && this._container.classList.remove(u), this } setOffset(u) { return this.options.offset = u, this._update(), this } toggleClassName(u) { if (this._container) return this._container.classList.toggle(u) } setSubpixelPositioning(u) { this.options.subpixelPositioning = u } _createCloseButton() { this.options.closeButton && (this._closeButton = ae.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose)) } _focusFirstElement() { if (!this.options.focusAfterOpen || !this._container) return; const u = this._container.querySelector(Vl); u && u.focus() } }, P.RasterDEMTileSource = Xe, P.RasterTileSource = Oe, P.ScaleControl = class { constructor(u) { this._onMove = () => { da(this._map, this._container, this.options) }, this.setUnit = e => { this.options.unit = e, da(this._map, this._container, this.options) }, this.options = Object.assign(Object.assign({}, jl), u) } getDefaultPosition() { return "bottom-left" } onAdd(u) { return this._map = u, this._container = ae.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", u.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container } onRemove() { ae.remove(this._container), this._map.off("move", this._onMove), this._map = void 0 } }, P.ScrollZoomHandler = du, P.Style = Ys, P.TerrainControl = class { constructor(u) { this._toggleTerrain = () => { this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon() }, this._updateTerrainIcon = () => { this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable")) }, this.options = u } onAdd(u) { return this._map = u, this._container = ae.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = ae.create("button", "maplibregl-ctrl-terrain", this._container), ae.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container } onRemove() { ae.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0 } }, P.TwoFingersTouchPitchHandler = Al, P.TwoFingersTouchRotateHandler = hu, P.TwoFingersTouchZoomHandler = uu, P.TwoFingersTouchZoomRotateHandler = Rl, P.VectorTileSource = Be, P.VideoSource = Ve, P.addSourceType = (u, e) => c._(void 0, void 0, void 0, function* () { if (ct(u)) throw new Error(`A source type called "${u}" already exists.`); ((i, o) => { Ke[i] = o })(u, e) }), P.clearPrewarmedResources = function () { const u = ur; u && (u.isPreloaded() && u.numActive() === 1 ? (u.release(lr), ur = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()")) }, P.createTileMesh = Ks, P.getMaxParallelImageRequests = function () { return c.a.MAX_PARALLEL_IMAGE_REQUESTS }, P.getRTLTextPluginStatus = function () { return Pt().getRTLTextPluginStatus() }, P.getVersion = function () { return ma }, P.getWorkerCount = function () { return gi.workerCount }, P.getWorkerUrl = function () { return c.a.WORKER_URL }, P.importScriptInWorkers = function (u) { return Gr().broadcast("IS", u) }, P.prewarm = function () { xr().acquire(lr) }, P.setMaxParallelImageRequests = function (u) { c.a.MAX_PARALLEL_IMAGE_REQUESTS = u }, P.setRTLTextPlugin = function (u, e) { return Pt().setRTLTextPlugin(u, e) }, P.setWorkerCount = function (u) { gi.workerCount = u }, P.setWorkerUrl = function (u) { c.a.WORKER_URL = u }
      }); var Z = S; return Z
    })
  }($u)), $u.exports
} var zv = Av(); const Da = Cv(zv), y_ = (m, x) => { const S = m.__vccOpts || m; for (const [z, F] of x) S[z] = F; return S }, mm = { version: 8, sources: { osm: { type: "raster", tiles: ["https://a.tile.openstreetmap.org/{z}/{x}/{y}.png"], tileSize: 256, attribution: "© OpenStreetMap Contributors" } }, layers: [{ id: "osm", type: "raster", source: "osm", minzoom: 0, maxzoom: 19 }] }, kv = {
  data() { return { map: null, style: mm, center: [-122.67419412732124, 45.52024728220982], facilityLabels: { ABL: "Advisory Bike Lane", BBBL: "Bike Lane Buffered by Bus Lane", BL: "Bike Lane", BBL: "Buffered Bike Lane", ESR: "Enhanced Shared Roadway", LSB: "Local Service Bikeway", NG: "Neighborhood Greenway", PBL: "Protected Bike Lane", SBBL: "Shared Bus-Bike Lane", SIR: "Separated in-roadway", TRL: "Off-Street Path/Trail" }, facilityClasses: { "Class 1": ["NG", "TRL"], "Class 2": ["ABL", "BBBL", "BL", "BBL", "SBBL"], "Class 3": ["ESR", "LSB"], "Class 4": ["PBL", "SIR"] }, classColors: { "Class 1": "#FBAD18", "Class 2": "#F0565F", "Class 3": "#3862AE", "Class 4": "#4BC0B1" } } }, mounted() { this.initializeMap() }, beforeUnmount() { this.map && this.map.remove() }, methods: {
    initializeMap() { this.map = new Da.Map({ container: "map-container", style: mm, center: this.center, zoom: 13 }), this.map.addControl(new Da.NavigationControl), this.map.on("load", () => { this.map.setPaintProperty("osm", "raster-opacity", .25), this.loadBikeFacilities(), this.createJeremyHouseMarker() }) }, loadBikeFacilities() { fetch("data/portland-bike-facilities.geojson").then(x => { if (!x.ok) throw new Error(`Failed to load data: ${x.status} ${x.statusText}`); return x.json() }).then(x => { if (console.log("Successfully loaded GeoJSON data:", x), !x.features || x.features.length === 0) { console.error("GeoJSON has no features"); return } this.map.addSource("bike-facilities", { type: "geojson", data: x }); const S = "Facility", z = "Status"; Object.entries(this.facilityClasses).forEach(([F, Z]) => { const P = ["any"]; Z.forEach(c => { P.push(["==", ["get", S], c]) }), this.map.addLayer({ id: `${F}-existing`, type: "line", source: "bike-facilities", layout: { "line-join": "round", "line-cap": "round" }, paint: { "line-color": this.classColors[F], "line-width": 4, "line-opacity": .9, "line-blur": .5 }, filter: ["all", P, ["==", ["get", z], "ACTIVE"]] }), this.map.addLayer({ id: `${F}-planned`, type: "line", source: "bike-facilities", layout: { "line-join": "round", "line-cap": "round" }, paint: { "line-color": this.classColors[F], "line-width": 3, "line-dasharray": [2, 2] }, filter: ["all", P, ["any", ["==", ["get", z], "PLANNED"], ["==", ["get", z], "RECOMM"]]] }) }), this.addPopups(S, z), this.addCursorInteraction(), x.features && x.features.length > 0 && this.fitMapToBounds(x) }).catch(x => { console.error("Error loading bike facility data:", x) }) }, findFacilityTypeField(m) { const x = ["FACILITYTYPE", "FACILITY_TYPE", "TYPE", "BIKETYPE", "BIKE_TYPE", "FACILITY"]; for (const S of x) if (m[S] !== void 0) return S; return Object.keys(m)[0] }, findStatusField(m) { const x = ["STATUS", "FACSTATUS", "FAC_STATUS", "STATE"]; for (const S of x) if (m[S] !== void 0) return S; return "STATUS" }, getFacilityClass(m) { for (const [x, S] of Object.entries(this.facilityClasses)) if (S.includes(m)) return x; return "Unclassified" }, getFacilityLabel(m) { return this.facilityLabels[m] || m }, fitMapToBounds(m) { try { const x = new Da.LngLatBounds; let S = !1; m.features.forEach(z => { z.geometry && z.geometry.coordinates && (z.geometry.type === "LineString" ? z.geometry.coordinates.forEach(F => { x.extend(F), S = !0 }) : z.geometry.type === "MultiLineString" ? z.geometry.coordinates.forEach(F => { F.forEach(Z => { x.extend(Z), S = !0 }) }) : z.geometry.type === "Point" && (x.extend(z.geometry.coordinates), S = !0)) }), S ? (this.map.fitBounds(x, { padding: 50 }), this.map.setZoom(13)) : console.warn("No valid coordinates found to fit bounds") } catch (x) { console.error("Error fitting bounds:", x), this.map.setCenter(this.center), this.map.setZoom(13) } }, addPopups(m, x) {
      this.map.on("click", S => {
        const z = []; Object.keys(this.facilityClasses).forEach(xe => { z.push(`${xe}-existing`), z.push(`${xe}-planned`) }); const F = this.map.queryRenderedFeatures(S.point, { layers: z }); if (!F.length) return; const Z = F[0], P = Z.properties[m], c = Z.properties[x], de = Z.properties.SegmentName || "Unnamed", ze = this.getFacilityClass(P); new Da.Popup().setLngLat(S.lngLat).setHTML(`
              <h3>Bike Facility</h3>
              <p><strong>Type:</strong> ${this.facilityLabels[P] || P}</p>
              <p><strong>Class:</strong> ${ze}</p>
              <p><strong>Street:</strong> ${de}</p>
              <p><strong>Status:</strong> ${c}</p>
          `).addTo(this.map)
      })
    }, addCursorInteraction() { const m = []; Object.keys(this.facilityClasses).forEach(x => { m.push(`${x}-existing`), m.push(`${x}-planned`) }), m.forEach(x => { this.map.on("mouseenter", x, () => { this.map.getCanvas().style.cursor = "pointer" }), this.map.on("mouseleave", x, () => { this.map.getCanvas().style.cursor = "" }) }) }, createJeremyHouseMarker() { const m = [-122.664292, 45.648232], x = document.createElement("div"); x.className = "custom-marker", x.style.width = "25px", x.style.height = "25px", new Da.Marker(x).setLngLat(m).setPopup(new Da.Popup({ offset: 25 }).setHTML("<h3>Hire me! 🙏</h3>")).addTo(this.map) }
  }
}; function Dv(m, x, S, z, F, Z) { return u_(), h_("div", null, x[0] || (x[0] = [wo("div", { id: "map-container" }, null, -1)])) } const Rv = y_(kv, [["render", Dv], ["__scopeId", "data-v-c8634007"]]), Lv = Jy({ __name: "App", setup(m) { return (x, S) => (u_(), h_("main", null, [S[0] || (S[0] = wo("div", { class: "hero" }, [wo("img", { src: Iv, width: "100" }), wo("h2", null, "Portland Bike Facilities Map"), wo("cite", null, "by Jeremy Wilson")], -1)), Zs(Rv)])) } }), Fv = y_(Lv, [["__scopeId", "data-v-af927f63"]]); Pv(Fv).mount("#app");
